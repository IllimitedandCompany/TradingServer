'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import any from 'promise.any';
class DomainClient {
    /**
   * Returns domain client domain
   * @returns {String} client domain
   */ get domain() {
        return this._domain;
    }
    /**
   * Returns domain client token
   * @returns {String} client token
   */ get token() {
        return this._token;
    }
    /**
   * Sends a CopyFactory API request
   * @param {Object} opts options request options
   * @param {Boolean} isExtendedTimeout whether to run the request with an extended timeout
   * @returns {Object|String|any} request result
   */ requestCopyFactory(opts, isExtendedTimeout = false) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._updateHost();
            const regionIndex = _this._regionIndex;
            try {
                return yield _this._httpClient.request(Object.assign({}, opts, {
                    url: _this._urlCache.url + opts.url
                }), isExtendedTimeout);
            } catch (err) {
                if (![
                    'ConflictError',
                    'InternalError',
                    'ApiError',
                    'TimeoutError'
                ].includes(err.name)) {
                    throw err;
                } else {
                    if (_this._regionCache.length === _this._regionIndex + 1) {
                        _this._regionIndex = 0;
                        throw err;
                    } else {
                        if (_this._regionIndex === regionIndex) {
                            _this._regionIndex++;
                        }
                        return yield _this.requestCopyFactory(opts, isExtendedTimeout);
                    }
                }
            }
        })();
    }
    /**
   * Sends an http request
   * @param {Object} opts options request options
   * @returns {Object|String|any} request result
   */ request(opts) {
        return this._httpClient.request(opts);
    }
    /**
   * Sends a signal client request
   * @param {Object} opts options request options 
   * @param {Object} host signal client host data
   * @param {String} accountId account id
   * @returns {Object|String|any} request result
   */ requestSignal(opts, host, accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._updateAccountRegions(host, accountId);
            try {
                return yield any(host.regions.map((region)=>{
                    return _this._httpClient.requestWithFailover(Object.assign({}, opts, {
                        url: `${host.host}.${region}.${host.domain}` + opts.url,
                        headers: {
                            'auth-token': _this._token
                        }
                    }));
                }));
            } catch (error) {
                throw error.errors[0];
            }
        })();
    }
    /**
   * Returns CopyFactory host for signal client requests
   * @param {String[]} regions subscriber regions
   * @returns {String} signal client CopyFactory host
   */ getSignalClientHost(regions) {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this._updateHost();
            return {
                host: 'https://copyfactory-api-v1',
                regions,
                lastUpdated: Date.now(),
                domain: _this._urlCache.domain
            };
        })();
    }
    /**
   * Account request info
   * @typedef {Object} AccountInfo
   * @property {String} id primary account id
   * @property {String[]} regions account available regions
   */ /**
   * Returns account data by id
   * @param {String} accountId account id
   * @returns {AccountInfo} account data
   */ getAccountInfo(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            const getAccount = function() {
                var _ref = _async_to_generator(function*(id) {
                    const accountOpts = {
                        url: `https://mt-provisioning-api-v1.${_this.domain}/users/current/accounts/${id}`,
                        method: 'GET',
                        headers: {
                            'auth-token': _this.token
                        },
                        json: true
                    };
                    return yield _this._httpClient.requestWithFailover(accountOpts);
                });
                return function getAccount(id) {
                    return _ref.apply(this, arguments);
                };
            }();
            let accountData = yield getAccount(accountId);
            let primaryAccountId = '';
            if (accountData.primaryAccountId) {
                primaryAccountId = accountData.primaryAccountId;
                accountData = yield getAccount(primaryAccountId);
            } else {
                primaryAccountId = accountData._id;
            }
            let regions = [
                accountData.region
            ].concat(accountData.accountReplicas && accountData.accountReplicas.map((replica)=>replica.region) || []);
            return {
                id: primaryAccountId,
                regions
            };
        })();
    }
    _updateHost() {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this._urlCache || _this._urlCache.lastUpdated < Date.now() - 1000 * 60 * 10) {
                yield _this._updateRegions();
                const urlSettings = yield _this._httpClient.request({
                    url: `https://mt-provisioning-api-v1.${_this._domain}/users/current/servers/mt-client-api`,
                    method: 'GET',
                    headers: {
                        'auth-token': _this._token
                    },
                    json: true
                });
                _this._urlCache = {
                    url: `https://copyfactory-api-v1.${_this._regionCache[_this._regionIndex]}.${urlSettings.domain}`,
                    domain: urlSettings.domain,
                    lastUpdated: Date.now()
                };
            } else {
                _this._urlCache = {
                    url: `https://copyfactory-api-v1.${_this._regionCache[_this._regionIndex]}.${_this._urlCache.domain}`,
                    domain: _this._urlCache.domain,
                    lastUpdated: Date.now()
                };
            }
        })();
    }
    _updateRegions() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._regionCache = yield _this._httpClient.request({
                url: `https://mt-provisioning-api-v1.${_this._domain}/users/current/regions`,
                method: 'GET',
                headers: {
                    'auth-token': _this._token
                },
                json: true
            });
            _this._regionIndex = 0;
        })();
    }
    _updateAccountRegions(host, accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (host.lastUpdated < Date.now() - 1000 * 60 * 10) {
                const accountData = yield _this.getAccountInfo(accountId);
                host.lastUpdated = Date.now();
                host.regions = accountData.regions;
            }
        })();
    }
    /**
   * Constructs domain client instance
   * @param {HttpClient} httpClient HTTP client
   * @param {String} token authorization token
   * @param {String} domain domain to connect to, default is agiliumtrade.agiliumtrade.ai
   */ constructor(httpClient, token, domain = 'agiliumtrade.agiliumtrade.ai'){
        this._httpClient = httpClient;
        this._domain = domain;
        this._token = token;
        this._urlCache = null;
        this._regionCache = [];
        this._regionIndex = 0;
    }
}
/**
 * Connection URL and request managing client
 */ export { DomainClient as default };
