"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SubscriptionManager;
    }
});
const _logger = /*#__PURE__*/ _interop_require_default(require("../../logger"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let SubscriptionManager = class SubscriptionManager {
    /**
   * Returns whether an account is currently subscribing
   * @param {String} accountId account id
   * @param {Number} instanceNumber instance index number
   * @returns {Boolean} whether an account is currently subscribing
   */ isAccountSubscribing(accountId, instanceNumber) {
        if (instanceNumber !== undefined) {
            return Object.keys(this._subscriptions).includes(accountId + ":" + instanceNumber);
        } else {
            for (let key of Object.keys(this._subscriptions)){
                if (key.startsWith(accountId)) {
                    return true;
                }
            }
            return false;
        }
    }
    /**
   * Returns whether an instance is in disconnected retry mode
   * @param {String} accountId account id
   * @param {Number} instanceNumber instance index number
   * @returns {Boolean} whether an account is currently subscribing
   */ isDisconnectedRetryMode(accountId, instanceNumber) {
        let instanceId = accountId + ":" + (instanceNumber || 0);
        return this._subscriptions[instanceId] ? this._subscriptions[instanceId].isDisconnectedRetryMode : false;
    }
    /**
   * Returns whether an account subscription is active
   * @param {String} accountId account id
   * @returns {Boolean} instance actual subscribe state
   */ isSubscriptionActive(accountId) {
        return !!this._subscriptionState[accountId];
    }
    /**
   * Subscribes to the Metatrader terminal events
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when subscription started
   */ subscribe(accountId, instanceNumber) {
        this._subscriptionState[accountId] = true;
        return this._websocketClient.rpcRequest(accountId, {
            type: "subscribe",
            instanceIndex: instanceNumber
        });
    }
    /**
   * Schedules to send subscribe requests to an account until cancelled
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Boolean} isDisconnectedRetryMode whether to start subscription in disconnected retry
   * mode. Subscription task in disconnected mode will be immediately replaced when the status packet is received
   */ async scheduleSubscribe(accountId, instanceNumber, isDisconnectedRetryMode = false) {
        const client = this._websocketClient;
        let instanceId = accountId + ":" + (instanceNumber || 0);
        if (!this._subscriptions[instanceId]) {
            this._subscriptions[instanceId] = {
                shouldRetry: true,
                task: null,
                waitTask: null,
                future: null,
                isDisconnectedRetryMode
            };
            let subscribeRetryIntervalInSeconds = 3;
            while(this._subscriptions[instanceId].shouldRetry){
                let resolveSubscribe;
                this._subscriptions[instanceId].task = {
                    promise: new Promise((res)=>{
                        resolveSubscribe = res;
                    })
                };
                this._subscriptions[instanceId].task.resolve = resolveSubscribe;
                // eslint-disable-next-line no-inner-declarations, complexity
                let subscribeTask = async ()=>{
                    try {
                        await this.subscribe(accountId, instanceNumber);
                    } catch (err) {
                        if (err.name === "TooManyRequestsError") {
                            const socketInstanceIndex = client.socketInstancesByAccounts[instanceNumber][accountId];
                            if (err.metadata.type === "LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER") {
                                this._logger.error(`${instanceId}: Failed to subscribe`, err);
                            }
                            if ([
                                "LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER",
                                "LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER",
                                "LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER"
                            ].includes(err.metadata.type)) {
                                delete client.socketInstancesByAccounts[instanceNumber][accountId];
                                client.lockSocketInstance(instanceNumber, socketInstanceIndex, this._websocketClient.getAccountRegion(accountId), err.metadata);
                            } else {
                                const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
                                if (Date.now() + subscribeRetryIntervalInSeconds * 1000 < retryTime) {
                                    await new Promise((res)=>setTimeout(res, retryTime - Date.now() - subscribeRetryIntervalInSeconds * 1000));
                                }
                            }
                        } else {
                            this._logger.error(`${instanceId}: Failed to subscribe`, err);
                            if (err.name === "NotFoundError") {
                                this.refreshAccount(accountId);
                            }
                            if (err.name === "TimeoutError") {
                                const mainAccountId = this._websocketClient.accountsByReplicaId[accountId];
                                if (mainAccountId) {
                                    const region = this._websocketClient.getAccountRegion(accountId);
                                    const connectedInstances = this._websocketClient._latencyService.getActiveAccountInstances(mainAccountId);
                                    // eslint-disable-next-line max-depth
                                    if (!connectedInstances.some((instance)=>instance.startsWith(`${mainAccountId}:${region}`))) {
                                        this._timeoutErrorCounter[accountId] = this._timeoutErrorCounter[accountId] || 0;
                                        this._timeoutErrorCounter[accountId]++;
                                        // eslint-disable-next-line max-depth
                                        if (this._timeoutErrorCounter[accountId] > 4) {
                                            this._timeoutErrorCounter[accountId] = 0;
                                            this.refreshAccount(accountId);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    resolveSubscribe();
                };
                subscribeTask();
                await this._subscriptions[instanceId].task.promise;
                if (!this._subscriptions[instanceId].shouldRetry) {
                    break;
                }
                const retryInterval = subscribeRetryIntervalInSeconds;
                subscribeRetryIntervalInSeconds = Math.min(subscribeRetryIntervalInSeconds * 2, 300);
                let resolve;
                let subscribePromise = new Promise((res)=>{
                    resolve = res;
                });
                this._subscriptions[instanceId].waitTask = setTimeout(()=>{
                    resolve(true);
                }, retryInterval * 1000);
                this._subscriptions[instanceId].future = {
                    resolve,
                    promise: subscribePromise
                };
                const result = await this._subscriptions[instanceId].future.promise;
                this._subscriptions[instanceId].future = null;
                if (!result) {
                    break;
                }
            }
            delete this._subscriptions[instanceId];
        }
    }
    /**
   * Unsubscribe from account
   * @param {String} accountId id of the MetaTrader account to unsubscribe
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when socket unsubscribed
   */ async unsubscribe(accountId, instanceNumber) {
        this.cancelAccount(accountId);
        delete this._subscriptionState[accountId];
        return this._websocketClient.rpcRequest(accountId, {
            type: "unsubscribe",
            instanceIndex: instanceNumber
        });
    }
    /**
   * Cancels active subscription tasks for an instance id
   * @param {String} instanceId instance id to cancel subscription task for
   */ cancelSubscribe(instanceId) {
        if (this._subscriptions[instanceId]) {
            const subscription = this._subscriptions[instanceId];
            if (subscription.future) {
                subscription.future.resolve(false);
                clearTimeout(subscription.waitTask);
            }
            if (subscription.task) {
                subscription.task.resolve(false);
            }
            subscription.shouldRetry = false;
        }
    }
    /**
   * Cancels active subscription tasks for an account
   * @param {String} accountId account id to cancel subscription tasks for
   */ cancelAccount(accountId) {
        for (let instanceId of Object.keys(this._subscriptions).filter((key)=>key.startsWith(accountId))){
            this.cancelSubscribe(instanceId);
        }
        Object.keys(this._awaitingResubscribe).forEach((instanceNumber)=>delete this._awaitingResubscribe[instanceNumber][accountId]);
        delete this._timeoutErrorCounter[accountId];
    }
    /**
   * Invoked on account timeout.
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   */ onTimeout(accountId, instanceNumber) {
        const region = this._websocketClient.getAccountRegion(accountId);
        if (this._websocketClient.socketInstancesByAccounts[instanceNumber][accountId] !== undefined && this._websocketClient.connected(instanceNumber, this._websocketClient.socketInstancesByAccounts[instanceNumber][accountId], region)) {
            this._logger.debug(`${accountId}:${instanceNumber}: scheduling subscribe because of account timeout`);
            this.scheduleSubscribe(accountId, instanceNumber, true);
        }
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   */ async onDisconnected(accountId, instanceNumber) {
        await new Promise((res)=>setTimeout(res, Math.max(Math.random() * 5, 1) * 1000));
        if (this._websocketClient.socketInstancesByAccounts[instanceNumber][accountId] !== undefined) {
            this._logger.debug(`${accountId}:${instanceNumber}: scheduling subscribe because account disconnected`);
            this.scheduleSubscribe(accountId, instanceNumber, true);
        }
    }
    /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect.
   * @param {Number} instanceNumber instance index number
   * @param {Number} socketInstanceIndex socket instance index
   * @param {String[]} reconnectAccountIds account ids to reconnect
   */ onReconnected(instanceNumber, socketInstanceIndex, reconnectAccountIds) {
        if (!this._awaitingResubscribe[instanceNumber]) {
            this._awaitingResubscribe[instanceNumber] = {};
        }
        try {
            const socketInstancesByAccounts = this._websocketClient.socketInstancesByAccounts[instanceNumber];
            for (let instanceId of Object.keys(this._subscriptions)){
                const accountId = instanceId.split(":")[0];
                if (socketInstancesByAccounts[accountId] === socketInstanceIndex) {
                    this.cancelSubscribe(instanceId);
                }
            }
            reconnectAccountIds.forEach(async (accountId)=>{
                try {
                    if (!this._awaitingResubscribe[instanceNumber][accountId]) {
                        this._awaitingResubscribe[instanceNumber][accountId] = true;
                        while(this.isAccountSubscribing(accountId, instanceNumber)){
                            await new Promise((res)=>setTimeout(res, 1000));
                        }
                        await new Promise((res)=>setTimeout(res, Math.random() * 5000));
                        if (this._awaitingResubscribe[instanceNumber][accountId]) {
                            delete this._awaitingResubscribe[instanceNumber][accountId];
                            this._logger.debug(`${accountId}:${instanceNumber}: scheduling subscribe because account reconnected`);
                            this.scheduleSubscribe(accountId, instanceNumber);
                        }
                    }
                } catch (err) {
                    this._logger.error(`${accountId}: Account resubscribe task failed`, err);
                }
            });
        } catch (err) {
            this._logger.error("Failed to process subscribe manager reconnected event", err);
        }
    }
    /**
   * Schedules a task to refresh the account data
   * @param {string} accountId account id
   */ refreshAccount(accountId) {
        const mainAccountId = this._websocketClient.accountsByReplicaId[accountId];
        if (mainAccountId) {
            const registry = this._metaApi._connectionRegistry;
            const rpcConnection = registry.rpcConnections[mainAccountId];
            const region = this._websocketClient.getAccountRegion(accountId);
            if (region) {
                if (rpcConnection) {
                    rpcConnection.scheduleRefresh(region);
                }
                const streamingConnection = registry.streamingConnections[mainAccountId];
                if (streamingConnection) {
                    streamingConnection.scheduleRefresh(region);
                }
            }
        }
    }
    /**
   * Constructs the subscription manager
   * @param {MetaApiWebsocketClient} websocketClient websocket client to use for sending requests
   * @param {MetaApi} metaApi metaApi instance
   */ constructor(websocketClient, metaApi){
        this._websocketClient = websocketClient;
        this._metaApi = metaApi;
        this._subscriptions = {};
        this._awaitingResubscribe = {};
        this._subscriptionState = {};
        this._logger = _logger.default.getLogger("SubscriptionManager");
        this._timeoutErrorCounter = {};
        this._recentlyDeletedAccounts = {};
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5cbi8qKlxuICogU3Vic2NyaXB0aW9uIG1hbmFnZXIgdG8gaGFuZGxlIGFjY291bnQgc3Vic2NyaXB0aW9uIGxvZ2ljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1YnNjcmlwdGlvbk1hbmFnZXIge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBzdWJzY3JpcHRpb24gbWFuYWdlclxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnR9IHdlYnNvY2tldENsaWVudCB3ZWJzb2NrZXQgY2xpZW50IHRvIHVzZSBmb3Igc2VuZGluZyByZXF1ZXN0c1xuICAgKiBAcGFyYW0ge01ldGFBcGl9IG1ldGFBcGkgbWV0YUFwaSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod2Vic29ja2V0Q2xpZW50LCBtZXRhQXBpKSB7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50ID0gd2Vic29ja2V0Q2xpZW50O1xuICAgIHRoaXMuX21ldGFBcGkgPSBtZXRhQXBpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICB0aGlzLl9hd2FpdGluZ1Jlc3Vic2NyaWJlID0ge307XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGUgPSB7fTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignU3Vic2NyaXB0aW9uTWFuYWdlcicpO1xuICAgIHRoaXMuX3RpbWVvdXRFcnJvckNvdW50ZXIgPSB7fTtcbiAgICB0aGlzLl9yZWNlbnRseURlbGV0ZWRBY2NvdW50cyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKi9cbiAgaXNBY2NvdW50U3Vic2NyaWJpbmcoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGlmKGluc3RhbmNlTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5pbmNsdWRlcyhhY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoYWNjb3VudElkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBpbnN0YW5jZSBpcyBpbiBkaXNjb25uZWN0ZWQgcmV0cnkgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBhbiBhY2NvdW50IGlzIGN1cnJlbnRseSBzdWJzY3JpYmluZ1xuICAgKi9cbiAgaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGxldCBpbnN0YW5jZUlkID0gYWNjb3VudElkICsgJzonICsgKGluc3RhbmNlTnVtYmVyIHx8IDApO1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdID8gdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5pc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhY2NvdW50IHN1YnNjcmlwdGlvbiBpcyBhY3RpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpbnN0YW5jZSBhY3R1YWwgc3Vic2NyaWJlIHN0YXRlXG4gICAqL1xuICBpc1N1YnNjcmlwdGlvbkFjdGl2ZShhY2NvdW50SWQpIHtcbiAgICByZXR1cm4gISF0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZVthY2NvdW50SWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gdGhlIE1ldGF0cmFkZXIgdGVybWluYWwgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzdWJzY3JpYmUgdG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiBzdGFydGVkXG4gICAqL1xuICBzdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlW2FjY291bnRJZF0gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQucnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAnc3Vic2NyaWJlJywgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgdG8gc2VuZCBzdWJzY3JpYmUgcmVxdWVzdHMgdG8gYW4gYWNjb3VudCB1bnRpbCBjYW5jZWxsZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSB3aGV0aGVyIHRvIHN0YXJ0IHN1YnNjcmlwdGlvbiBpbiBkaXNjb25uZWN0ZWQgcmV0cnlcbiAgICogbW9kZS4gU3Vic2NyaXB0aW9uIHRhc2sgaW4gZGlzY29ubmVjdGVkIG1vZGUgd2lsbCBiZSBpbW1lZGlhdGVseSByZXBsYWNlZCB3aGVuIHRoZSBzdGF0dXMgcGFja2V0IGlzIHJlY2VpdmVkXG4gICAqL1xuICBhc3luYyBzY2hlZHVsZVN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBpc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50O1xuICAgIGxldCBpbnN0YW5jZUlkID0gYWNjb3VudElkICsgJzonICsgKGluc3RhbmNlTnVtYmVyIHx8IDApO1xuICAgIGlmKCF0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdID0ge1xuICAgICAgICBzaG91bGRSZXRyeTogdHJ1ZSxcbiAgICAgICAgdGFzazogbnVsbCxcbiAgICAgICAgd2FpdFRhc2s6IG51bGwsXG4gICAgICAgIGZ1dHVyZTogbnVsbCxcbiAgICAgICAgaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGVcbiAgICAgIH07XG4gICAgICBsZXQgc3Vic2NyaWJlUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDM7XG4gICAgICB3aGlsZSh0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnNob3VsZFJldHJ5KSB7XG4gICAgICAgIGxldCByZXNvbHZlU3Vic2NyaWJlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW2luc3RhbmNlSWRdLnRhc2sgPSB7cHJvbWlzZTogbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICAgIHJlc29sdmVTdWJzY3JpYmUgPSByZXM7XG4gICAgICAgIH0pfTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS50YXNrLnJlc29sdmUgPSByZXNvbHZlU3Vic2NyaWJlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zLCBjb21wbGV4aXR5XG4gICAgICAgIGxldCBzdWJzY3JpYmVUYXNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmKGVyci5uYW1lID09PSAnVG9vTWFueVJlcXVlc3RzRXJyb3InKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlSW5kZXggPSBjbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXTtcbiAgICAgICAgICAgICAgaWYgKGVyci5tZXRhZGF0YS50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtpbnN0YW5jZUlkfTogRmFpbGVkIHRvIHN1YnNjcmliZWAsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFsnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSJywgJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfU0VSVkVSJywgXG4gICAgICAgICAgICAgICAgJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfVVNFUl9QRVJfU0VSVkVSJ10uaW5jbHVkZXMoZXJyLm1ldGFkYXRhLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdO1xuICAgICAgICAgICAgICAgIGNsaWVudC5sb2NrU29ja2V0SW5zdGFuY2UoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIFxuICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKSwgZXJyLm1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeVRpbWUgPSBuZXcgRGF0ZShlcnIubWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSArIHN1YnNjcmliZVJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwIDwgcmV0cnlUaW1lKSB7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHJldHJ5VGltZSAtIERhdGUubm93KCkgLVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzICogMTAwMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke2luc3RhbmNlSWR9OiBGYWlsZWQgdG8gc3Vic2NyaWJlYCwgZXJyKTtcbiAgICAgICAgICAgICAgaWYoZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEFjY291bnQoYWNjb3VudElkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihlcnIubmFtZSA9PT0gJ1RpbWVvdXRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWluQWNjb3VudElkID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFjY291bnRzQnlSZXBsaWNhSWRbYWNjb3VudElkXTtcbiAgICAgICAgICAgICAgICBpZihtYWluQWNjb3VudElkKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWdpb24gPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkSW5zdGFuY2VzID0gXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50Ll9sYXRlbmN5U2VydmljZS5nZXRBY3RpdmVBY2NvdW50SW5zdGFuY2VzKG1haW5BY2NvdW50SWQpO1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgICAgaWYoIWNvbm5lY3RlZEluc3RhbmNlcy5zb21lKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7bWFpbkFjY291bnRJZH06JHtyZWdpb259YCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRFcnJvckNvdW50ZXJbYWNjb3VudElkXSA9IHRoaXMuX3RpbWVvdXRFcnJvckNvdW50ZXJbYWNjb3VudElkXSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0RXJyb3JDb3VudGVyW2FjY291bnRJZF0rKztcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLl90aW1lb3V0RXJyb3JDb3VudGVyW2FjY291bnRJZF0gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dEVycm9yQ291bnRlclthY2NvdW50SWRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hBY2NvdW50KGFjY291bnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZVN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgICAgICBzdWJzY3JpYmVUYXNrKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF0udGFzay5wcm9taXNlO1xuICAgICAgICBpZighdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5zaG91bGRSZXRyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSBzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzO1xuICAgICAgICBzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzID0gTWF0aC5taW4oc3Vic2NyaWJlUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDIsIDMwMCk7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBsZXQgc3Vic2NyaWJlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS53YWl0VGFzayA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0sIHJldHJ5SW50ZXJ2YWwgKiAxMDAwKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXS5mdXR1cmUgPSB7cmVzb2x2ZSwgcHJvbWlzZTogc3Vic2NyaWJlUHJvbWlzZX07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF0uZnV0dXJlLnByb21pc2U7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF0uZnV0dXJlID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbaW5zdGFuY2VJZF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gYWNjb3VudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gdW5zdWJzY3JpYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNvY2tldCB1bnN1YnNjcmliZWRcbiAgICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICB0aGlzLmNhbmNlbEFjY291bnQoYWNjb3VudElkKTtcbiAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVbYWNjb3VudElkXTtcbiAgICByZXR1cm4gdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3Vuc3Vic2NyaWJlJywgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFjdGl2ZSBzdWJzY3JpcHRpb24gdGFza3MgZm9yIGFuIGluc3RhbmNlIGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUlkIGluc3RhbmNlIGlkIHRvIGNhbmNlbCBzdWJzY3JpcHRpb24gdGFzayBmb3JcbiAgICovXG4gIGNhbmNlbFN1YnNjcmliZShpbnN0YW5jZUlkKSB7XG4gICAgaWYodGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXSkge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tpbnN0YW5jZUlkXTtcbiAgICAgIGlmKHN1YnNjcmlwdGlvbi5mdXR1cmUpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmZ1dHVyZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN1YnNjcmlwdGlvbi53YWl0VGFzayk7XG4gICAgICB9XG4gICAgICBpZihzdWJzY3JpcHRpb24udGFzaykge1xuICAgICAgICBzdWJzY3JpcHRpb24udGFzay5yZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmlwdGlvbi5zaG91bGRSZXRyeSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFjdGl2ZSBzdWJzY3JpcHRpb24gdGFza3MgZm9yIGFuIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIHRvIGNhbmNlbCBzdWJzY3JpcHRpb24gdGFza3MgZm9yXG4gICAqL1xuICBjYW5jZWxBY2NvdW50KGFjY291bnRJZCkge1xuICAgIGZvciAobGV0IGluc3RhbmNlSWQgb2YgT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucykuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChhY2NvdW50SWQpKSkge1xuICAgICAgdGhpcy5jYW5jZWxTdWJzY3JpYmUoaW5zdGFuY2VJZCk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmUpLmZvckVhY2goaW5zdGFuY2VOdW1iZXIgPT4gXG4gICAgICBkZWxldGUgdGhpcy5fYXdhaXRpbmdSZXN1YnNjcmliZVtpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSk7XG4gICAgZGVsZXRlIHRoaXMuX3RpbWVvdXRFcnJvckNvdW50ZXJbYWNjb3VudElkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIGFjY291bnQgdGltZW91dC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICovXG4gIG9uVGltZW91dChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICBpZih0aGlzLl93ZWJzb2NrZXRDbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdLCByZWdpb24pKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlTnVtYmVyfTogc2NoZWR1bGluZyBzdWJzY3JpYmUgYmVjYXVzZSBvZiBhY2NvdW50IHRpbWVvdXRgKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgdGVybWluYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKi9cbiAgYXN5bmMgb25EaXNjb25uZWN0ZWQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgTWF0aC5tYXgoTWF0aC5yYW5kb20oKSAqIDUsIDEpICogMTAwMCkpO1xuICAgIGlmKHRoaXMuX3dlYnNvY2tldENsaWVudC5zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBzY2hlZHVsaW5nIHN1YnNjcmliZSBiZWNhdXNlIGFjY291bnQgZGlzY29ubmVjdGVkYCk7XG4gICAgICB0aGlzLnNjaGVkdWxlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSByZWNvbm5lY3RBY2NvdW50SWRzIGFjY291bnQgaWRzIHRvIHJlY29ubmVjdFxuICAgKi9cbiAgb25SZWNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVjb25uZWN0QWNjb3VudElkcykge1xuICAgIGlmKCF0aGlzLl9hd2FpdGluZ1Jlc3Vic2NyaWJlW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgdGhpcy5fYXdhaXRpbmdSZXN1YnNjcmliZVtpbnN0YW5jZU51bWJlcl0gPSB7fTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMgPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl07XG4gICAgICBmb3IobGV0IGluc3RhbmNlSWQgb2YgT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucykpe1xuICAgICAgICBjb25zdCBhY2NvdW50SWQgPSBpbnN0YW5jZUlkLnNwbGl0KCc6JylbMF07XG4gICAgICAgIGlmIChzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2FjY291bnRJZF0gPT09IHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLmNhbmNlbFN1YnNjcmliZShpbnN0YW5jZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25uZWN0QWNjb3VudElkcy5mb3JFYWNoKGFzeW5jIGFjY291bnRJZCA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYoIXRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUodGhpcy5pc0FjY291bnRTdWJzY3JpYmluZyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSkge1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgTWF0aC5yYW5kb20oKSAqIDUwMDApKTtcbiAgICAgICAgICAgIGlmKHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0pIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F3YWl0aW5nUmVzdWJzY3JpYmVbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBzY2hlZHVsaW5nIHN1YnNjcmliZSBiZWNhdXNlIGFjY291bnQgcmVjb25uZWN0ZWRgKTtcbiAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHthY2NvdW50SWR9OiBBY2NvdW50IHJlc3Vic2NyaWJlIHRhc2sgZmFpbGVkYCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHN1YnNjcmliZSBtYW5hZ2VyIHJlY29ubmVjdGVkIGV2ZW50JywgZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgdGFzayB0byByZWZyZXNoIHRoZSBhY2NvdW50IGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqL1xuICByZWZyZXNoQWNjb3VudChhY2NvdW50SWQpIHtcbiAgICBjb25zdCBtYWluQWNjb3VudElkID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFjY291bnRzQnlSZXBsaWNhSWRbYWNjb3VudElkXTtcbiAgICBpZihtYWluQWNjb3VudElkKSB7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IHRoaXMuX21ldGFBcGkuX2Nvbm5lY3Rpb25SZWdpc3RyeTtcbiAgICAgIGNvbnN0IHJwY0Nvbm5lY3Rpb24gPSByZWdpc3RyeS5ycGNDb25uZWN0aW9uc1ttYWluQWNjb3VudElkXTtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRBY2NvdW50UmVnaW9uKGFjY291bnRJZCk7XG4gICAgICBpZihyZWdpb24pIHtcbiAgICAgICAgaWYocnBjQ29ubmVjdGlvbikge1xuICAgICAgICAgIHJwY0Nvbm5lY3Rpb24uc2NoZWR1bGVSZWZyZXNoKHJlZ2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtaW5nQ29ubmVjdGlvbiA9IHJlZ2lzdHJ5LnN0cmVhbWluZ0Nvbm5lY3Rpb25zW21haW5BY2NvdW50SWRdO1xuICAgICAgICBpZihzdHJlYW1pbmdDb25uZWN0aW9uKSB7XG4gICAgICAgICAgc3RyZWFtaW5nQ29ubmVjdGlvbi5zY2hlZHVsZVJlZnJlc2gocmVnaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6WyJTdWJzY3JpcHRpb25NYW5hZ2VyIiwiaXNBY2NvdW50U3Vic2NyaWJpbmciLCJhY2NvdW50SWQiLCJpbnN0YW5jZU51bWJlciIsInVuZGVmaW5lZCIsIk9iamVjdCIsImtleXMiLCJfc3Vic2NyaXB0aW9ucyIsImluY2x1ZGVzIiwia2V5Iiwic3RhcnRzV2l0aCIsImlzRGlzY29ubmVjdGVkUmV0cnlNb2RlIiwiaW5zdGFuY2VJZCIsImlzU3Vic2NyaXB0aW9uQWN0aXZlIiwiX3N1YnNjcmlwdGlvblN0YXRlIiwic3Vic2NyaWJlIiwiX3dlYnNvY2tldENsaWVudCIsInJwY1JlcXVlc3QiLCJ0eXBlIiwiaW5zdGFuY2VJbmRleCIsInNjaGVkdWxlU3Vic2NyaWJlIiwiY2xpZW50Iiwic2hvdWxkUmV0cnkiLCJ0YXNrIiwid2FpdFRhc2siLCJmdXR1cmUiLCJzdWJzY3JpYmVSZXRyeUludGVydmFsSW5TZWNvbmRzIiwicmVzb2x2ZVN1YnNjcmliZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVzb2x2ZSIsInN1YnNjcmliZVRhc2siLCJlcnIiLCJuYW1lIiwic29ja2V0SW5zdGFuY2VJbmRleCIsInNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJtZXRhZGF0YSIsIl9sb2dnZXIiLCJlcnJvciIsImxvY2tTb2NrZXRJbnN0YW5jZSIsImdldEFjY291bnRSZWdpb24iLCJyZXRyeVRpbWUiLCJEYXRlIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJnZXRUaW1lIiwibm93Iiwic2V0VGltZW91dCIsInJlZnJlc2hBY2NvdW50IiwibWFpbkFjY291bnRJZCIsImFjY291bnRzQnlSZXBsaWNhSWQiLCJyZWdpb24iLCJjb25uZWN0ZWRJbnN0YW5jZXMiLCJfbGF0ZW5jeVNlcnZpY2UiLCJnZXRBY3RpdmVBY2NvdW50SW5zdGFuY2VzIiwic29tZSIsImluc3RhbmNlIiwiX3RpbWVvdXRFcnJvckNvdW50ZXIiLCJyZXRyeUludGVydmFsIiwiTWF0aCIsIm1pbiIsInN1YnNjcmliZVByb21pc2UiLCJyZXN1bHQiLCJ1bnN1YnNjcmliZSIsImNhbmNlbEFjY291bnQiLCJjYW5jZWxTdWJzY3JpYmUiLCJzdWJzY3JpcHRpb24iLCJjbGVhclRpbWVvdXQiLCJmaWx0ZXIiLCJfYXdhaXRpbmdSZXN1YnNjcmliZSIsImZvckVhY2giLCJvblRpbWVvdXQiLCJjb25uZWN0ZWQiLCJkZWJ1ZyIsIm9uRGlzY29ubmVjdGVkIiwibWF4IiwicmFuZG9tIiwib25SZWNvbm5lY3RlZCIsInJlY29ubmVjdEFjY291bnRJZHMiLCJzcGxpdCIsInJlZ2lzdHJ5IiwiX21ldGFBcGkiLCJfY29ubmVjdGlvblJlZ2lzdHJ5IiwicnBjQ29ubmVjdGlvbiIsInJwY0Nvbm5lY3Rpb25zIiwic2NoZWR1bGVSZWZyZXNoIiwic3RyZWFtaW5nQ29ubmVjdGlvbiIsInN0cmVhbWluZ0Nvbm5lY3Rpb25zIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJtZXRhQXBpIiwiTG9nZ2VyTWFuYWdlciIsImdldExvZ2dlciIsIl9yZWNlbnRseURlbGV0ZWRBY2NvdW50cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7ZUFPcUJBOzs7K0RBTEs7Ozs7OztBQUtYLElBQUEsQUFBTUEsc0JBQU4sTUFBTUE7SUFrQm5COzs7OztHQUtDLEdBQ0RDLHFCQUFxQkMsU0FBUyxFQUFFQyxjQUFjLEVBQUU7UUFDOUMsSUFBR0EsbUJBQW1CQyxXQUFXO1lBQy9CLE9BQU9DLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNDLGNBQWMsRUFBRUMsUUFBUSxDQUFDTixZQUFZLE1BQU1DO1FBQ3JFLE9BQU87WUFDTCxLQUFLLElBQUlNLE9BQU9KLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNDLGNBQWMsRUFBRztnQkFDaEQsSUFBSUUsSUFBSUMsVUFBVSxDQUFDUixZQUFZO29CQUM3QixPQUFPO2dCQUNUO1lBQ0Y7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUVBOzs7OztHQUtDLEdBQ0RTLHdCQUF3QlQsU0FBUyxFQUFFQyxjQUFjLEVBQUU7UUFDakQsSUFBSVMsYUFBYVYsWUFBWSxNQUFPQyxDQUFBQSxrQkFBa0IsQ0FBQTtRQUN0RCxPQUFPLElBQUksQ0FBQ0ksY0FBYyxDQUFDSyxXQUFXLEdBQUcsSUFBSSxDQUFDTCxjQUFjLENBQUNLLFdBQVcsQ0FBQ0QsdUJBQXVCLEdBQUc7SUFDckc7SUFFQTs7OztHQUlDLEdBQ0RFLHFCQUFxQlgsU0FBUyxFQUFFO1FBQzlCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ1ksa0JBQWtCLENBQUNaLFVBQVU7SUFDN0M7SUFFQTs7Ozs7R0FLQyxHQUNEYSxVQUFVYixTQUFTLEVBQUVDLGNBQWMsRUFBRTtRQUNuQyxJQUFJLENBQUNXLGtCQUFrQixDQUFDWixVQUFVLEdBQUc7UUFDckMsT0FBTyxJQUFJ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