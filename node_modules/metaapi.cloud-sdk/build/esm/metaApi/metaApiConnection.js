'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import SynchronizationListener from '../clients/metaApi/synchronizationListener';
import LoggerManager from '../logger';
let MetaApiConnection = class MetaApiConnection extends SynchronizationListener {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @param {string} instanceId connection instance id
   * @return {Promise} promise resolving when the connection is opened
   */ connect(instanceId) {
        return _async_to_generator(function*() {})();
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   * @param {string} instanceId connection instance id
   */ close(instanceId) {
        return _async_to_generator(function*() {})();
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._account;
    }
    /**
   * Returns connection application
   * @return {String} connection application
   */ get application() {
        return this._application;
    }
    /**
   * Schedules the refresh task
   * @param {string} region replica region
   */ scheduleRefresh(region) {
        if (!this._refreshTasks[region]) {
            const delay = Math.random() * 6 * 60 * 60 * 1000;
            this._refreshTasks[region] = setTimeout(this._refreshReplicas, delay);
        }
    }
    /**
   * Cancels the scheduled refresh task
   * @param {string} region replica region
   */ cancelRefresh(region) {
        clearTimeout(this._refreshTasks[region]);
        delete this._refreshTasks[region];
    }
    /**
   * Refreshes account replicas
   */ _refreshReplicas() {
        var _this = this;
        return _async_to_generator(function*() {
            Object.values(_this._refreshTasks).forEach((task)=>clearTimeout(task));
            _this._refreshTasks = {};
            const oldReplicas = {};
            _this._account.replicas.forEach((replica)=>oldReplicas[replica.region] = replica.id);
            const newReplicas = {};
            let isAccountUpdated = false;
            try {
                yield _this._account.reload();
                isAccountUpdated = true;
                _this._account.replicas.forEach((replica)=>newReplicas[replica.region] = replica.id);
            } catch (error) {
                if (error.name === 'NotFoundError') {
                    if (_this._connectionRegistry) {
                        _this._connectionRegistry.closeAllInstances(_this._account.id);
                    }
                }
            }
            if (isAccountUpdated) {
                const deletedReplicas = {};
                const addedReplicas = {};
                Object.keys(oldReplicas).forEach((key)=>{
                    if (newReplicas[key] !== oldReplicas[key]) {
                        deletedReplicas[key] = oldReplicas[key];
                    }
                });
                Object.keys(newReplicas).forEach((key)=>{
                    if (newReplicas[key] !== oldReplicas[key]) {
                        addedReplicas[key] = newReplicas[key];
                    }
                });
                if (Object.keys(deletedReplicas).length) {
                    Object.values(deletedReplicas).forEach((replicaId)=>_this._websocketClient.onAccountDeleted(replicaId));
                }
                if (Object.keys(deletedReplicas).length || Object.keys(addedReplicas).length) {
                    newReplicas[_this._account.region] = _this._account.id;
                    _this._websocketClient.updateAccountCache(_this._account.id, newReplicas);
                    Object.values(_this._account.accountRegions).forEach((instance)=>{
                        _this._websocketClient.ensureSubscribe(instance, 0);
                        _this._websocketClient.ensureSubscribe(instance, 1);
                    });
                }
            }
        })();
    }
    _ensureSynchronized(instanceIndex, key) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            if (state && !_this._closed) {
                try {
                    const synchronizationResult = yield _this.synchronize(instanceIndex);
                    if (synchronizationResult) {
                        state.synchronized = true;
                        state.synchronizationRetryIntervalInSeconds = 1;
                    }
                } catch (err) {
                    _this._logger.error('MetaApi websocket client for account ' + _this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
                    if (state.shouldSynchronize === key) {
                        setTimeout(_this._ensureSynchronized.bind(_this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
                        state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
                    }
                }
            }
        })();
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex['' + instanceIndex]) {
            this._stateByInstanceIndex['' + instanceIndex] = {
                instanceIndex,
                ordersSynchronized: {},
                dealsSynchronized: {},
                shouldSynchronize: undefined,
                synchronizationRetryIntervalInSeconds: 1,
                synchronized: false,
                lastDisconnectedSynchronizationId: undefined,
                lastSynchronizationId: undefined,
                disconnected: false
            };
        }
        return this._stateByInstanceIndex['' + instanceIndex];
    }
    _checkIsConnectionActive() {
        if (!this._opened) {
            throw new Error('This connection has not been initialized yet, please invoke await connection.connect()');
        }
        if (this._closed) {
            throw new Error('This connection has been closed, please create a new connection');
        }
    }
    /**
   * Constructs MetaApi MetaTrader Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {String} [application] application to use
   */ constructor(websocketClient, account, application){
        super();
        this._websocketClient = websocketClient;
        this._account = account;
        this._logger = LoggerManager.getLogger('MetaApiConnection');
        this._application = application;
        this._refreshReplicas = this._refreshReplicas.bind(this);
        this._refreshTasks = {};
    }
};
/**
 * Exposes MetaApi MetaTrader API connection to consumers
 */ export { MetaApiConnection as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uTGlzdGVuZXInO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vbG9nZ2VyJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBBUEkgY29ubmVjdGlvbiB0byBjb25zdW1lcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YUFwaUNvbm5lY3Rpb24gZXh0ZW5kcyBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgTWV0YUFwaSBNZXRhVHJhZGVyIEFwaSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50fSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBpZCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYXBwbGljYXRpb25dIGFwcGxpY2F0aW9uIHRvIHVzZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod2Vic29ja2V0Q2xpZW50LCBhY2NvdW50LCBhcHBsaWNhdGlvbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50ID0gd2Vic29ja2V0Q2xpZW50O1xuICAgIHRoaXMuX2FjY291bnQgPSBhY2NvdW50O1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdNZXRhQXBpQ29ubmVjdGlvbicpO1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgdGhpcy5fcmVmcmVzaFJlcGxpY2FzID0gdGhpcy5fcmVmcmVzaFJlcGxpY2FzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVmcmVzaFRhc2tzID0ge307XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbm5lY3Rpb24uIENhbiBvbmx5IGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSwgbmV4dCBjYWxscyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoaW5zdGFuY2VJZCkge31cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLiBUaGUgaW5zdGFuY2Ugb2YgdGhlIGNsYXNzIHNob3VsZCBubyBsb25nZXIgYmUgdXNlZCBhZnRlciB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJZCBjb25uZWN0aW9uIGluc3RhbmNlIGlkXG4gICAqL1xuICBhc3luYyBjbG9zZShpbnN0YW5jZUlkKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFBcGkgYWNjb3VudFxuICAgKiBAcmV0dXJuIHtNZXRhdHJhZGVyQWNjb3VudH0gTWV0YUFwaSBhY2NvdW50XG4gICAqL1xuICBnZXQgYWNjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbm5lY3Rpb24gYXBwbGljYXRpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBjb25uZWN0aW9uIGFwcGxpY2F0aW9uXG4gICAqL1xuICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwcGxpY2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyB0aGUgcmVmcmVzaCB0YXNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpb24gcmVwbGljYSByZWdpb25cbiAgICovXG4gIHNjaGVkdWxlUmVmcmVzaChyZWdpb24pIHtcbiAgICBpZighdGhpcy5fcmVmcmVzaFRhc2tzW3JlZ2lvbl0pIHtcbiAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5yYW5kb20oKSAqIDYgKiA2MCAqIDYwICogMTAwMDtcbiAgICAgIHRoaXMuX3JlZnJlc2hUYXNrc1tyZWdpb25dID0gc2V0VGltZW91dCh0aGlzLl9yZWZyZXNoUmVwbGljYXMsIGRlbGF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgc2NoZWR1bGVkIHJlZnJlc2ggdGFza1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaW9uIHJlcGxpY2EgcmVnaW9uXG4gICAqL1xuICBjYW5jZWxSZWZyZXNoKHJlZ2lvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoVGFza3NbcmVnaW9uXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hUYXNrc1tyZWdpb25dO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyBhY2NvdW50IHJlcGxpY2FzXG4gICAqL1xuICBhc3luYyBfcmVmcmVzaFJlcGxpY2FzKCkge1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5fcmVmcmVzaFRhc2tzKS5mb3JFYWNoKHRhc2sgPT4gY2xlYXJUaW1lb3V0KHRhc2spKTtcbiAgICB0aGlzLl9yZWZyZXNoVGFza3MgPSB7fTtcbiAgICBjb25zdCBvbGRSZXBsaWNhcyA9IHt9O1xuICAgIHRoaXMuX2FjY291bnQucmVwbGljYXMuZm9yRWFjaChyZXBsaWNhID0+IG9sZFJlcGxpY2FzW3JlcGxpY2EucmVnaW9uXSA9IHJlcGxpY2EuaWQpO1xuICAgIGNvbnN0IG5ld1JlcGxpY2FzID0ge307XG4gICAgbGV0IGlzQWNjb3VudFVwZGF0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fYWNjb3VudC5yZWxvYWQoKTtcbiAgICAgIGlzQWNjb3VudFVwZGF0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fYWNjb3VudC5yZXBsaWNhcy5mb3JFYWNoKHJlcGxpY2EgPT4gbmV3UmVwbGljYXNbcmVwbGljYS5yZWdpb25dID0gcmVwbGljYS5pZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmKGVycm9yLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICBpZih0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkuY2xvc2VBbGxJbnN0YW5jZXModGhpcy5fYWNjb3VudC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYoaXNBY2NvdW50VXBkYXRlZCkge1xuICAgICAgY29uc3QgZGVsZXRlZFJlcGxpY2FzID0ge307XG4gICAgICBjb25zdCBhZGRlZFJlcGxpY2FzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhvbGRSZXBsaWNhcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZihuZXdSZXBsaWNhc1trZXldICE9PSBvbGRSZXBsaWNhc1trZXldKSB7XG4gICAgICAgICAgZGVsZXRlZFJlcGxpY2FzW2tleV0gPSBvbGRSZXBsaWNhc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKG5ld1JlcGxpY2FzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmKG5ld1JlcGxpY2FzW2tleV0gIT09IG9sZFJlcGxpY2FzW2tleV0pIHtcbiAgICAgICAgICBhZGRlZFJlcGxpY2FzW2tleV0gPSBuZXdSZXBsaWNhc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmKE9iamVjdC5rZXlzKGRlbGV0ZWRSZXBsaWNhcykubGVuZ3RoKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoZGVsZXRlZFJlcGxpY2FzKS5mb3JFYWNoKHJlcGxpY2FJZCA9PiBcbiAgICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQub25BY2NvdW50RGVsZXRlZChyZXBsaWNhSWQpKTtcbiAgICAgIH1cbiAgICAgIGlmKE9iamVjdC5rZXlzKGRlbGV0ZWRSZXBsaWNhcykubGVuZ3RoIHx8IE9iamVjdC5rZXlzKGFkZGVkUmVwbGljYXMpLmxlbmd0aCkge1xuICAgICAgICBuZXdSZXBsaWNhc1t0aGlzLl9hY2NvdW50LnJlZ2lvbl0gPSB0aGlzLl9hY2NvdW50LmlkO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQudXBkYXRlQWNjb3VudENhY2hlKHRoaXMuX2FjY291bnQuaWQsIG5ld1JlcGxpY2FzKTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zKS5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKGluc3RhbmNlLCAwKTtcbiAgICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKGluc3RhbmNlLCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2Vuc3VyZVN5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBrZXkpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3luY2hyb25pemF0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy5zeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KTtcbiAgICAgICAgaWYoc3luY2hyb25pemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemVkID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGZvciBhY2NvdW50ICcgKyB0aGlzLl9hY2NvdW50LmlkICtcbiAgICAgICAgICAnOicgKyBpbnN0YW5jZUluZGV4ICsgJyBmYWlsZWQgdG8gc3luY2hyb25pemUnLCBlcnIpO1xuICAgICAgICBpZiAoc3RhdGUuc2hvdWxkU3luY2hyb25pemUgPT09IGtleSkge1xuICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fZW5zdXJlU3luY2hyb25pemVkLmJpbmQodGhpcywgaW5zdGFuY2VJbmRleCwga2V5KSxcbiAgICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzID0gTWF0aC5taW4oc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDIsIDMwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSkge1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSA9IHtcbiAgICAgICAgaW5zdGFuY2VJbmRleCxcbiAgICAgICAgb3JkZXJzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgZGVhbHNTeW5jaHJvbml6ZWQ6IHt9LFxuICAgICAgICBzaG91bGRTeW5jaHJvbml6ZTogdW5kZWZpbmVkLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzOiAxLFxuICAgICAgICBzeW5jaHJvbml6ZWQ6IGZhbHNlLFxuICAgICAgICBsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGRpc2Nvbm5lY3RlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdO1xuICB9XG5cbiAgX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCkge1xuICAgIGlmKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQsIHBsZWFzZSBpbnZva2UgYXdhaXQgY29ubmVjdGlvbi5jb25uZWN0KCknKTtcbiAgICB9XG4gICAgaWYodGhpcy5fY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQsIHBsZWFzZSBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbicpO1xuICAgIH1cbiAgfVxuXG59XG4iXSwibmFtZXMiOlsiU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJMb2dnZXJNYW5hZ2VyIiwiTWV0YUFwaUNvbm5lY3Rpb24iLCJjb25uZWN0IiwiaW5zdGFuY2VJZCIsImNsb3NlIiwiYWNjb3VudCIsIl9hY2NvdW50IiwiYXBwbGljYXRpb24iLCJfYXBwbGljYXRpb24iLCJzY2hlZHVsZVJlZnJlc2giLCJyZWdpb24iLCJfcmVmcmVzaFRhc2tzIiwiZGVsYXkiLCJNYXRoIiwicmFuZG9tIiwic2V0VGltZW91dCIsIl9yZWZyZXNoUmVwbGljYXMiLCJjYW5jZWxSZWZyZXNoIiwiY2xlYXJUaW1lb3V0IiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInRhc2siLCJvbGRSZXBsaWNhcyIsInJlcGxpY2FzIiwicmVwbGljYSIsImlkIiwibmV3UmVwbGljYXMiLCJpc0FjY291bnRVcGRhdGVkIiwicmVsb2FkIiwiZXJyb3IiLCJuYW1lIiwiX2Nvbm5lY3Rpb25SZWdpc3RyeSIsImNsb3NlQWxsSW5zdGFuY2VzIiwiZGVsZXRlZFJlcGxpY2FzIiwiYWRkZWRSZXBsaWNhcyIsImtleXMiLCJrZXkiLCJsZW5ndGgiLCJyZXBsaWNhSWQiLCJfd2Vic29ja2V0Q2xpZW50Iiwib25BY2NvdW50RGVsZXRlZCIsInVwZGF0ZUFjY291bnRDYWNoZSIsImFjY291bnRSZWdpb25zIiwiaW5zdGFuY2UiLCJlbnN1cmVTdWJzY3JpYmUiLCJfZW5zdXJlU3luY2hyb25pemVkIiwiaW5zdGFuY2VJbmRleCIsInN0YXRlIiwiX2dldFN0YXRlIiwiX2Nsb3NlZCIsInN5bmNocm9uaXphdGlvblJlc3VsdCIsInN5bmNocm9uaXplIiwic3luY2hyb25pemVkIiwic3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyIsImVyciIsIl9sb2dnZXIiLCJzaG91bGRTeW5jaHJvbml6ZSIsImJpbmQiLCJtaW4iLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJvcmRlcnNTeW5jaHJvbml6ZWQiLCJkZWFsc1N5bmNocm9uaXplZCIsInVuZGVmaW5lZCIsImxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCIsImxhc3RTeW5jaHJvbml6YXRpb25JZCIsImRpc2Nvbm5lY3RlZCIsIl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSIsIl9vcGVuZWQiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwid2Vic29ja2V0Q2xpZW50IiwiZ2V0TG9nZ2VyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsT0FBT0EsNkJBQTZCLDZDQUE2QztBQUNqRixPQUFPQyxtQkFBbUIsWUFBWTtBQUt2QixJQUFBLEFBQU1DLG9CQUFOLE1BQU1BLDBCQUEwQkY7SUFrQjdDOzs7O0dBSUMsR0FDRCxBQUFNRyxRQUFRQyxVQUFVO2VBQXhCLG9CQUFBLGFBQTJCOztJQUUzQjs7O0dBR0MsR0FDRCxBQUFNQyxNQUFNRCxVQUFVO2VBQXRCLG9CQUFBLGFBQXlCOztJQUV6Qjs7O0dBR0MsR0FDRCxJQUFJRSxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNDLFFBQVE7SUFDdEI7SUFFQTs7O0dBR0MsR0FDRCxJQUFJQyxjQUFjO1FBQ2hCLE9BQU8sSUFBSSxDQUFDQyxZQUFZO0lBQzFCO0lBRUE7OztHQUdDLEdBQ0RDLGdCQUFnQkMsTUFBTSxFQUFFO1FBQ3RCLElBQUcsQ0FBQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0QsT0FBTyxFQUFFO1lBQzlCLE1BQU1FLFFBQVFDLEtBQUtDLE1BQU0sS0FBSyxJQUFJLEtBQUssS0FBSztZQUM1QyxJQUFJLENBQUNILGFBQWEsQ0FBQ0QsT0FBTyxHQUFHSyxXQUFXLElBQUksQ0FBQ0MsZ0JBQWdCLEVBQUVKO1FBQ2pFO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDREssY0FBY1AsTUFBTSxFQUFFO1FBQ3BCUSxhQUFhLElBQUksQ0FBQ1AsYUFBYSxDQUFDRCxPQUFPO1FBQ3ZDLE9BQU8sSUFBSSxDQUFDQyxhQUFhLENBQUNELE9BQU87SUFDbkM7SUFFQTs7R0FFQyxHQUNELEFBQU1NOztlQUFOLG9CQUFBO1lBQ0VHLE9BQU9DLE1BQU0sQ0FBQyxNQUFLVCxhQUFhLEVBQUVVLE9BQU8sQ0FBQ0MsQ0FBQUEsT0FBUUosYUFBYUk7WUFDL0QsTUFBS1gsYUFBYSxHQUFHLENBQUM7WUFDdEIsTUFBTVksY0FBYyxDQUFDO1lBQ3JCLE1BQUtqQixRQUFRLENBQUNrQixRQUFRLENBQUNILE9BQU8sQ0FBQ0ksQ0FBQUEsVUFBV0YsV0FBVyxDQUFDRSxRQUFRZixNQUFNLENBQUMsR0FBR2UsUUFBUUMsRUFBRTtZQUNsRixNQUFNQyxjQUFjLENBQUM7WUFDckIsSUFBSUMsbUJBQW1CO1lBQ3ZCLElBQUk7Z0JBQ0YsTUFBTSxNQUFLdEIsUUFBUSxDQUFDdUIsTUFBTTtnQkFDMUJELG1CQUFtQjtnQkFDbkIsTUFBS3RCLFFBQVEsQ0FBQ2tCLFFBQVEsQ0FBQ0gsT0FBTyxDQUFDSSxDQUFBQSxVQUFXRSxXQUFXLENBQUNGLFFBQVFmLE1BQU0sQ0FBQyxHQUFHZSxRQUFRQyxFQUFFO1lBQ3BGLEVBQUUsT0FBT0ksT0FBTztnQkFDZCxJQUFHQSxNQUFNQyxJQUFJLEtBQUssaUJBQWlCO29CQUNqQyxJQUFHLE1BQUtDLG1CQUFtQixFQUFFO3dCQUMzQixNQUFLQSxtQkFBbUIsQ0FBQ0MsaUJBQWlCLENBQUMsTUFBSzNCLFFBQVEsQ0FBQ29CLEVBQUU7b0JBQzdEO2dCQUNGO1lBQ0Y7WUFDQSxJQUFHRSxrQkFBa0I7Z0JBQ25CLE1BQU1NLGtCQUFrQixDQUFDO2dCQUN6QixNQUFNQyxnQkFBZ0IsQ0FBQztnQkFDdkJoQixPQUFPaUIsSUFBSSxDQUFDYixhQUFhRixPQUFPLENBQUNnQixDQUFBQTtvQkFDL0IsSUFBR1YsV0FBVyxDQUFDVSxJQUFJLEtBQUtkLFdBQVcsQ0FBQ2MsSUFBSSxFQUFFO3dCQUN4Q0gsZUFBZSxDQUFDRyxJQUFJLEdBQUdkLFdBQVcsQ0FBQ2MsSUFBSTtvQkFDekM7Z0JBQ0Y7Z0JBQ0FsQixPQUFPaUIsSUFBSSxDQUFDVCxhQUFhTixPQUFPLENBQUNnQixDQUFBQTtvQkFDL0IsSUFBR1YsV0FBVyxDQUFDVSxJQUFJLEtBQUtkLFdBQVcsQ0FBQ2MsSUFBSSxFQUFFO3dCQUN4Q0YsYUFBYSxDQUFDRSxJQUFJLEdBQUdWLFdBQVcsQ0FBQ1UsSUFBSTtvQkFDdkM7Z0JBQ0Y7Z0JBQ0EsSUFBR2xCLE9BQU9pQixJQUFJLENBQUNGLGlCQUFpQkksTUFBTSxFQUFFO29CQUN0Q25CLE9BQU9DLE1BQU0sQ0FBQ2MsaUJBQWlCYixPQUFPLENBQUNrQixDQUFBQSxZQUNyQyxNQUFLQyxnQkFBZ0IsQ0FBQ0MsZ0JBQWdCLENBQUNGO2dCQUMzQztnQkFDQSxJQUFHcEIsT0FBT2lCLElBQUksQ0FBQ0YsaUJBQWlCSSxNQUFNLElBQUluQixPQUFPaUIsSUFBSSxDQUFDRCxlQUFlRyxNQUFNLEVBQUU7b0JBQzNFWCxXQUFXLENBQUMsTUFBS3JCLFFBQVEsQ0FBQ0ksTUFBTSxDQUFDLEdBQUcsTUFBS0osUUFBUSxDQUFDb0IsRUFBRTtvQkFDcEQsTUFBS2MsZ0JBQWdCLENBQUNFLGtCQUFrQixDQUFDLE1BQUtwQyxRQUFRLENBQUNvQixFQUFFLEVBQUVDO29CQUMzRFIsT0FBT0MsTUFBTSxDQUFDLE1BQUtkLFFBQVEsQ0FBQ3FDLGNBQWMsRUFBRXRCLE9BQU8sQ0FBQ3VCLENBQUFBO3dCQUNsRCxNQUFLSixnQkFBZ0IsQ0FBQ0ssZUFBZSxDQUFDRCxVQUFVO3dCQUNoRCxNQUFLSixnQkFBZ0IsQ0FBQ0ssZUFBZSxDQUFDRCxVQUFVO29CQUNsRDtnQkFDRjtZQUNGO1FBQ0Y7O0lBRU1FLG9CQUFvQkMsYUFBYSxFQUFFVixHQUFHOztlQUE1QyxvQkFBQTtZQUNFLElBQUlXLFFBQVEsTUFBS0MsU0FBUyxDQUFDRjtZQUMzQixJQUFJQyxTQUFTLENBQUMsTUFBS0UsT0FBTyxFQUFFO2dCQUMxQixJQUFJO29CQUNGLE1BQU1DLHdCQUF3QixNQUFNLE1BQUtDLFdBQVcsQ0FBQ0w7b0JBQ3JELElBQUdJLHVCQUF1Qjt3QkFDeEJILE1BQU1LLFlBQVksR0FBRzt3QkFDckJMLE1BQU1NLHFDQUFxQyxHQUFHO29CQUNoRDtnQkFDRixFQUFFLE9BQU9DLEtBQUs7b0JBQ1osTUFBS0MsT0FBTyxDQUFDMUIsS0FBSyxDQUFDLDBDQUEwQyxNQUFLeEIsUUFBUSxDQUFDb0IsRUFBRSxHQUMzRSxNQUFNcUIsZ0JBQWdCLDBCQUEwQlE7b0JBQ2xELElBQUlQLE1BQU1TLGlCQUFpQixLQUFLcEIsS0FBSzt3QkFDbkN0QixXQUFXLE1BQUsrQixtQkFBbUIsQ0FBQ1ksSUFBSSxRQUFPWCxlQUFlVixNQUM1RFcsTUFBTU0scUNBQXFDLEdBQUc7d0JBQ2hETixNQUFNTSxxQ0FBcUMsR0FBR3pDLEtBQUs4QyxHQUFHLENBQUNYLE1BQU1NLHFDQUFxQyxHQUFHLEdBQUc7b0JBQzFHO2dCQUNGO1lBQ0Y7UUFDRjs7SUFFQUwsVUFBVUYsYUFBYSxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUNhLHFCQUFxQixDQUFDLEtBQUtiLGNBQWMsRUFBRTtZQUNuRCxJQUFJLENBQUNhLHFCQUFxQixDQUFDLEtBQUtiLGNBQWMsR0FBRztnQkFDL0NBO2dCQUNBYyxvQkFBb0IsQ0FBQztnQkFDckJDLG1CQUFtQixDQUFDO2dCQUNwQkwsbUJBQW1CTTtnQkFDbkJULHVDQUF1QztnQkFDdkNELGNBQWM7Z0JBQ2RXLG1DQUFtQ0Q7Z0JBQ25DRSx1QkFBdUJGO2dCQUN2QkcsY0FBYztZQUNoQjtRQUNGO1FBQ0EsT0FBTyxJQUFJLENBQUNOLHFCQUFxQixDQUFDLEtBQUtiLGNBQWM7SUFDdkQ7SUFFQW9CLDJCQUEyQjtRQUN6QixJQUFHLENBQUMsSUFBSSxDQUFDQyxPQUFPLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsSUFBRyxJQUFJLENBQUNuQixPQUFPLEVBQUU7WUFDZixNQUFNLElBQUltQixNQUFNO1FBQ2xCO0lBQ0Y7SUEvSkE7Ozs7O0dBS0MsR0FDREMsWUFBWUMsZUFBZSxFQUFFbEUsT0FBTyxFQUFFRSxXQUFXLENBQUU7UUFDakQsS0FBSztRQUNMLElBQUksQ0FBQ2lDLGdCQUFnQixHQUFHK0I7UUFDeEIsSUFBSSxDQUFDakUsUUFBUSxHQUFHRDtRQUNoQixJQUFJLENBQUNtRCxPQUFPLEdBQUd4RCxjQUFjd0UsU0FBUyxDQUFDO1FBQ3ZDLElBQUksQ0FBQ2hFLFlBQVksR0FBR0Q7UUFDcEIsSUFBSSxDQUFDUyxnQkFBZ0IsR0FBRyxJQUFJLENBQUNBLGdCQUFnQixDQUFDMEMsSUFBSSxDQUFDLElBQUk7UUFDdkQsSUFBSSxDQUFDL0MsYUFBYSxHQUFHLENBQUM7SUFDeEI7QUFtSkY7QUF0S0E7O0NBRUMsR0FDRCxTQUFxQlYsK0JBbUtwQiJ9