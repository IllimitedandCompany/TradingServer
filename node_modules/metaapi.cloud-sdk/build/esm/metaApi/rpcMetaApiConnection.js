'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import LoggerManager from '../logger';
import MetaApiConnection from './metaApiConnection';
import TimeoutError from '../clients/timeoutError';
let RpcMetaApiConnection = class RpcMetaApiConnection extends MetaApiConnection {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @param {string} instanceId connection instance id
   * @return {Promise} promise resolving when the connection is opened
   */ connect(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this._openedInstances.includes(instanceId)) {
                _this._openedInstances.push(instanceId);
            }
            if (!_this._opened) {
                _this._opened = true;
                const accountRegions = _this._account.accountRegions;
                _this._websocketClient.addAccountCache(_this._account.id, accountRegions);
                Object.keys(accountRegions).forEach((region)=>{
                    _this._websocketClient.ensureSubscribe(accountRegions[region], 0);
                    _this._websocketClient.ensureSubscribe(accountRegions[region], 1);
                });
            }
        })();
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   * @param {string} instanceId connection instance id
   */ close(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._opened) {
                _this._openedInstances = _this._openedInstances.filter((id)=>id !== instanceId);
                if (!_this._openedInstances.length && !_this._closed) {
                    clearInterval(_this._refreshJob);
                    yield _this._connectionRegistry.removeRpc(_this.account);
                    _this._websocketClient.removeSynchronizationListener(_this.account.id, _this);
                    _this._websocketClient.removeAccountCache(_this.account.id);
                    _this._websocketClient.removeReconnectListener(_this);
                    _this._closed = true;
                }
            }
        })();
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onConnected(instanceIndex, replicas) {
        var _this = this;
        return _async_to_generator(function*() {
            const state = _this._getState(instanceIndex);
            state.synchronized = true;
            const region = _this.getRegion(instanceIndex);
            _this.cancelRefresh(region);
        })();
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onDisconnected(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            const state = _this._getState(instanceIndex);
            state.synchronized = false;
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: disconnected from broker`);
        })();
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   */ onStreamClosed(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            delete _this._stateByInstanceIndex[instanceIndex];
        })();
    }
    /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @returns {Boolean} a flag indicating status of state synchronization with MetaTrader terminal
   */ isSynchronized() {
        return Object.values(this._stateByInstanceIndex).map((instance)=>instance.synchronized).includes(true);
    }
    /**
   * Waits until synchronization to RPC application is completed
   * @param {Number} timeoutInSeconds synchronization timeout in seconds. Defaults to 5 minutes
   * @return {Promise} promise which resolves when synchronization to RPC application is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */ waitSynchronized(timeoutInSeconds = 300) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            const startTime = Date.now();
            let synchronized = _this.isSynchronized();
            while(!synchronized && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield new Promise((res)=>setTimeout(res, 1000));
                synchronized = _this.isSynchronized();
            }
            if (!synchronized) {
                throw new TimeoutError('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + _this._account.id);
            }
            // eslint-disable-next-line
            while(true){
                try {
                    yield _this._websocketClient.waitSynchronized(_this._account.id, undefined, 'RPC', 5, 'RPC');
                    break;
                } catch (err) {
                    if (Date.now() > startTime + timeoutInSeconds * 1000) {
                        throw err;
                    }
                }
            }
        })();
    }
    /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @param {String} region reconnected region
   * @param {Number} instanceNumber reconnected instance number
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */ onReconnected(region, instanceNumber) {
        var _this = this;
        return _async_to_generator(function*() {
            const instanceTemplate = `${region}:${instanceNumber}`;
            Object.keys(_this._stateByInstanceIndex).filter((key)=>key.startsWith(`${instanceTemplate}:`)).forEach((key)=>{
                delete _this._stateByInstanceIndex[key];
            });
        })();
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex[instanceIndex]) {
            this._stateByInstanceIndex[instanceIndex] = {
                instanceIndex,
                synchronized: false
            };
        }
        return this._stateByInstanceIndex[instanceIndex];
    }
    /**
   * Constructs MetaApi MetaTrader RPC Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   */ constructor(websocketClient, account, connectionRegistry){
        super(websocketClient, account, 'RPC');
        this._connectionRegistry = connectionRegistry;
        this._websocketClient.addSynchronizationListener(account.id, this);
        this._stateByInstanceIndex = {};
        this._openedInstances = [];
        Object.values(account.accountRegions).forEach((replicaId)=>this._websocketClient.addReconnectListener(this, replicaId));
        this._logger = LoggerManager.getLogger('MetaApiConnection');
    }
};
/**
 * Exposes MetaApi MetaTrader RPC API connection to consumers
 */ export { RpcMetaApiConnection as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5pbXBvcnQgTG9nZ2VyTWFuYWdlciBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IE1ldGFBcGlDb25uZWN0aW9uIGZyb20gJy4vbWV0YUFwaUNvbm5lY3Rpb24nO1xuaW1wb3J0IFRpbWVvdXRFcnJvciBmcm9tICcuLi9jbGllbnRzL3RpbWVvdXRFcnJvcic7XG5cbi8qKlxuICogRXhwb3NlcyBNZXRhQXBpIE1ldGFUcmFkZXIgUlBDIEFQSSBjb25uZWN0aW9uIHRvIGNvbnN1bWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBScGNNZXRhQXBpQ29ubmVjdGlvbiBleHRlbmRzIE1ldGFBcGlDb25uZWN0aW9uIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBNZXRhQXBpIE1ldGFUcmFkZXIgUlBDIEFwaSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50fSBhY2NvdW50IE1ldGFUcmFkZXIgYWNjb3VudCBpZCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvblJlZ2lzdHJ5fSBjb25uZWN0aW9uUmVnaXN0cnkgbWV0YXRyYWRlciBhY2NvdW50IGNvbm5lY3Rpb24gcmVnaXN0cnlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdlYnNvY2tldENsaWVudCwgYWNjb3VudCwgY29ubmVjdGlvblJlZ2lzdHJ5KSB7XG4gICAgc3VwZXIod2Vic29ja2V0Q2xpZW50LCBhY2NvdW50LCAnUlBDJyk7XG4gICAgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5ID0gY29ubmVjdGlvblJlZ2lzdHJ5O1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzKTtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX29wZW5lZEluc3RhbmNlcyA9IFtdO1xuICAgIE9iamVjdC52YWx1ZXMoYWNjb3VudC5hY2NvdW50UmVnaW9ucylcbiAgICAgIC5mb3JFYWNoKHJlcGxpY2FJZCA9PiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkUmVjb25uZWN0TGlzdGVuZXIodGhpcywgcmVwbGljYUlkKSk7XG4gICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyTWFuYWdlci5nZXRMb2dnZXIoJ01ldGFBcGlDb25uZWN0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbm5lY3Rpb24uIENhbiBvbmx5IGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSwgbmV4dCBjYWxscyB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoaW5zdGFuY2VJZCkge1xuICAgIGlmKCF0aGlzLl9vcGVuZWRJbnN0YW5jZXMuaW5jbHVkZXMoaW5zdGFuY2VJZCkpIHtcbiAgICAgIHRoaXMuX29wZW5lZEluc3RhbmNlcy5wdXNoKGluc3RhbmNlSWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX29wZW5lZCkge1xuICAgICAgdGhpcy5fb3BlbmVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFjY291bnRSZWdpb25zID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9ucztcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRBY2NvdW50Q2FjaGUodGhpcy5fYWNjb3VudC5pZCwgYWNjb3VudFJlZ2lvbnMpO1xuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudFJlZ2lvbnMpLmZvckVhY2gocmVnaW9uID0+IHtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZShhY2NvdW50UmVnaW9uc1tyZWdpb25dLCAwKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZShhY2NvdW50UmVnaW9uc1tyZWdpb25dLCAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGFzeW5jIGNsb3NlKGluc3RhbmNlSWQpIHtcbiAgICBpZih0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRoaXMuX29wZW5lZEluc3RhbmNlcyA9IHRoaXMuX29wZW5lZEluc3RhbmNlcy5maWx0ZXIoaWQgPT4gaWQgIT09IGluc3RhbmNlSWQpO1xuICAgICAgaWYgKCF0aGlzLl9vcGVuZWRJbnN0YW5jZXMubGVuZ3RoICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9yZWZyZXNoSm9iKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LnJlbW92ZVJwYyh0aGlzLmFjY291bnQpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5hY2NvdW50LmlkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFjY291bnRDYWNoZSh0aGlzLmFjY291bnQuaWQpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgZXN0YWJsaXNoZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGxpY2FzIG51bWJlciBvZiBhY2NvdW50IHJlcGxpY2FzIGxhdW5jaGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCwgcmVwbGljYXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRSZWdpb24oaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5jYW5jZWxSZWZyZXNoKHJlZ2lvbik7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuc3luY2hyb25pemVkID0gZmFsc2U7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGRpc2Nvbm5lY3RlZCBmcm9tIGJyb2tlcmApO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN0cmVhbSBmb3IgYW4gaW5zdGFuY2UgaW5kZXggaXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqL1xuICBhc3luYyBvblN0cmVhbUNsb3NlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmxhZyBpbmRpY2F0aW5nIHN0YXR1cyBvZiBzdGF0ZSBzeW5jaHJvbml6YXRpb24gd2l0aCBNZXRhVHJhZGVyIHRlcm1pbmFsXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBhIGZsYWcgaW5kaWNhdGluZyBzdGF0dXMgb2Ygc3RhdGUgc3luY2hyb25pemF0aW9uIHdpdGggTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKi9cbiAgaXNTeW5jaHJvbml6ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAubWFwKGluc3RhbmNlID0+IGluc3RhbmNlLnN5bmNocm9uaXplZClcbiAgICAgIC5pbmNsdWRlcyh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyB1bnRpbCBzeW5jaHJvbml6YXRpb24gdG8gUlBDIGFwcGxpY2F0aW9uIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dEluU2Vjb25kcyBzeW5jaHJvbml6YXRpb24gdGltZW91dCBpbiBzZWNvbmRzLiBEZWZhdWx0cyB0byA1IG1pbnV0ZXNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byBSUEMgYXBwbGljYXRpb24gaXMgY29tcGxldGVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYXBwbGljYXRpb24gZmFpbGVkIHRvIHN5bmNocm9uaXplIHdpdGggdGhlIHRlbWluYWwgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgYXN5bmMgd2FpdFN5bmNocm9uaXplZCh0aW1lb3V0SW5TZWNvbmRzPTMwMCkge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3luY2hyb25pemVkID0gdGhpcy5pc1N5bmNocm9uaXplZCgpO1xuICAgIHdoaWxlKCFzeW5jaHJvbml6ZWQgJiYgc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDAgPiBEYXRlLm5vdygpKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwMDApKTtcbiAgICAgIHN5bmNocm9uaXplZCA9IHRoaXMuaXNTeW5jaHJvbml6ZWQoKTtcbiAgICB9XG4gICAgaWYgKCFzeW5jaHJvbml6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBNZXRhQXBpIHRvIHN5bmNocm9uaXplIHRvIE1ldGFUcmFkZXIgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fYWNjb3VudC5pZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3dlYnNvY2tldENsaWVudC53YWl0U3luY2hyb25pemVkKHRoaXMuX2FjY291bnQuaWQsIHVuZGVmaW5lZCwgJ1JQQycsIDUsICdSUEMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYoRGF0ZS5ub3coKSA+IHN0YXJ0VGltZSArIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiByZWNvbm5lY3RlZCByZWdpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIHJlY29ubmVjdGVkIGluc3RhbmNlIG51bWJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqL1xuICBhc3luYyBvblJlY29ubmVjdGVkKHJlZ2lvbiwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZVRlbXBsYXRlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChgJHtpbnN0YW5jZVRlbXBsYXRlfTpgKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhba2V5XTtcbiAgICAgIH0pO1xuICB9XG5cbiAgX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZighdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdID0ge1xuICAgICAgICBpbnN0YW5jZUluZGV4LFxuICAgICAgICBzeW5jaHJvbml6ZWQ6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdO1xuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJMb2dnZXJNYW5hZ2VyIiwiTWV0YUFwaUNvbm5lY3Rpb24iLCJUaW1lb3V0RXJyb3IiLCJScGNNZXRhQXBpQ29ubmVjdGlvbiIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwiX29wZW5lZEluc3RhbmNlcyIsImluY2x1ZGVzIiwicHVzaCIsIl9vcGVuZWQiLCJhY2NvdW50UmVnaW9ucyIsIl9hY2NvdW50IiwiX3dlYnNvY2tldENsaWVudCIsImFkZEFjY291bnRDYWNoZSIsImlkIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJyZWdpb24iLCJlbnN1cmVTdWJzY3JpYmUiLCJjbG9zZSIsImZpbHRlciIsImxlbmd0aCIsIl9jbG9zZWQiLCJjbGVhckludGVydmFsIiwiX3JlZnJlc2hKb2IiLCJfY29ubmVjdGlvblJlZ2lzdHJ5IiwicmVtb3ZlUnBjIiwiYWNjb3VudCIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwicmVtb3ZlQWNjb3VudENhY2hlIiwicmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIiLCJvbkNvbm5lY3RlZCIsImluc3RhbmNlSW5kZXgiLCJyZXBsaWNhcyIsInN0YXRlIiwiX2dldFN0YXRlIiwic3luY2hyb25pemVkIiwiZ2V0UmVnaW9uIiwiY2FuY2VsUmVmcmVzaCIsIm9uRGlzY29ubmVjdGVkIiwiX2xvZ2dlciIsImRlYnVnIiwib25TdHJlYW1DbG9zZWQiLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJpc1N5bmNocm9uaXplZCIsInZhbHVlcyIsIm1hcCIsImluc3RhbmNlIiwid2FpdFN5bmNocm9uaXplZCIsInRpbWVvdXRJblNlY29uZHMiLCJfY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJ1bmRlZmluZWQiLCJlcnIiLCJvblJlY29ubmVjdGVkIiwiaW5zdGFuY2VOdW1iZXIiLCJpbnN0YW5jZVRlbXBsYXRlIiwia2V5Iiwic3RhcnRzV2l0aCIsImNvbnN0cnVjdG9yIiwid2Vic29ja2V0Q2xpZW50IiwiY29ubmVjdGlvblJlZ2lzdHJ5IiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJyZXBsaWNhSWQiLCJhZGRSZWNvbm5lY3RMaXN0ZW5lciIsImdldExvZ2dlciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE9BQU9BLG1CQUFtQixZQUFZO0FBQ3RDLE9BQU9DLHVCQUF1QixzQkFBc0I7QUFDcEQsT0FBT0Msa0JBQWtCLDBCQUEwQjtBQUtwQyxJQUFBLEFBQU1DLHVCQUFOLE1BQU1BLDZCQUE2QkY7SUFtQmhEOzs7O0dBSUMsR0FDRCxBQUFNRyxRQUFRQyxVQUFVOztlQUF4QixvQkFBQTtZQUNFLElBQUcsQ0FBQyxNQUFLQyxnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDRixhQUFhO2dCQUM5QyxNQUFLQyxnQkFBZ0IsQ0FBQ0UsSUFBSSxDQUFDSDtZQUM3QjtZQUNBLElBQUksQ0FBQyxNQUFLSSxPQUFPLEVBQUU7Z0JBQ2pCLE1BQUtBLE9BQU8sR0FBRztnQkFDZixNQUFNQyxpQkFBaUIsTUFBS0MsUUFBUSxDQUFDRCxjQUFjO2dCQUNuRCxNQUFLRSxnQkFBZ0IsQ0FBQ0MsZUFBZSxDQUFDLE1BQUtGLFFBQVEsQ0FBQ0csRUFBRSxFQUFFSjtnQkFDeERLLE9BQU9DLElBQUksQ0FBQ04sZ0JBQWdCTyxPQUFPLENBQUNDLENBQUFBO29CQUNsQyxNQUFLTixnQkFBZ0IsQ0FBQ08sZUFBZSxDQUFDVCxjQUFjLENBQUNRLE9BQU8sRUFBRTtvQkFDOUQsTUFBS04sZ0JBQWdCLENBQUNPLGVBQWUs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