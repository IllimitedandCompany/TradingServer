'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import TerminalState from './terminalState';
import MemoryHistoryStorage from './memoryHistoryStorage';
import TimeoutError from '../clients/timeoutError';
import randomstring from 'randomstring';
import ConnectionHealthMonitor from './connectionHealthMonitor';
import { ValidationError } from '../clients/errorHandler';
import OptionsValidator from '../clients/optionsValidator';
import LoggerManager from '../logger';
import MetaApiConnection from './metaApiConnection';
let StreamingMetaApiConnection = class StreamingMetaApiConnection extends MetaApiConnection {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @param {string} instanceId connection instance id
   * @return {Promise} promise resolving when the connection is opened
   */ connect(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this._openedInstances.includes(instanceId)) {
                _this._openedInstances.push(instanceId);
            }
            if (!_this._opened) {
                _this._logger.trace(`${_this._account.id}: Opening connection`);
                _this._opened = true;
                try {
                    yield _this.initialize();
                    yield _this.subscribe();
                } catch (err) {
                    yield _this.close();
                    throw err;
                }
            }
        })();
    }
    /**
   * Clears the order and transaction history of a specified application and removes application
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */ removeApplication() {
        this._checkIsConnectionActive();
        this._historyStorage.clear();
        return this._websocketClient.removeApplication(this._account.id);
    }
    /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */ synchronize(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            const region = _this.getRegion(instanceIndex);
            const instance = _this.getInstanceNumber(instanceIndex);
            const host = _this.getHostName(instanceIndex);
            let startingHistoryOrderTime = new Date(Math.max((_this._historyStartTime || new Date(0)).getTime(), (yield _this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
            let startingDealTime = new Date(Math.max((_this._historyStartTime || new Date(0)).getTime(), (yield _this._historyStorage.lastDealTime(instance)).getTime()));
            let synchronizationId = randomstring.generate(32);
            _this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
            const accountId = _this._account.accountRegions[region];
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: initiating synchronization ${synchronizationId}`);
            return _this._websocketClient.synchronize(accountId, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime, _this.terminalState.getHashes());
        })();
    }
    /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */ initialize() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            yield _this._historyStorage.initialize(_this._account.id, _this._connectionRegistry.application);
            _this._websocketClient.addAccountCache(_this._account.id, _this._account.accountRegions);
        })();
    }
    /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */ subscribe() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            const accountRegions = _this._account.accountRegions;
            Object.values(accountRegions).forEach((replicaId)=>{
                _this._websocketClient.ensureSubscribe(replicaId, 0);
                _this._websocketClient.ensureSubscribe(replicaId, 1);
            });
        })();
    }
    /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @param {boolean} [waitForQuote] if set to false, the method will resolve without waiting for the first quote to
   * arrive. Default is to wait for quote if quotes subscription is requested.
   * @returns {Promise} promise which resolves when subscription request was processed
   */ subscribeToMarketData(symbol, subscriptions, timeoutInSeconds, waitForQuote = true) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            if (!_this._terminalState.specification(symbol)) {
                throw new ValidationError(`${_this._account.id}: Cannot subscribe to market data for symbol ${symbol} because ` + 'symbol does not exist');
            } else {
                subscriptions = subscriptions || [
                    {
                        type: 'quotes'
                    }
                ];
                if (_this._subscriptions[symbol]) {
                    const prevSubscriptions = _this._subscriptions[symbol].subscriptions;
                    subscriptions.forEach((subscription)=>{
                        const index = subscription.type === 'candles' ? prevSubscriptions.findIndex((item)=>item.type === subscription.type && item.timeframe === subscription.timeframe) : prevSubscriptions.findIndex((item)=>item.type === subscription.type);
                        if (index === -1) {
                            prevSubscriptions.push(subscription);
                        } else {
                            prevSubscriptions[index] = subscription;
                        }
                    });
                } else {
                    _this._subscriptions[symbol] = {
                        subscriptions
                    };
                }
                yield _this._websocketClient.subscribeToMarketData(_this._account.id, symbol, subscriptions, _this._account.reliability);
                if (waitForQuote !== false && subscriptions.find((s)=>s.type === 'quotes')) {
                    return _this.terminalState.waitForPrice(symbol, timeoutInSeconds);
                }
            }
        })();
    }
    /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */ unsubscribeFromMarketData(symbol, subscriptions) {
        this._checkIsConnectionActive();
        if (!subscriptions) {
            delete this._subscriptions[symbol];
        } else if (this._subscriptions[symbol]) {
            this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter((s)=>s.type === 'candles' ? !subscriptions.find((s2)=>s.type === s2.type && s.timeframe === s2.timeframe) : !subscriptions.find((s2)=>s.type === s2.type));
            if (!this._subscriptions[symbol].subscriptions.length) {
                delete this._subscriptions[symbol];
            }
        }
        return this._websocketClient.unsubscribeFromMarketData(this._account.id, symbol, subscriptions, this._account.reliability);
    }
    /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity
    onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
        var _this = this;
        return _async_to_generator(function*() {
            let subscriptions = _this._subscriptions[symbol] || [];
            if (unsubscriptions && unsubscriptions.length) {
                if (subscriptions) {
                    for (let subscription of unsubscriptions){
                        subscriptions = subscriptions.filter((s)=>s.type === subscription.type);
                    }
                }
                _this.unsubscribeFromMarketData(symbol, unsubscriptions).catch((err)=>{
                    if (err.name !== ValidationError) {
                        _this._logger.error(`${_this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
                    } else {
                        _this._logger.trace(`${_this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
                    }
                });
            }
            if (updates && updates.length) {
                if (subscriptions) {
                    for (let subscription of updates){
                        subscriptions.filter((s)=>s.type === subscription.type).forEach((s)=>s.intervalInMilliiseconds = subscription.intervalInMilliseconds);
                    }
                }
                _this.subscribeToMarketData(symbol, updates).catch((err)=>{
                    _this._logger.error(`${_this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
                });
            }
            if (subscriptions && !subscriptions.length) {
                delete _this._subscriptions[symbol];
            }
        })();
    }
    /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */ get subscribedSymbols() {
        return Object.keys(this._subscriptions);
    }
    /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */ subscriptions(symbol) {
        this._checkIsConnectionActive();
        return (this._subscriptions[symbol] || {}).subscriptions;
    }
    /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */ get terminalState() {
        return this._terminalState;
    }
    /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */ get historyStorage() {
        return this._historyStorage;
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onConnected(instanceIndex, replicas) {
        var _this = this;
        return _async_to_generator(function*() {
            let key = randomstring.generate(32);
            let state = _this._getState(instanceIndex);
            const region = _this.getRegion(instanceIndex);
            _this.cancelRefresh(region);
            yield _this._terminalHashManager.refreshIgnoredFieldLists(region);
            state.shouldSynchronize = key;
            state.synchronizationRetryIntervalInSeconds = 1;
            state.synchronized = false;
            _this._ensureSynchronized(instanceIndex, key);
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: connected to broker`);
        })();
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ onDisconnected(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
            state.lastSynchronizationId = undefined;
            state.shouldSynchronize = undefined;
            state.synchronized = false;
            state.disconnected = true;
            const instanceNumber = _this.getInstanceNumber(instanceIndex);
            const region = _this.getRegion(instanceIndex);
            const instance = `${region}:${instanceNumber}`;
            delete _this._refreshMarketDataSubscriptionSessions[instance];
            clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete _this._refreshMarketDataSubscriptionTimeouts[instance];
            if (state.synchronizationTimeout) {
                clearTimeout(state.synchronizationTimeout);
                delete state.synchronizationTimeout;
            }
            if (state.ensureSynchronizeTimeout) {
                clearTimeout(state.ensureSynchronizeTimeout);
                delete state.ensureSynchronizeTimeout;
            }
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: disconnected from broker`);
        })();
    }
    /**
   * Invoked when a symbol specifications were updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when position synchronization finished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ onPositionsSynchronized(instanceIndex, synchronizationId) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onDealsSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.dealsSynchronized[synchronizationId] = true;
            _this._scheduleSynchronizationTimeout(instanceIndex);
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: finished synchronization ${synchronizationId}`);
        })();
    }
    /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.ordersSynchronized[synchronizationId] = true;
            _this._scheduleSynchronizationTimeout(instanceIndex);
        })();
    }
    /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @param {String} region reconnected region
   * @param {Number} instanceNumber reconnected instance number
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */ onReconnected(region, instanceNumber) {
        var _this = this;
        return _async_to_generator(function*() {
            const instanceTemplate = `${region}:${instanceNumber}`;
            Object.keys(_this._stateByInstanceIndex).filter((key)=>key.startsWith(`${instanceTemplate}:`)).forEach((key)=>{
                delete _this._stateByInstanceIndex[key];
            });
            delete _this._refreshMarketDataSubscriptionSessions[instanceTemplate];
            clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instanceTemplate]);
            delete _this._refreshMarketDataSubscriptionTimeouts[instanceTemplate];
        })();
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onStreamClosed(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            delete _this._stateByInstanceIndex[instanceIndex];
        })();
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._logger.debug(`${_this._account.id}:${instanceIndex}: starting synchronization ${synchronizationId}`);
            const instanceNumber = _this.getInstanceNumber(instanceIndex);
            const region = _this.getRegion(instanceIndex);
            const instance = `${region}:${instanceNumber}`;
            const accountId = _this._account.accountRegions[region];
            delete _this._refreshMarketDataSubscriptionSessions[instance];
            let sessionId = randomstring.generate(32);
            _this._refreshMarketDataSubscriptionSessions[instance] = sessionId;
            clearTimeout(_this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete _this._refreshMarketDataSubscriptionTimeouts[instance];
            yield _this._refreshMarketDataSubscriptions(accountId, instanceNumber, sessionId);
            _this._scheduleSynchronizationTimeout(instanceIndex);
            let state = _this._getState(instanceIndex);
            if (state && !_this._closed) {
                state.lastSynchronizationId = synchronizationId;
            }
        })();
    }
    /**
   * Invoked when account region has been unsubscribed
   * @param {String} region account region unsubscribed
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onUnsubscribeRegion(region) {
        Object.keys(this._refreshMarketDataSubscriptionTimeouts).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>{
            clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete this._refreshMarketDataSubscriptionTimeouts[instance];
            delete this._refreshMarketDataSubscriptionSessions[instance];
        });
        Object.keys(this._stateByInstanceIndex).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>delete this._stateByInstanceIndex[instance]);
    }
    /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */ isSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            return Object.values(_this._stateByInstanceIndex).reduce((acc, s)=>{
                if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
                    return acc;
                }
                const checkSynchronizationId = synchronizationId || s.lastSynchronizationId;
                let synchronized = !!s.ordersSynchronized[checkSynchronizationId] && !!s.dealsSynchronized[checkSynchronizationId];
                return acc || synchronized;
            }, false);
        })();
    }
    /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @property {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @property {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */ /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} opts synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */ // eslint-disable-next-line complexity
    waitSynchronized(opts) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._checkIsConnectionActive();
            opts = opts || {};
            let instanceIndex = opts.instanceIndex;
            let synchronizationId = opts.synchronizationId;
            let timeoutInSeconds = opts.timeoutInSeconds || 300;
            let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
            let applicationPattern = opts.applicationPattern || (_this._account.application === 'CopyFactory' ? 'CopyFactory.*|RPC' : 'RPC');
            let startTime = Date.now();
            let synchronized;
            while(!(synchronized = yield _this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()){
                yield new Promise((res)=>setTimeout(res, intervalInMilliseconds));
            }
            let state;
            if (instanceIndex === undefined) {
                for (let s of Object.values(_this._stateByInstanceIndex)){
                    if (yield _this.isSynchronized(s.instanceIndex, synchronizationId)) {
                        state = s;
                        instanceIndex = s.instanceIndex;
                    }
                }
            } else {
                state = Object.values(_this._stateByInstanceIndex).find((s)=>s.instanceIndex === instanceIndex);
            }
            if (!synchronized) {
                throw new TimeoutError('Timed out waiting for MetaApi to synchronize to MetaTrader account ' + _this._account.id + ', synchronization id ' + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
            }
            let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
            const region = _this.getRegion(state.instanceIndex);
            const accountId = _this._account.accountRegions[region];
            yield _this._websocketClient.waitSynchronized(accountId, _this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
        })();
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   * @param {string} instanceId connection instance id
   */ close(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._opened) {
                _this._openedInstances = _this._openedInstances.filter((id)=>id !== instanceId);
                if (!_this._openedInstances.length && !_this._closed) {
                    clearInterval(_this._refreshJob);
                    _this._logger.debug(`${_this._account.id}: Closing connection`);
                    _this._stateByInstanceIndex = {};
                    yield _this._connectionRegistry.removeStreaming(_this._account);
                    _this._terminalState.close();
                    const accountRegions = _this._account.accountRegions;
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this);
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this._terminalState);
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this._historyStorage);
                    _this._websocketClient.removeSynchronizationListener(_this._account.id, _this._healthMonitor);
                    _this._websocketClient.removeReconnectListener(_this);
                    _this._healthMonitor.stop();
                    _this._refreshMarketDataSubscriptionSessions = {};
                    Object.values(_this._refreshMarketDataSubscriptionTimeouts).forEach((timeout)=>clearTimeout(timeout));
                    _this._refreshMarketDataSubscriptionTimeouts = {};
                    Object.values(accountRegions).forEach((replicaId)=>_this._websocketClient.removeAccountCache(replicaId));
                    _this._closed = true;
                    _this._logger.trace(`${_this._account.id}: Closed connection`);
                }
            }
        })();
    }
    /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */ get synchronized() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.synchronized, false);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._account;
    }
    /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */ get healthMonitor() {
        return this._healthMonitor;
    }
    _refreshMarketDataSubscriptions(accountId, instanceNumber, session) {
        var _this = this;
        return _async_to_generator(function*() {
            const region = _this._websocketClient.getAccountRegion(accountId);
            const instance = `${region}:${instanceNumber}`;
            try {
                if (_this._refreshMarketDataSubscriptionSessions[instance] === session) {
                    const subscriptionsList = [];
                    Object.keys(_this._subscriptions).forEach((key)=>{
                        const subscriptions = _this.subscriptions(key);
                        const subscriptionsItem = {
                            symbol: key
                        };
                        if (subscriptions) {
                            subscriptionsItem.subscriptions = subscriptions;
                        }
                        subscriptionsList.push(subscriptionsItem);
                    });
                    yield _this._websocketClient.refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptionsList);
                }
            } catch (err) {
                _this._logger.error(`Error refreshing market data subscriptions job for account ${_this._account.id} ` + `${instanceNumber}`, err);
            } finally{
                if (_this._refreshMarketDataSubscriptionSessions[instance] === session) {
                    let refreshInterval = (Math.random() * (_this._maxSubscriptionRefreshInterval - _this._minSubscriptionRefreshInterval) + _this._minSubscriptionRefreshInterval) * 1000;
                    _this._refreshMarketDataSubscriptionTimeouts[instance] = setTimeout(()=>_this._refreshMarketDataSubscriptions(accountId, instanceNumber, session), refreshInterval);
                }
            }
        })();
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === 'number') {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === 'number') {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    _ensureSynchronized(instanceIndex, key) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            if (state && state.shouldSynchronize && !_this._closed) {
                try {
                    const synchronizationResult = yield _this.synchronize(instanceIndex);
                    if (synchronizationResult) {
                        state.synchronized = true;
                        state.synchronizationRetryIntervalInSeconds = 1;
                        delete state.ensureSynchronizeTimeout;
                    }
                    _this._scheduleSynchronizationTimeout(instanceIndex);
                } catch (err) {
                    _this._logger.error('MetaApi websocket client for account ' + _this._account.id + ':' + instanceIndex + ' failed to synchronize', err);
                    if (state.shouldSynchronize === key) {
                        if (state.ensureSynchronizeTimeout) {
                            clearTimeout(state.ensureSynchronizeTimeout);
                        }
                        state.ensureSynchronizeTimeout = setTimeout(_this._ensureSynchronized.bind(_this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
                        state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
                    }
                }
            }
        })();
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex['' + instanceIndex]) {
            this._stateByInstanceIndex['' + instanceIndex] = {
                instanceIndex,
                ordersSynchronized: {},
                dealsSynchronized: {},
                shouldSynchronize: undefined,
                synchronizationRetryIntervalInSeconds: 1,
                synchronized: false,
                lastDisconnectedSynchronizationId: undefined,
                lastSynchronizationId: undefined,
                disconnected: false
            };
        }
        return this._stateByInstanceIndex['' + instanceIndex];
    }
    _scheduleSynchronizationTimeout(instanceIndex) {
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            if (state.synchronizationTimeout) {
                clearTimeout(state.synchronizationTimeout);
            }
            let synchronizationTimeout = 2 * 60 * 1000;
            state.synchronizationTimeout = setTimeout(()=>this._checkSynchronizationTimedOut(instanceIndex), synchronizationTimeout);
        }
    }
    _checkSynchronizationTimedOut(instanceIndex) {
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            let synchronizationId = state.lastSynchronizationId;
            let synchronized = !!state.dealsSynchronized[synchronizationId];
            if (!synchronized && synchronizationId && state.shouldSynchronize) {
                this._logger.warn(`${this._account.id}:${instanceIndex}: resynchronized since latest synchronization ` + `${synchronizationId} did not finish in time`);
                this._ensureSynchronized(instanceIndex, state.shouldSynchronize);
            }
        }
    }
    /**
   * Constructs MetaApi MetaTrader streaming Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
   */ constructor(websocketClient, terminalHashManager, account, historyStorage, connectionRegistry, historyStartTime, refreshSubscriptionsOpts){
        super(websocketClient, account);
        refreshSubscriptionsOpts = refreshSubscriptionsOpts || {};
        const validator = new OptionsValidator();
        this._minSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.minDelayInSeconds, 1, 'refreshSubscriptionsOpts.minDelayInSeconds');
        this._maxSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.maxDelayInSeconds, 600, 'refreshSubscriptionsOpts.maxDelayInSeconds');
        this._connectionRegistry = connectionRegistry;
        this._historyStartTime = historyStartTime;
        this._terminalHashManager = terminalHashManager;
        this._terminalState = new TerminalState(account, terminalHashManager, this._websocketClient);
        this._historyStorage = historyStorage || new MemoryHistoryStorage();
        this._healthMonitor = new ConnectionHealthMonitor(this);
        this._websocketClient.addSynchronizationListener(account.id, this);
        this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
        this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
        this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
        Object.values(account.accountRegions).forEach((replicaId)=>this._websocketClient.addReconnectListener(this, replicaId));
        this._subscriptions = {};
        this._stateByInstanceIndex = {};
        this._refreshMarketDataSubscriptionSessions = {};
        this._refreshMarketDataSubscriptionTimeouts = {};
        this._openedInstances = [];
        this._logger = LoggerManager.getLogger('MetaApiConnection');
    }
};
/**
 * Exposes MetaApi MetaTrader streaming API connection to consumers
 */ export { StreamingMetaApiConnection as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUZXJtaW5hbFN0YXRlIGZyb20gJy4vdGVybWluYWxTdGF0ZSc7XG5pbXBvcnQgTWVtb3J5SGlzdG9yeVN0b3JhZ2UgZnJvbSAnLi9tZW1vcnlIaXN0b3J5U3RvcmFnZSc7XG5pbXBvcnQgVGltZW91dEVycm9yIGZyb20gJy4uL2NsaWVudHMvdGltZW91dEVycm9yJztcbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBDb25uZWN0aW9uSGVhbHRoTW9uaXRvciBmcm9tICcuL2Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yfSBmcm9tICcuLi9jbGllbnRzL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgT3B0aW9uc1ZhbGlkYXRvciBmcm9tICcuLi9jbGllbnRzL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCBNZXRhQXBpQ29ubmVjdGlvbiBmcm9tICcuL21ldGFBcGlDb25uZWN0aW9uJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBzdHJlYW1pbmcgQVBJIGNvbm5lY3Rpb24gdG8gY29uc3VtZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9uIGV4dGVuZHMgTWV0YUFwaUNvbm5lY3Rpb24ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgTWV0YVRyYWRlciBzdHJlYW1pbmcgQXBpIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7VGVybWluYWxIYXNoTWFuYWdlcn0gdGVybWluYWxIYXNoTWFuYWdlciB0ZXJtaW5hbCBoYXNoIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudH0gYWNjb3VudCBNZXRhVHJhZGVyIGFjY291bnQgaWQgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0ge0hpc3RvcnlTdG9yYWdlfSBoaXN0b3J5U3RvcmFnZSB0ZXJtaW5hbCBoaXN0b3J5IHN0b3JhZ2UuIEJ5IGRlZmF1bHQgYW4gaW5zdGFuY2Ugb2YgTWVtb3J5SGlzdG9yeVN0b3JhZ2VcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25SZWdpc3RyeX0gY29ubmVjdGlvblJlZ2lzdHJ5IG1ldGF0cmFkZXIgYWNjb3VudCBjb25uZWN0aW9uIHJlZ2lzdHJ5XG4gICAqIEBwYXJhbSB7RGF0ZX0gW2hpc3RvcnlTdGFydFRpbWVdIGhpc3Rvcnkgc3RhcnQgc3luYyB0aW1lXG4gICAqIEBwYXJhbSB7UmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzfSBbcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzXSBzdWJzY3JpcHRpb25zIHJlZnJlc2ggb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2Vic29ja2V0Q2xpZW50LCB0ZXJtaW5hbEhhc2hNYW5hZ2VyLCBhY2NvdW50LCBoaXN0b3J5U3RvcmFnZSwgY29ubmVjdGlvblJlZ2lzdHJ5LFxuICAgIGhpc3RvcnlTdGFydFRpbWUsIHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cykge1xuICAgIHN1cGVyKHdlYnNvY2tldENsaWVudCwgYWNjb3VudCk7XG4gICAgcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzID0gcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIHx8IHt9O1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgdGhpcy5fbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWluRGVsYXlJblNlY29uZHMsIDEsXG4gICAgICAncmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzLm1pbkRlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4U3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWF4RGVsYXlJblNlY29uZHMsIDYwMCxcbiAgICAgICdyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWF4RGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkgPSBjb25uZWN0aW9uUmVnaXN0cnk7XG4gICAgdGhpcy5faGlzdG9yeVN0YXJ0VGltZSA9IGhpc3RvcnlTdGFydFRpbWU7XG4gICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlciA9IHRlcm1pbmFsSGFzaE1hbmFnZXI7XG4gICAgdGhpcy5fdGVybWluYWxTdGF0ZSA9IG5ldyBUZXJtaW5hbFN0YXRlKGFjY291bnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIHRoaXMuX3dlYnNvY2tldENsaWVudCk7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UgPSBoaXN0b3J5U3RvcmFnZSB8fCBuZXcgTWVtb3J5SGlzdG9yeVN0b3JhZ2UoKTtcbiAgICB0aGlzLl9oZWFsdGhNb25pdG9yID0gbmV3IENvbm5lY3Rpb25IZWFsdGhNb25pdG9yKHRoaXMpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5fdGVybWluYWxTdGF0ZSk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMuX2hpc3RvcnlTdG9yYWdlKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5faGVhbHRoTW9uaXRvcik7XG4gICAgT2JqZWN0LnZhbHVlcyhhY2NvdW50LmFjY291bnRSZWdpb25zKVxuICAgICAgLmZvckVhY2gocmVwbGljYUlkID0+IHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRSZWNvbm5lY3RMaXN0ZW5lcih0aGlzLCByZXBsaWNhSWQpKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zID0ge307XG4gICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cyA9IHt9O1xuICAgIHRoaXMuX29wZW5lZEluc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdNZXRhQXBpQ29ubmVjdGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIG5leHQgY2FsbHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJZCBjb25uZWN0aW9uIGluc3RhbmNlIGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgb3BlbmVkXG4gICAqL1xuICBhc3luYyBjb25uZWN0KGluc3RhbmNlSWQpIHtcbiAgICBpZighdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmluY2x1ZGVzKGluc3RhbmNlSWQpKSB7XG4gICAgICB0aGlzLl9vcGVuZWRJbnN0YW5jZXMucHVzaChpbnN0YW5jZUlkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogT3BlbmluZyBjb25uZWN0aW9uYCk7XG4gICAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgb3JkZXIgYW5kIHRyYW5zYWN0aW9uIGhpc3Rvcnkgb2YgYSBzcGVjaWZpZWQgYXBwbGljYXRpb24gYW5kIHJlbW92ZXMgYXBwbGljYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgaGlzdG9yeSBpcyBjbGVhcmVkIGFuZCBhcHBsaWNhdGlvbiBpcyByZW1vdmVkXG4gICAqL1xuICByZW1vdmVBcHBsaWNhdGlvbigpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHRoaXMuX2hpc3RvcnlTdG9yYWdlLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVBcHBsaWNhdGlvbih0aGlzLl9hY2NvdW50LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgdGVybWluYWwgdG8gc3RhcnQgc3luY2hyb25pemF0aW9uIHByb2Nlc3NcbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L3N5bmNocm9uaXppbmcvc3luY2hyb25pemUvKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICBhc3luYyBzeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgaG9zdCA9IHRoaXMuZ2V0SG9zdE5hbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgbGV0IHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSA9IG5ldyBEYXRlKE1hdGgubWF4KFxuICAgICAgKHRoaXMuX2hpc3RvcnlTdGFydFRpbWUgfHwgbmV3IERhdGUoMCkpLmdldFRpbWUoKSxcbiAgICAgIChhd2FpdCB0aGlzLl9oaXN0b3J5U3RvcmFnZS5sYXN0SGlzdG9yeU9yZGVyVGltZShpbnN0YW5jZSkpLmdldFRpbWUoKVxuICAgICkpO1xuICAgIGxldCBzdGFydGluZ0RlYWxUaW1lID0gbmV3IERhdGUoTWF0aC5tYXgoXG4gICAgICAodGhpcy5faGlzdG9yeVN0YXJ0VGltZSB8fCBuZXcgRGF0ZSgwKSkuZ2V0VGltZSgpLFxuICAgICAgKGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmxhc3REZWFsVGltZShpbnN0YW5jZSkpLmdldFRpbWUoKVxuICAgICkpO1xuICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMik7XG4gICAgdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkubGFzdFN5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQ7XG4gICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9uc1tyZWdpb25dO1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBpbml0aWF0aW5nIHN5bmNocm9uaXphdGlvbiAke3N5bmNocm9uaXphdGlvbklkfWApO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3luY2hyb25pemUoYWNjb3VudElkLCBpbnN0YW5jZSwgaG9zdCwgc3luY2hyb25pemF0aW9uSWQsXG4gICAgICBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUsIHN0YXJ0aW5nRGVhbFRpbWUsIHRoaXMudGVybWluYWxTdGF0ZS5nZXRIYXNoZXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgbWV0YSBhcGkgY29ubmVjdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gbWV0YSBhcGkgY29ubmVjdGlvbiBpcyBpbml0aWFsaXplZFxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmluaXRpYWxpemUodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LmFwcGxpY2F0aW9uKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkQWNjb3VudENhY2hlKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBzdWJzY3JpcHRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiBpcyBpbml0aWF0ZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZSgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGNvbnN0IGFjY291bnRSZWdpb25zID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9ucztcbiAgICBPYmplY3QudmFsdWVzKGFjY291bnRSZWdpb25zKS5mb3JFYWNoKHJlcGxpY2FJZCA9PiB7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMCk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3N1YnNjcmliZVRvTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlLiBQbGVhc2VcbiAgICogbm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgb24gc2VydmVyLXNpZGUgeWV0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gdGltZW91dCB0byB3YWl0IGZvciBwcmljZXMgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3YWl0Rm9yUXVvdGVdIGlmIHNldCB0byBmYWxzZSwgdGhlIG1ldGhvZCB3aWxsIHJlc29sdmUgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgZmlyc3QgcXVvdGUgdG9cbiAgICogYXJyaXZlLiBEZWZhdWx0IGlzIHRvIHdhaXQgZm9yIHF1b3RlIGlmIHF1b3RlcyBzdWJzY3JpcHRpb24gaXMgcmVxdWVzdGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIHRpbWVvdXRJblNlY29uZHMsIHdhaXRGb3JRdW90ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmKCF0aGlzLl90ZXJtaW5hbFN0YXRlLnNwZWNpZmljYXRpb24oc3ltYm9sKSl7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke3RoaXMuX2FjY291bnQuaWR9OiBDYW5ub3Qgc3Vic2NyaWJlIHRvIG1hcmtldCBkYXRhIGZvciBzeW1ib2wgJHtzeW1ib2x9IGJlY2F1c2UgYCArXG4gICAgICAnc3ltYm9sIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zIHx8IFt7dHlwZTogJ3F1b3Rlcyd9XTtcbiAgICAgIGlmKHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXSkge1xuICAgICAgICBjb25zdCBwcmV2U3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zO1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmlwdGlvbi50eXBlID09PSAnY2FuZGxlcycgPyBcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUgJiYgXG4gICAgICAgICAgICBpdGVtLnRpbWVmcmFtZSA9PT0gc3Vic2NyaXB0aW9uLnRpbWVmcmFtZSkgOlxuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSk7XG4gICAgICAgICAgaWYoaW5kZXggPT09IC0xKXtcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnNbaW5kZXhdID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gICAgICBpZiAod2FpdEZvclF1b3RlICE9PSBmYWxzZSAmJiBzdWJzY3JpcHRpb25zLmZpbmQocyA9PiBzLnR5cGUgPT09ICdxdW90ZXMnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbFN0YXRlLndhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdW5zdWJzY3JpcHRpb24gcmVxdWVzdCB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICB1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhKHN5bWJvbCwgc3Vic2NyaXB0aW9ucykge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zXG4gICAgICAgIC5maWx0ZXIocyA9PiBzLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgICFzdWJzY3JpcHRpb25zLmZpbmQoczIgPT4gcy50eXBlID09PSBzMi50eXBlICYmIHMudGltZWZyYW1lID09PSBzMi50aW1lZnJhbWUpIDogXG4gICAgICAgICAgIXN1YnNjcmlwdGlvbnMuZmluZChzMiA9PiBzLnR5cGUgPT09IHMyLnR5cGUpKTtcbiAgICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsXG4gICAgICB0aGlzLl9hY2NvdW50LnJlbGlhYmlsaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gc3Vic2NyaXB0aW9uIGRvd25ncmFkZSBoYXMgb2NjdXJyZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdXBkYXRlIHN1YnNjcmlwdGlvbnMgZm9yXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IHVwZGF0ZXMgYXJyYXkgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFVbnN1YnNjcmlwdGlvbj59IHVuc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBzdWJzY3JpcHRpb25zIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIG9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBzeW1ib2wsIHVwZGF0ZXMsIHVuc3Vic2NyaXB0aW9ucykge1xuICAgIGxldCBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IFtdO1xuICAgIGlmICh1bnN1YnNjcmlwdGlvbnMgJiYgdW5zdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgc3Vic2NyaXB0aW9uIG9mIHVuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMudHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIubmFtZSAhPT0gVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7dGhpcy5fYWNjb3VudC5pZH06IGZhaWxlZCBkbyB1bnN1YnNjcmliZSBmcm9tIG1hcmtldCBkYXRhIG9uIHN1YnNjcmlwdGlvbiBkb3duZ3JhZGVkYCxcbiAgICAgICAgICAgICAgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke3RoaXMuX2FjY291bnQuaWR9OiBmYWlsZWQgZG8gdW5zdWJzY3JpYmUgZnJvbSBtYXJrZXQgZGF0YSBvbiBzdWJzY3JpcHRpb24gZG93bmdyYWRlZGAsXG4gICAgICAgICAgICAgIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMgJiYgdXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IHN1YnNjcmlwdGlvbiBvZiB1cGRhdGVzKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5maWx0ZXIocyA9PiBzLnR5cGUgPT09IHN1YnNjcmlwdGlvbi50eXBlKVxuICAgICAgICAgICAgLmZvckVhY2gocyA9PiBzLmludGVydmFsSW5NaWxsaWlzZWNvbmRzID0gc3Vic2NyaXB0aW9uLmludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHVwZGF0ZXMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHt0aGlzLl9hY2NvdW50LmlkfTogZmFpbGVkIGRvIHVuc3Vic2NyaWJlIGZyb20gbWFya2V0IGRhdGEgb24gc3Vic2NyaXB0aW9uIGRvd25ncmFkZWRgLFxuICAgICAgICAgICAgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb25zICYmICFzdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIHRoZSBzeW1ib2xzIGNvbm5lY3Rpb24gaXMgc3Vic2NyaWJlZCB0b1xuICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn0gbGlzdCBvZiB0aGUgc3ltYm9scyBjb25uZWN0aW9uIGlzIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCBzdWJzY3JpYmVkU3ltYm9scygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdWJzY3JpcHRpb25zIGZvciBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb25zIGZvclxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IGxpc3Qgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIHN5bWJvbFxuICAgKi9cbiAgc3Vic2NyaXB0aW9ucyhzeW1ib2wpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IHt9KS5zdWJzY3JpcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYWwgY29weSBvZiB0ZXJtaW5hbCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7VGVybWluYWxTdGF0ZX0gbG9jYWwgY29weSBvZiB0ZXJtaW5hbCBzdGF0ZVxuICAgKi9cbiAgZ2V0IHRlcm1pbmFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsb2NhbCBoaXN0b3J5IHN0b3JhZ2VcbiAgICogQHJldHVybnMge0hpc3RvcnlTdG9yYWdlfSBsb2NhbCBoaXN0b3J5IHN0b3JhZ2VcbiAgICovXG4gIGdldCBoaXN0b3J5U3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yeVN0b3JhZ2U7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwbGljYXMgbnVtYmVyIG9mIGFjY291bnQgcmVwbGljYXMgbGF1bmNoZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkNvbm5lY3RlZChpbnN0YW5jZUluZGV4LCByZXBsaWNhcykge1xuICAgIGxldCBrZXkgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuY2FuY2VsUmVmcmVzaChyZWdpb24pO1xuICAgIGF3YWl0IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVmcmVzaElnbm9yZWRGaWVsZExpc3RzKHJlZ2lvbik7XG4gICAgc3RhdGUuc2hvdWxkU3luY2hyb25pemUgPSBrZXk7XG4gICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgc3RhdGUuc3luY2hyb25pemVkID0gZmFsc2U7XG4gICAgdGhpcy5fZW5zdXJlU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGtleSk7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGNvbm5lY3RlZCB0byBicm9rZXJgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIHRlcm1pbmF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIGFzeW5jIG9uRGlzY29ubmVjdGVkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5sYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQgPSBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHN0YXRlLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgIGlmIChzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCk7XG4gICAgICBkZWxldGUgc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgICBkZWxldGUgc3RhdGUuZW5zdXJlU3luY2hyb25pemVUaW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZGlzY29ubmVjdGVkIGZyb20gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3ltYm9sIHNwZWNpZmljYXRpb25zIHdlcmUgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBzcGVjaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJlbW92ZWRTeW1ib2xzIHJlbW92ZWQgc3ltYm9sc1xuICAgKi9cbiAgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwb3NpdGlvbiBzeW5jaHJvbml6YXRpb24gZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW4gaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqL1xuICBvblBvc2l0aW9uc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcGVuZGluZyBvcmRlciBzeW5jaHJvbml6YXRpb24gZm5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhbiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlXG4gICAqIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICovXG4gIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW5jaHJvbml6YXRpb24gb2YgaGlzdG9yeSBkZWFscyBvbiBhIE1ldGFUcmFkZXIgYWNjb3VudCBoYXZlIGZpbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuXG4gICAqIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF0gPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZmluaXNoZWQgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3Rvcnkgb3JkZXJzIG9uIGEgTWV0YVRyYWRlciBhY2NvdW50IGhhdmUgZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW5cbiAgICogaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSA9IHRydWU7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiByZWNvbm5lY3RlZCByZWdpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIHJlY29ubmVjdGVkIGluc3RhbmNlIG51bWJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqL1xuICBhc3luYyBvblJlY29ubmVjdGVkKHJlZ2lvbiwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZVRlbXBsYXRlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChgJHtpbnN0YW5jZVRlbXBsYXRlfTpgKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhba2V5XTtcbiAgICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlVGVtcGxhdGVdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlVGVtcGxhdGVdKTtcbiAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZVRlbXBsYXRlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIGlzIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWNpZmljYXRpb25zSGFzaCBzcGVjaWZpY2F0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbnNIYXNoIHBvc2l0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcnNIYXNoIG9yZGVycyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLCBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBzdGFydGluZyBzeW5jaHJvbml6YXRpb24gJHtzeW5jaHJvbml6YXRpb25JZH1gKTtcbiAgICBjb25zdCBpbnN0YW5jZU51bWJlciA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRSZWdpb24oaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9YDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgIGxldCBzZXNzaW9uSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdID0gc2Vzc2lvbklkO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzZXNzaW9uSWQpO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhY2NvdW50IHJlZ2lvbiBoYXMgYmVlbiB1bnN1YnNjcmliZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvbiB1bnN1YnNjcmliZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblVuc3Vic2NyaWJlUmVnaW9uKHJlZ2lvbikge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMpXG4gICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7cmVnaW9ufTpgKSlcbiAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV07XG4gICAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleClcbiAgICAgIC5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2Uuc3RhcnRzV2l0aChgJHtyZWdpb259OmApKVxuICAgICAgLmZvckVhY2goaW5zdGFuY2UgPT4gZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIG9wdGlvbmFsIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZFxuICAgKiBieSBkZWZhdWx0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYSBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXJcbiAgICogdGVybWluYWxcbiAgICovXG4gIGFzeW5jIGlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2VJbmRleCAhPT0gdW5kZWZpbmVkICYmIHMuaW5zdGFuY2VJbmRleCAhPT0gaW5zdGFuY2VJbmRleCkge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hlY2tTeW5jaHJvbml6YXRpb25JZCA9IHN5bmNocm9uaXphdGlvbklkIHx8IHMubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgICAgbGV0IHN5bmNocm9uaXplZCA9ICEhcy5vcmRlcnNTeW5jaHJvbml6ZWRbY2hlY2tTeW5jaHJvbml6YXRpb25JZF0gJiYgXG4gICAgICAgICEhcy5kZWFsc1N5bmNocm9uaXplZFtjaGVja1N5bmNocm9uaXphdGlvbklkXTtcbiAgICAgIHJldHVybiBhY2MgfHwgc3luY2hyb25pemVkO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTeW5jaHJvbml6YXRpb25PcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYXBwbGljYXRpb25QYXR0ZXJuXSBhcHBsaWNhdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiwgZGVmYXVsdCBpcyAuKlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N5bmNocm9uaXphdGlvbklkXSBzeW5jaHJvbml6YXRpb24gaWQsIGxhc3Qgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWQgd2lsbCBiZSB1c2VkIGJ5XG4gICAqIGRlZmF1bHRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtpbnN0YW5jZUluZGV4XSBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIHRvIGVuc3VyZSBzeW5jaHJvbml6YXRpb24gb24sIGRlZmF1bHQgaXMgdG8gd2FpdFxuICAgKiBmb3IgdGhlIGZpcnN0IGluc3RhbmNlIHRvIHN5bmNocm9uaXplXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtpbnRlcnZhbEluTWlsbGlzZWNvbmRzXSBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKi9cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgc3luY2hyb25pemF0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uT3B0aW9uc30gb3B0cyBzeW5jaHJvbml6YXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29tcGxldGVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYXBwbGljYXRpb24gZmFpbGVkIHRvIHN5bmNocm9uaXplIHdpdGggdGhlIHRlbWluYWwgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgd2FpdFN5bmNocm9uaXplZChvcHRzKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBsZXQgaW5zdGFuY2VJbmRleCA9IG9wdHMuaW5zdGFuY2VJbmRleDtcbiAgICBsZXQgc3luY2hyb25pemF0aW9uSWQgPSBvcHRzLnN5bmNocm9uaXphdGlvbklkO1xuICAgIGxldCB0aW1lb3V0SW5TZWNvbmRzID0gb3B0cy50aW1lb3V0SW5TZWNvbmRzIHx8IDMwMDtcbiAgICBsZXQgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IG9wdHMuaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyB8fCAxMDAwO1xuICAgIGxldCBhcHBsaWNhdGlvblBhdHRlcm4gPSBvcHRzLmFwcGxpY2F0aW9uUGF0dGVybiB8fFxuICAgICAgKHRoaXMuX2FjY291bnQuYXBwbGljYXRpb24gPT09ICdDb3B5RmFjdG9yeScgPyAnQ29weUZhY3RvcnkuKnxSUEMnIDogJ1JQQycpO1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBzeW5jaHJvbml6ZWQ7XG4gICAgd2hpbGUgKCEoc3luY2hyb25pemVkID0gYXdhaXQgdGhpcy5pc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkpICYmXG4gICAgICAoc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDApID4gRGF0ZS5ub3coKSkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzKSk7XG4gICAgfVxuICAgIGxldCBzdGF0ZTtcbiAgICBpZiAoaW5zdGFuY2VJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpKSB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzU3luY2hyb25pemVkKHMuaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpKSB7XG4gICAgICAgICAgc3RhdGUgPSBzO1xuICAgICAgICAgIGluc3RhbmNlSW5kZXggPSBzLmluc3RhbmNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5maW5kKHMgPT4gcy5pbnN0YW5jZUluZGV4ID09PSBpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgaWYgKCFzeW5jaHJvbml6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBNZXRhQXBpIHRvIHN5bmNocm9uaXplIHRvIE1ldGFUcmFkZXIgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fYWNjb3VudC5pZCArICcsIHN5bmNocm9uaXphdGlvbiBpZCAnICsgKHN5bmNocm9uaXphdGlvbklkIHx8IChzdGF0ZSAmJiBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQpIHx8XG4gICAgICAgICAgKHN0YXRlICYmIHN0YXRlLmxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCkpKTtcbiAgICB9XG4gICAgbGV0IHRpbWVMZWZ0SW5TZWNvbmRzID0gTWF0aC5tYXgoMCwgdGltZW91dEluU2Vjb25kcyAtIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKHN0YXRlLmluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnNbcmVnaW9uXTtcbiAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQud2FpdFN5bmNocm9uaXplZChhY2NvdW50SWQsIHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCksXG4gICAgICBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVMZWZ0SW5TZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGFzeW5jIGNsb3NlKGluc3RhbmNlSWQpIHtcbiAgICBpZiAodGhpcy5fb3BlbmVkKSB7XG4gICAgICB0aGlzLl9vcGVuZWRJbnN0YW5jZXMgPSB0aGlzLl9vcGVuZWRJbnN0YW5jZXMuZmlsdGVyKGlkID0+IGlkICE9PSBpbnN0YW5jZUlkKTtcbiAgICAgIGlmICghdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmxlbmd0aCAmJiAhdGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVmcmVzaEpvYik7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfTogQ2xvc2luZyBjb25uZWN0aW9uYCk7XG4gICAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4ID0ge307XG4gICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5yZW1vdmVTdHJlYW1pbmcodGhpcy5fYWNjb3VudCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsU3RhdGUuY2xvc2UoKTtcbiAgICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbnMgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2hpc3RvcnlTdG9yYWdlKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2hlYWx0aE1vbml0b3IpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX2hlYWx0aE1vbml0b3Iuc3RvcCgpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cykuZm9yRWFjaCh0aW1lb3V0ID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhhY2NvdW50UmVnaW9ucykuZm9yRWFjaChyZXBsaWNhSWQgPT4gXG4gICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFjY291bnRDYWNoZShyZXBsaWNhSWQpKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke3RoaXMuX2FjY291bnQuaWR9OiBDbG9zZWQgY29ubmVjdGlvbmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN5bmNocm9uaXphdGlvbiBzdGF0dXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gc3luY2hyb25pemF0aW9uIHN0YXR1c1xuICAgKi9cbiAgZ2V0IHN5bmNocm9uaXplZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLnN5bmNocm9uaXplZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9uSGVhbHRoTW9uaXRvcn0gY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGhlYWx0aE1vbml0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWx0aE1vbml0b3I7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXSA9PT0gc2Vzc2lvbikge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zTGlzdCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucyhrZXkpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNJdGVtID0ge3N5bWJvbDoga2V5fTtcbiAgICAgICAgICBpZihzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zSXRlbS5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QucHVzaChzdWJzY3JpcHRpb25zSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvciByZWZyZXNoaW5nIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgam9iIGZvciBhY2NvdW50ICR7dGhpcy5fYWNjb3VudC5pZH0gYCArXG4gICAgICBgJHtpbnN0YW5jZU51bWJlcn1gLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV0gPT09IHNlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlZnJlc2hJbnRlcnZhbCA9IChNYXRoLnJhbmRvbSgpICogKHRoaXMuX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCAtIFxuICAgICAgICAgIHRoaXMuX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCkgKyB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwpICogMTAwMDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0gPSBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pLCByZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlID0ge307XG4gICAgaWYgKHR5cGVvZiBzdG9wTG9zcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3M7XG4gICAgfSBlbHNlIGlmIChzdG9wTG9zcykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcy52YWx1ZTtcbiAgICAgIHRyYWRlLnN0b3BMb3NzVW5pdHMgPSBzdG9wTG9zcy51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWtlUHJvZml0ID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQ7XG4gICAgfSBlbHNlIGlmICh0YWtlUHJvZml0KSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdC52YWx1ZTtcbiAgICAgIHRyYWRlLnRha2VQcm9maXRVbml0cyA9IHRha2VQcm9maXQudW5pdHM7XG4gICAgfVxuICAgIHJldHVybiB0cmFkZTtcbiAgfVxuXG4gIGFzeW5jIF9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwga2V5KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnNob3VsZFN5bmNocm9uaXplICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN5bmNocm9uaXphdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY2hyb25pemUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgIGlmKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZm9yIGFjY291bnQgJyArIHRoaXMuX2FjY291bnQuaWQgK1xuICAgICAgICAgICc6JyArIGluc3RhbmNlSW5kZXggKyAnIGZhaWxlZCB0byBzeW5jaHJvbml6ZScsIGVycik7XG4gICAgICAgIGlmIChzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9PT0ga2V5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fZW5zdXJlU3luY2hyb25pemVkLmJpbmQodGhpcywgaW5zdGFuY2VJbmRleCwga2V5KSxcbiAgICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzID0gTWF0aC5taW4oc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDIsIDMwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSkge1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSA9IHtcbiAgICAgICAgaW5zdGFuY2VJbmRleCxcbiAgICAgICAgb3JkZXJzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgZGVhbHNTeW5jaHJvbml6ZWQ6IHt9LFxuICAgICAgICBzaG91bGRTeW5jaHJvbml6ZTogdW5kZWZpbmVkLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzOiAxLFxuICAgICAgICBzeW5jaHJvbml6ZWQ6IGZhbHNlLFxuICAgICAgICBsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGRpc2Nvbm5lY3RlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdO1xuICB9XG5cbiAgX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIGlmIChzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGxldCBzeW5jaHJvbml6YXRpb25UaW1lb3V0ID0gMiAqIDYwICogMTAwMDtcbiAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQgPVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2NoZWNrU3luY2hyb25pemF0aW9uVGltZWRPdXQoaW5zdGFuY2VJbmRleCksIHN5bmNocm9uaXphdGlvblRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIF9jaGVja1N5bmNocm9uaXphdGlvblRpbWVkT3V0KGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgbGV0IHN5bmNocm9uaXphdGlvbklkID0gc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgICAgbGV0IHN5bmNocm9uaXplZCA9ICEhc3RhdGUuZGVhbHNTeW5jaHJvbml6ZWRbc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgaWYgKCFzeW5jaHJvbml6ZWQgJiYgc3luY2hyb25pemF0aW9uSWQgJiYgc3RhdGUuc2hvdWxkU3luY2hyb25pemUpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogcmVzeW5jaHJvbml6ZWQgc2luY2UgbGF0ZXN0IHN5bmNocm9uaXphdGlvbiBgICtcbiAgICAgICAgICBgJHtzeW5jaHJvbml6YXRpb25JZH0gZGlkIG5vdCBmaW5pc2ggaW4gdGltZWApO1xuICAgICAgICB0aGlzLl9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3RhdGUuc2hvdWxkU3luY2hyb25pemUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iXSwibmFtZXMiOlsiVGVybWluYWxTdGF0ZSIsIk1lbW9yeUhpc3RvcnlTdG9yYWdlIiwiVGltZW91dEVycm9yIiwicmFuZG9tc3RyaW5nIiwiQ29ubmVjdGlvbkhlYWx0aE1vbml0b3IiLCJWYWxpZGF0aW9uRXJyb3IiLCJPcHRpb25zVmFsaWRhdG9yIiwiTG9nZ2VyTWFuYWdlciIsIk1ldGFBcGlDb25uZWN0aW9uIiwiU3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb24iLCJjb25uZWN0IiwiaW5zdGFuY2VJZCIsIl9vcGVuZWRJbnN0YW5jZXMiLCJpbmNsdWRlcyIsInB1c2giLCJfb3BlbmVkIiwiX2xvZ2dlciIsInRyYWNlIiwiX2FjY291bnQiLCJpZCIsImluaXRpYWxpemUiLCJzdWJzY3JpYmUiLCJlcnIiLCJjbG9zZSIsInJlbW92ZUFwcGxpY2F0aW9uIiwiX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlIiwiX2hpc3RvcnlTdG9yYWdlIiwiY2xlYXIiLCJfd2Vic29ja2V0Q2xpZW50Iiwic3luY2hyb25pemUiLCJpbnN0YW5jZUluZGV4IiwicmVnaW9uIiwiZ2V0UmVnaW9uIiwiaW5zdGFuY2UiLCJnZXRJbnN0YW5jZU51bWJlciIsImhvc3QiLCJnZXRIb3N0TmFtZSIsInN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSIsIkRhdGUiLCJNYXRoIiwibWF4IiwiX2hpc3RvcnlTdGFydFRpbWUiLCJnZXRUaW1lIiwibGFzdEhpc3RvcnlPcmRlclRpbWUiLCJzdGFydGluZ0RlYWxUaW1lIiwibGFzdERlYWxUaW1lIiwic3luY2hyb25pemF0aW9uSWQiLCJnZW5lcmF0ZSIsIl9nZXRTdGF0ZSIsImxhc3RTeW5jaHJvbml6YXRpb25JZCIsImFjY291bnRJZCIsImFjY291bnRSZWdpb25zIiwiZGVidWciLCJ0ZXJtaW5hbFN0YXRlIiwiZ2V0SGFzaGVzIiwiX2Nvbm5lY3Rpb25SZWdpc3RyeSIsImFwcGxpY2F0aW9uIiwiYWRkQWNjb3VudENhY2hlIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInJlcGxpY2FJZCIsImVuc3VyZVN1YnNjcmliZSIsInN1YnNjcmliZVRvTWFya2V0RGF0YSIsInN5bWJvbCIsInN1YnNjcmlwdGlvbnMiLCJ0aW1lb3V0SW5TZWNvbmRzIiwid2FpdEZvclF1b3RlIiwiX3Rlcm1pbmFsU3RhdGUiLCJzcGVjaWZpY2F0aW9uIiwidHlwZSIsIl9zdWJzY3JpcHRpb25zIiwicHJldlN1YnNjcmlwdGlvbnMiLCJzdWJzY3JpcHRpb24iLCJpbmRleCIsImZpbmRJbmRleCIsIml0ZW0iLCJ0aW1lZnJhbWUiLCJyZWxpYWJpbGl0eSIsImZpbmQiLCJzIiwid2FpdEZvclByaWNlIiwidW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSIsImZpbHRlciIsInMyIiwibGVuZ3RoIiwib25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkIiwidXBkYXRlcyIsInVuc3Vic2NyaXB0aW9ucyIsImNhdGNoIiwibmFtZSIsImVycm9yIiwiaW50ZXJ2YWxJbk1pbGxpaXNlY29uZHMiLCJpbnRlcnZhbEluTWlsbGlzZWNvbmRzIiwic3Vic2NyaWJlZFN5bWJvbHMiLCJrZXlzIiwiaGlzdG9yeVN0b3JhZ2UiLCJvbkNvbm5lY3RlZCIsInJlcGxpY2FzIiwia2V5Iiwic3RhdGUiLCJjYW5jZWxSZWZyZXNoIiwiX3Rlcm1pbmFsSGFzaE1hbmFnZXIiLCJyZWZyZXNoSWdub3JlZEZpZWxkTGlzdHMiLCJzaG91bGRTeW5jaHJvbml6ZSIsInN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMiLCJzeW5jaHJvbml6ZWQiLCJfZW5zdXJlU3luY2hyb25pemVkIiwib25EaXNjb25uZWN0ZWQiLCJsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQiLCJ1bmRlZmluZWQiLCJkaXNjb25uZWN0ZWQiLCJpbnN0YW5jZU51bWJlciIsIl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zIiwiY2xlYXJUaW1lb3V0IiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMiLCJzeW5jaHJvbml6YXRpb25UaW1lb3V0IiwiZW5zdXJlU3luY2hyb25pemVUaW1lb3V0Iiwib25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJzcGVjaWZpY2F0aW9ucyIsInJlbW92ZWRTeW1ib2xzIiwiX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dCIsIm9uUG9zaXRpb25zU3luY2hyb25pemVkIiwib25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkIiwib25EZWFsc1N5bmNocm9uaXplZCIsImRlYWxzU3luY2hyb25pemVkIiwib25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkIiwib3JkZXJzU3luY2hyb25pemVkIiwib25SZWNvbm5lY3RlZCIsImluc3RhbmNlVGVtcGxhdGUiLCJfc3RhdGVCeUluc3RhbmNlSW5kZXgiLCJzdGFydHNXaXRoIiwib25TdHJlYW1DbG9zZWQiLCJvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQiLCJzcGVjaWZpY2F0aW9uc0hhc2giLCJwb3NpdGlvbnNIYXNoIiwib3JkZXJzSGFzaCIsInNlc3Npb25JZCIsIl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMiLCJfY2xvc2VkIiwib25VbnN1YnNjcmliZVJlZ2lvbiIsImlzU3luY2hyb25pemVkIiwicmVkdWNlIiwiYWNjIiwiY2hlY2tTeW5jaHJvbml6YXRpb25JZCIsIndhaXRTeW5jaHJvbml6ZWQiLCJvcHRzIiwiYXBwbGljYXRpb25QYXR0ZXJuIiwic3RhcnRUaW1lIiwibm93IiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJ0aW1lTGVmdEluU2Vjb25kcyIsImNsZWFySW50ZXJ2YWwiLCJfcmVmcmVzaEpvYiIsInJlbW92ZVN0cmVhbWluZyIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiX2hlYWx0aE1vbml0b3IiLCJyZW1vdmVSZWNvbm5lY3RMaXN0ZW5lciIsInN0b3AiLCJ0aW1lb3V0IiwicmVtb3ZlQWNjb3VudENhY2hlIiwiYWNjb3VudCIsImhlYWx0aE1vbml0b3IiLCJzZXNzaW9uIiwiZ2V0QWNjb3VudFJlZ2lvbiIsInN1YnNjcmlwdGlvbnNMaXN0Iiwic3Vic2NyaXB0aW9uc0l0ZW0iLCJyZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMiLCJyZWZyZXNoSW50ZXJ2YWwiLCJyYW5kb20iLCJfbWF4U3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsIiwiX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCIsIl9nZW5lcmF0ZVN0b3BPcHRpb25zIiwic3RvcExvc3MiLCJ0YWtlUHJvZml0IiwidHJhZGUiLCJ2YWx1ZSIsInN0b3BMb3NzVW5pdHMiLCJ1bml0cyIsInRha2VQcm9maXRVbml0cyIsInN5bmNocm9uaXphdGlvblJlc3VsdCIsImJpbmQiLCJtaW4iLCJfY2hlY2tTeW5jaHJvbml6YXRpb25UaW1lZE91dCIsIndhcm4iLCJjb25zdHJ1Y3RvciIsIndlYnNvY2tldENsaWVudCIsInRlcm1pbmFsSGFzaE1hbmFnZXIiLCJjb25uZWN0aW9uUmVnaXN0cnkiLCJoaXN0b3J5U3RhcnRUaW1lIiwicmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIiwidmFsaWRhdG9yIiwidmFsaWRhdGVOb25aZXJvIiwibWluRGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsImFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiYWRkUmVjb25uZWN0TGlzdGVuZXIiLCJnZXRMb2dnZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxPQUFPQSxtQkFBbUIsa0JBQWtCO0FBQzVDLE9BQU9DLDBCQUEwQix5QkFBeUI7QUFDMUQsT0FBT0Msa0JBQWtCLDBCQUEwQjtBQUNuRCxPQUFPQyxrQkFBa0IsZUFBZTtBQUN4QyxPQUFPQyw2QkFBNkIsNEJBQTRCO0FBQ2hFLFNBQVFDLGVBQWUsUUFBTywwQkFBMEI7QUFDeEQsT0FBT0Msc0JBQXNCLDhCQUE4QjtBQUMzRCxPQUFPQyxtQkFBbUIsWUFBWTtBQUN0QyxPQUFPQyx1QkFBdUIsc0JBQXNCO0FBS3JDLElBQUEsQUFBTUMsNkJBQU4sTUFBTUEsbUNBQW1DRDtJQTBDdEQ7Ozs7R0FJQyxHQUNELEFBQU1FLFFBQVFDLFVBQVU7O2VBQXhCLG9CQUFBO1lBQ0UsSUFBRyxDQUFDLE1BQUtDLGdCQUFnQixDQUFDQyxRQUFRLENBQUNGLGFBQWE7Z0JBQzlDLE1BQUtDLGdCQUFnQixDQUFDRSxJQUFJLENBQUNIO1lBQzdCO1lBQ0EsSUFB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