'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
import randomstring from 'randomstring';
import socketIO from 'socket.io-client';
import TimeoutError from '../timeoutError';
import { ValidationError, NotFoundError, InternalError, UnauthorizedError, TooManyRequestsError, ForbiddenError } from '../errorHandler';
import OptionsValidator from '../optionsValidator';
import NotSynchronizedError from './notSynchronizedError';
import NotConnectedError from './notConnectedError';
import TradeError from './tradeError';
import PacketOrderer from './packetOrderer';
import SynchronizationThrottler from './synchronizationThrottler';
import SubscriptionManager from './subscriptionManager';
import LoggerManager from '../../logger';
import any from 'promise.any';
import LatencyService from './latencyService';
let PacketLogger;
if (typeof window === 'undefined') {
    PacketLogger = require('./packetLogger').default;
}
let MetaApiWebsocketClient = class MetaApiWebsocketClient {
    /**
   * Restarts the account synchronization process on an out of order packet
   * @param {String} accountId account id
   * @param {Number} instanceIndex instance index
   * @param {Number} expectedSequenceNumber expected s/n
   * @param {Number} actualSequenceNumber actual s/n
   * @param {Object} packet packet data
   * @param {Date} receivedAt time the packet was received at
   */ onOutOfOrderPacket(accountId, instanceIndex, expectedSequenceNumber, actualSequenceNumber, packet, receivedAt) {
        if (this._subscriptionManager.isSubscriptionActive(accountId)) {
            this._logger.error('MetaApi websocket client received an out of order ' + `packet type ${packet.type} for account id ${accountId}:${instanceIndex}. Expected s/n ` + `${expectedSequenceNumber} does not match the actual of ${actualSequenceNumber}`);
            this.ensureSubscribe(accountId, instanceIndex);
        }
    }
    /**
   * Patch server URL for use in unit tests
   * @param {String} url patched server URL
   */ set url(url) {
        this._url = url;
    }
    /**
   * Websocket client predefined region
   * @returns {String} predefined region
   */ get region() {
        return this._region;
    }
    /**
   * Returns the list of socket instance dictionaries
   * @return {Object[]} list of socket instance dictionaries
   */ get socketInstances() {
        return this._socketInstances;
    }
    /**
   * Returns the dictionary of socket instances by account ids
   * @return {Object} dictionary of socket instances by account ids
   */ get socketInstancesByAccounts() {
        return this._socketInstancesByAccounts;
    }
    /**
   * Returns the dictionary of account replicas by region
   * @return {Object} dictionary of account replicas by region
   */ get accountReplicas() {
        return this._accountReplicas;
    }
    /**
   * Returns the dictionary of primary account ids by replica ids
   * @return {Object} dictionary of primary account ids by replica ids
   */ get accountsByReplicaId() {
        return this._accountsByReplicaId;
    }
    /**
   * Returns clear account cache job. Used for tests
   * @return {Function} clear account cache job
   */ get clearAccountCacheJob() {
        return this._clearAccountCacheJob.bind(this);
    }
    /**
   * Returns the list of subscribed account ids
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @return {string[]} list of subscribed account ids
   */ subscribedAccountIds(instanceNumber, socketInstanceIndex, region) {
        const connectedIds = [];
        if (this._socketInstancesByAccounts[instanceNumber]) {
            Object.keys(this._connectedHosts).forEach((instanceId)=>{
                const accountId = instanceId.split(':')[0];
                const accountRegion = this.getAccountRegion(accountId);
                if (!connectedIds.includes(accountId) && this._socketInstancesByAccounts[instanceNumber][accountId] !== undefined && (this._socketInstancesByAccounts[instanceNumber][accountId] === socketInstanceIndex || socketInstanceIndex === undefined) && accountRegion === region) {
                    connectedIds.push(accountId);
                }
            });
        }
        return connectedIds;
    }
    /**
   * Returns websocket client connection status
   * @param {Number} instanceNumber instance index number
   * @param {Number} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @returns {Boolean} websocket client connection status
   */ connected(instanceNumber, socketInstanceIndex, region) {
        const instance = this._socketInstances[region] && this._socketInstances[region][instanceNumber].length > socketInstanceIndex ? this._socketInstances[region][instanceNumber][socketInstanceIndex] : null;
        return instance && instance.socket && instance.socket.connected || false;
    }
    /**
   * Returns list of accounts assigned to instance
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @returns 
   */ getAssignedAccounts(instanceNumber, socketInstanceIndex, region) {
        const accountIds = [];
        Object.keys(this._socketInstancesByAccounts[instanceNumber]).forEach((key)=>{
            const accountRegion = this.getAccountRegion(key);
            if (accountRegion === region && this._socketInstancesByAccounts[instanceNumber][key] === socketInstanceIndex) {
                accountIds.push(key);
            }
        });
        return accountIds;
    }
    /**
   * Returns account region by id
   * @param {String} accountId account id
   * @returns {String} account region
   */ getAccountRegion(accountId) {
        return this._regionsByAccounts[accountId] && this._regionsByAccounts[accountId].region;
    }
    /**
   * Adds account cache info
   * @param {String} accountId account id
   * @param {Object} replicas account replicas
   */ addAccountCache(accountId, replicas) {
        this._accountReplicas[accountId] = replicas;
        Object.keys(replicas).forEach((region)=>{
            const replicaId = replicas[region];
            if (!this._regionsByAccounts[replicaId]) {
                this._regionsByAccounts[replicaId] = {
                    region,
                    connections: 1,
                    lastUsed: Date.now()
                };
            } else {
                this._regionsByAccounts[replicaId].connections++;
            }
            this._accountsByReplicaId[replicaId] = accountId;
        });
    }
    /**
   * Updates account cache info
   * @param {String} accountId account id
   * @param {Object} replicas account replicas
   */ updateAccountCache(accountId, replicas) {
        const oldReplicas = this._accountReplicas[accountId];
        if (oldReplicas) {
            const connectionCount = this._regionsByAccounts[accountId].connections;
            Object.keys(oldReplicas).forEach((region)=>{
                const replicaId = replicas[region];
                delete this._accountsByReplicaId[replicaId];
                delete this._regionsByAccounts[replicaId];
            });
            this._accountReplicas[accountId] = replicas;
            Object.keys(replicas).forEach((region)=>{
                const replicaId = replicas[region];
                this._regionsByAccounts[replicaId] = {
                    region,
                    connections: connectionCount,
                    lastUsed: Date.now()
                };
                this._accountsByReplicaId[replicaId] = accountId;
            });
        }
    }
    /**
   * Removes account region info
   * @param {String} accountId account id
   */ removeAccountCache(accountId) {
        if (this._regionsByAccounts[accountId]) {
            if (this._regionsByAccounts[accountId].connections > 0) {
                this._regionsByAccounts[accountId].connections--;
            }
        }
    }
    /**
   * Locks subscription for a socket instance based on TooManyRequestsError metadata
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @param {Object} metadata TooManyRequestsError metadata
   */ lockSocketInstance(instanceNumber, socketInstanceIndex, region, metadata) {
        var _this = this;
        return _async_to_generator(function*() {
            if (metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
                _this._subscribeLock = {
                    recommendedRetryTime: metadata.recommendedRetryTime,
                    lockedAtAccounts: _this.subscribedAccountIds(instanceNumber, undefined, region).length,
                    lockedAtTime: Date.now()
                };
            } else {
                const subscribedAccounts = _this.subscribedAccountIds(instanceNumber, socketInstanceIndex, region);
                if (subscribedAccounts.length === 0) {
                    const socketInstance = _this.socketInstances[region][instanceNumber][socketInstanceIndex];
                    socketInstance.socket.close();
                    yield _this._reconnect(instanceNumber, socketInstanceIndex, region);
                } else {
                    const instance = _this.socketInstances[region][instanceNumber][socketInstanceIndex];
                    instance.subscribeLock = {
                        recommendedRetryTime: metadata.recommendedRetryTime,
                        type: metadata.type,
                        lockedAtAccounts: subscribedAccounts.length
                    };
                }
            }
        })();
    }
    /**
   * Connects to MetaApi server via socket.io protocol
   * @param {Number} instanceNumber instance index number
   * @param {String} region server region
   * @returns {Promise} promise which resolves when connection is established
   */ connect(instanceNumber, region) {
        var _this = this;
        return _async_to_generator(function*() {
            let clientId = Math.random();
            let resolve;
            let result = new Promise((res, rej)=>{
                resolve = res;
            });
            const socketInstanceIndex = _this._socketInstances[region][instanceNumber].length;
            const instance = {
                id: socketInstanceIndex,
                reconnectWaitTime: _this._socketMinimumReconnectTimeout,
                connected: false,
                requestResolves: {},
                resolved: false,
                connectResult: result,
                sessionId: randomstring.generate(32),
                isReconnecting: false,
                socket: null,
                synchronizationThrottler: new SynchronizationThrottler(_this, socketInstanceIndex, instanceNumber, region, _this._synchronizationThrottlerOpts),
                subscribeLock: null,
                instanceNumber
            };
            instance.connected = true;
            _this._socketInstances[region][instanceNumber].push(instance);
            instance.synchronizationThrottler.start();
            const serverUrl = yield _this._getServerUrl(instanceNumber, socketInstanceIndex, region);
            const socketInstance = socketIO(serverUrl, {
                path: '/ws',
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: Infinity,
                timeout: _this._connectTimeout,
                extraHeaders: {
                    'Client-Id': clientId
                },
                query: {
                    'auth-token': _this._token,
                    clientId: clientId,
                    protocol: 3
                }
            });
            instance.socket = socketInstance;
            socketInstance.on('connect', /*#__PURE__*/ _async_to_generator(function*() {
                // eslint-disable-next-line no-console
                _this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client connected to the MetaApi server`);
                instance.reconnectWaitTime = _this._socketMinimumReconnectTimeout;
                instance.isReconnecting = false;
                if (!instance.resolved) {
                    instance.resolved = true;
                    resolve();
                } else {
                    yield _this._fireReconnected(instanceNumber, instance.id, region);
                }
                if (!instance.connected) {
                    instance.socket.close();
                }
            }));
            socketInstance.on('reconnect', /*#__PURE__*/ _async_to_generator(function*() {
                instance.isReconnecting = false;
                _this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client reconnected`);
                yield _this._fireReconnected(instanceNumber, instance.id, region);
            }));
            socketInstance.on('connect_error', function() {
                var _ref = _async_to_generator(function*(err) {
                    // eslint-disable-next-line no-console
                    _this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client connection error`, err);
                    instance.isReconnecting = false;
                    yield _this._reconnect(instanceNumber, instance.id, region);
                });
                return function(err) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('connect_timeout', function() {
                var _ref = _async_to_generator(function*(timeout) {
                    // eslint-disable-next-line no-console
                    _this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client connection timeout`);
                    instance.isReconnecting = false;
                    if (!instance.resolved) {
                        yield _this._reconnect(instanceNumber, instance.id, region);
                    }
                });
                return function(timeout) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('disconnect', function() {
                var _ref = _async_to_generator(function*(reason) {
                    instance.synchronizationThrottler.onDisconnect();
                    // eslint-disable-next-line no-console
                    _this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client disconnected from the ` + `MetaApi server because of ${reason}`);
                    instance.isReconnecting = false;
                    yield _this._reconnect(instanceNumber, instance.id, region);
                });
                return function(reason) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('error', function() {
                var _ref = _async_to_generator(function*(error) {
                    // eslint-disable-next-line no-console
                    _this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client error`, error);
                    instance.isReconnecting = false;
                    yield _this._reconnect(instanceNumber, instance.id, region);
                });
                return function(error) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('response', (data)=>{
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                _this._logger.debug(()=>`${data.accountId}: Response received: ${JSON.stringify({
                        requestId: data.requestId,
                        timestamps: data.timestamps
                    })}`);
                let requestResolve = instance.requestResolves[data.requestId] || {
                    resolve: ()=>{},
                    reject: ()=>{}
                };
                delete instance.requestResolves[data.requestId];
                _this._convertIsoTimeToDate(data);
                requestResolve.resolve(data);
                if (data.timestamps && requestResolve.type) {
                    data.timestamps.clientProcessingFinished = new Date();
                    for (let listener of _this._latencyListeners){
                        Promise.resolve().then(()=>requestResolve.type === 'trade' ? listener.onTrade(data.accountId, data.timestamps) : listener.onResponse(data.accountId, requestResolve.type, data.timestamps)).catch((error)=>_this._logger.error('Failed to process onResponse event for account ' + data.accountId + ', request type ' + requestResolve.type, error));
                    }
                }
            });
            socketInstance.on('processingError', (data)=>{
                let requestResolve = instance.requestResolves[data.requestId] || {
                    resolve: ()=>{},
                    reject: ()=>{}
                };
                delete instance.requestResolves[data.requestId];
                requestResolve.reject(_this._convertError(data));
            });
            // eslint-disable-next-line complexity
            socketInstance.on('synchronization', function() {
                var _ref = _async_to_generator(function*(data) {
                    if (typeof data === 'string') {
                        data = JSON.parse(data);
                    }
                    if (data.instanceIndex && data.instanceIndex !== instanceNumber) {
                        _this._logger.trace(()=>`${data.accountId}:${data.instanceNumber}: received packet with wrong instance ` + `index via a socket with instance number of ${instanceNumber}, data=${JSON.stringify({
                                type: data.type,
                                sequenceNumber: data.sequenceNumber,
                                sequenceTimestamp: data.sequenceTimestamp,
                                synchronizationId: data.synchronizationId,
                                application: data.application,
                                host: data.host,
                                specificationsUpdated: data.specificationsUpdated,
                                positionsUpdated: data.positionsUpdated,
                                ordersUpdated: data.ordersUpdated,
                                specifications: data.specifications ? (data.specifications || []).length : undefined
                            })}`);
                        return;
                    }
                    if (!_this._regionsByAccounts[data.accountId]) {
                        _this._regionsByAccounts[data.accountId] = {
                            region,
                            connections: 0,
                            lastUsed: Date.now()
                        };
                    }
                    _this._logger.trace(()=>`${data.accountId}:${data.instanceIndex}: Sync packet received: ${JSON.stringify({
                            type: data.type,
                            sequenceNumber: data.sequenceNumber,
                            sequenceTimestamp: data.sequenceTimestamp,
                            synchronizationId: data.synchronizationId,
                            application: data.application,
                            host: data.host,
                            specificationsUpdated: data.specificationsUpdated,
                            positionsUpdated: data.positionsUpdated,
                            ordersUpdated: data.ordersUpdated,
                            specifications: data.specifications ? (data.specifications || []).length : undefined
                        })}, ` + `active listeners: ${(_this._synchronizationListeners[data.accountId] || []).length}`);
                    let activeSynchronizationIds = instance.synchronizationThrottler.activeSynchronizationIds;
                    if (!data.synchronizationId || activeSynchronizationIds.includes(data.synchronizationId)) {
                        if (_this._packetLogger) {
                            yield _this._packetLogger.logPacket(data);
                        }
                        const ignoredPacketTypes = [
                            'disconnected',
                            'status',
                            'keepalive'
                        ];
                        if (!_this._subscriptionManager.isSubscriptionActive(data.accountId) && !ignoredPacketTypes.includes(data.type)) {
                            _this._logger.debug(`${data.accountId}: Packet arrived to inactive connection, attempting` + ` unsubscribe, packet: ${data.type}`);
                            if (_this._throttleRequest('unsubscribe', data.accountId, data.instanceIndex, _this._unsubscribeThrottlingInterval)) {
                                _this.unsubscribe(data.accountId).catch((err)=>{
                                    _this._logger.warn(`${data.accountId}:${data.instanceIndex || 0}: failed to unsubscribe`, err);
                                });
                            }
                            return;
                        }
                        _this._convertIsoTimeToDate(data);
                    } else {
                        data.type = 'noop';
                    }
                    _this.queuePacket(data);
                });
                return function(data) {
                    return _ref.apply(this, arguments);
                };
            }());
            return result;
        })();
    }
    /**
   * Closes connection to MetaApi server
   */ close() {
        Object.keys(this._socketInstances).forEach((region)=>{
            Object.keys(this._socketInstances[region]).forEach((instanceNumber)=>{
                this._socketInstances[region][instanceNumber].forEach(function() {
                    var _ref = _async_to_generator(function*(instance) {
                        if (instance.connected) {
                            instance.connected = false;
                            yield instance.socket.close();
                            for (let requestResolve of Object.values(instance.requestResolves)){
                                requestResolve.reject(new Error('MetaApi connection closed'));
                            }
                            instance.requestResolves = {};
                        }
                    });
                    return function(instance) {
                        return _ref.apply(this, arguments);
                    };
                }());
                this._socketInstancesByAccounts[instanceNumber] = {};
                this._socketInstances[region][instanceNumber] = [];
            });
        });
        this._synchronizationListeners = {};
        this._latencyListeners = [];
        this._packetOrderer.stop();
    }
    /**
   * Stops the client
   */ stop() {
        clearInterval(this._clearAccountCacheInterval);
        clearInterval(this._clearInactiveSyncDataJob);
        this._latencyService.stop();
    }
    /**
   * Returns account information for a specified MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {GetAccountInformationOptions} [options] additional request options
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */ getAccountInformation(accountId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getAccountInformation'
            }, options));
            return response.accountInformation;
        })();
    }
    /**
   * Returns positions for a specified MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {GetPositionsOptions} [options] additional request options
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */ getPositions(accountId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getPositions'
            }, options));
            return response.positions;
        })();
    }
    /**
   * Returns specific position for a MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @param {GetPositionOptions} [options] additional request options
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */ getPosition(accountId, positionId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getPosition',
                positionId
            }, options));
            return response.position;
        })();
    }
    /**
   * Returns open orders for a specified MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {GetOrdersOptions} [options] additional request options
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */ getOrders(accountId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getOrders'
            }, options));
            return response.orders;
        })();
    }
    /**
   * Returns specific open order for a MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} orderId order id (ticket number)
   * @param {GetOrderOptions} [options] additional request options
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */ getOrder(accountId, orderId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getOrder',
                orderId
            }, options));
            return response.order;
        })();
    }
    /**
   * MetaTrader history orders search query response
   * @typedef {Object} MetatraderHistoryOrders
   * @property {Array<MetatraderOrder>} historyOrders array of history orders returned
   * @property {Boolean} synchronizing flag indicating that history order initial synchronization is still in progress
   * and thus search results may be incomplete
   */ /**
   * Returns the history of completed orders for a specific ticket number.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */ getHistoryOrdersByTicket(accountId, ticket) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getHistoryOrdersByTicket',
                ticket
            });
            return {
                historyOrders: response.historyOrders,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns the history of completed orders for a specific position id
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */ getHistoryOrdersByPosition(accountId, positionId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getHistoryOrdersByPosition',
                positionId
            });
            return {
                historyOrders: response.historyOrders,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns the history of completed orders for a specific time range
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */ getHistoryOrdersByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getHistoryOrdersByTimeRange',
                startTime,
                endTime,
                offset,
                limit
            });
            return {
                historyOrders: response.historyOrders,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * MetaTrader history deals search query response
   * @typedef {Object} MetatraderDeals
   * @property {Array<MetatraderDeal>} deals array of history deals returned
   * @property {Boolean} synchronizing flag indicating that deal initial synchronization is still in progress
   * and thus search results may be incomplete
   */ /**
   * MetaTrader deal
   * @typedef {Object} MetatraderDeal
   * @property {String} id deal id (ticket number)
   * @property {String} type deal type (one of DEAL_TYPE_BUY, DEAL_TYPE_SELL, DEAL_TYPE_BALANCE, DEAL_TYPE_CREDIT,
   * DEAL_TYPE_CHARGE, DEAL_TYPE_CORRECTION, DEAL_TYPE_BONUS, DEAL_TYPE_COMMISSION, DEAL_TYPE_COMMISSION_DAILY,
   * DEAL_TYPE_COMMISSION_MONTHLY, DEAL_TYPE_COMMISSION_AGENT_DAILY, DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
   * DEAL_TYPE_INTEREST, DEAL_TYPE_BUY_CANCELED, DEAL_TYPE_SELL_CANCELED, DEAL_DIVIDEND, DEAL_DIVIDEND_FRANKED,
   * DEAL_TAX). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_type
   * @property {String} entryType deal entry type (one of DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT,
   * DEAL_ENTRY_OUT_BY). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_entry
   * @property {String} [symbol] symbol deal relates to
   * @property {Number} [magic] deal magic number, identifies the EA which initiated the deal
   * @property {Date} time time the deal was conducted at
   * @property {String} brokerTime time time the deal was conducted at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Number} [volume] deal volume
   * @property {Number} [price] the price the deal was conducted at
   * @property {Number} [commission] deal commission
   * @property {Number} [swap] deal swap
   * @property {Number} profit deal profit
   * @property {String} [positionId] id of position the deal relates to
   * @property {String} [orderId] id of order the deal relates to
   * @property {String} [comment] deal comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [brokerComment] current comment value on broker side (possibly overriden by the broker)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} [reason] optional deal execution reason. One of DEAL_REASON_CLIENT, DEAL_REASON_MOBILE,
   * DEAL_REASON_WEB, DEAL_REASON_EXPERT, DEAL_REASON_SL, DEAL_REASON_TP, DEAL_REASON_SO, DEAL_REASON_ROLLOVER,
   * DEAL_REASON_VMARGIN, DEAL_REASON_SPLIT, DEAL_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_reason.
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {number} [stopLoss] deal stop loss. For MT5 opening deal this is the SL of the order opening the 
   * position. For MT4 deals or MT5 closing deal this is the last known position SL.
   * @property {number} [takeProfit] deal take profit. For MT5 opening deal this is the TP of the order opening the 
   * position. For MT4 deals or MT5 closing deal this is the last known position TP.
   */ /**
   * Returns history deals with a specific ticket number
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */ getDealsByTicket(accountId, ticket) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getDealsByTicket',
                ticket
            });
            return {
                deals: response.deals,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns history deals for a specific position id
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */ getDealsByPosition(accountId, positionId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getDealsByPosition',
                positionId
            });
            return {
                deals: response.deals,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns history deals with for a specific time range
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */ getDealsByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getDealsByTimeRange',
                startTime,
                endTime,
                offset,
                limit
            });
            return {
                deals: response.deals,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Clears the order and transaction history of a specified application and removes the application
   * @param {String} accountId id of the MetaTrader account to remove history and application for
   * @return {Promise} promise resolving when the history is cleared
   */ removeApplication(accountId) {
        return this.rpcRequest(accountId, {
            type: 'removeApplication'
        });
    }
    /**
   * MetaTrader trade response
   * @typedef {Object} MetatraderTradeResponse
   * @property {Number} numericCode numeric response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are 0, 10008-10010, 10025. The rest
   * codes are errors
   * @property {String} stringCode string response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are ERR_NO_ERROR,
   * TRADE_RETCODE_PLACED, TRADE_RETCODE_DONE, TRADE_RETCODE_DONE_PARTIAL, TRADE_RETCODE_NO_CHANGES. The rest codes are
   * errors.
   * @property {String} message human-readable response message
   * @property {String} orderId order id which was created/modified during the trade
   * @property {String} positionId position id which was modified during the trade
   */ /**
   * Execute a trade on a connected MetaTrader account
   * @param {String} accountId id of the MetaTrader account to execute trade for
   * @param {MetatraderTrade} trade trade to execute (see docs for possible trade types)
   * @param {String} [application] application to use
   * @param {String} [reliability] account reliability
   * @returns {Promise<MetatraderTradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ // eslint-disable-next-line complexity
    trade(accountId, trade, application, reliability) {
        var _this = this;
        return _async_to_generator(function*() {
            let response;
            if (application === 'RPC') {
                response = yield _this.rpcRequest(accountId, {
                    type: 'trade',
                    trade,
                    application
                });
            } else {
                response = yield _this.rpcRequestAllInstances(accountId, {
                    type: 'trade',
                    trade,
                    application: application || _this._application,
                    requestId: randomstring.generate(32)
                }, reliability);
            }
            response.response = response.response || {};
            response.response.stringCode = response.response.stringCode || response.response.description;
            response.response.numericCode = response.response.numericCode !== undefined ? response.response.numericCode : response.response.error;
            if ([
                'ERR_NO_ERROR',
                'TRADE_RETCODE_PLACED',
                'TRADE_RETCODE_DONE',
                'TRADE_RETCODE_DONE_PARTIAL',
                'TRADE_RETCODE_NO_CHANGES'
            ].includes(response.response.stringCode || response.response.description)) {
                return response.response;
            } else {
                throw new TradeError(response.response.message, response.response.numericCode, response.response.stringCode);
            }
        })();
    }
    /**
   * Creates a task that ensures the account gets subscribed to the server
   * @param {String} accountId account id to subscribe
   * @param {Number} instanceNumber instance index number
   */ ensureSubscribe(accountId, instanceNumber) {
        this._subscriptionManager.scheduleSubscribe(accountId, instanceNumber);
    }
    /**
   * Subscribes to the Metatrader terminal events
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when subscription started
   */ subscribe(accountId, instanceNumber) {
        return this._subscriptionManager.subscribe(accountId, instanceNumber);
    }
    /**
   * Requests the terminal to start synchronization process
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceIndex instance index
   * @param {String} host name of host to synchronize with
   * @param {String} synchronizationId synchronization request id
   * @param {Date} startingHistoryOrderTime from what date to start synchronizing history orders from. If not specified,
   * the entire order history will be downloaded.
   * @param {Date} startingDealTime from what date to start deal synchronization from. If not specified, then all
   * history deals will be downloaded.
   * @param {Function} getHashes function to get terminal state hashes
   * @returns {Promise} promise which resolves when synchronization started
   */ synchronize(accountId, instanceIndex, host, synchronizationId, startingHistoryOrderTime, startingDealTime, hashes) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._getSocketInstanceByAccount(accountId, instanceIndex) === undefined) {
                _this._logger.debug(`${accountId}:${instanceIndex}: creating socket instance on synchronize`);
                yield _this._createSocketInstanceByAccount(accountId, instanceIndex);
            }
            const syncThrottler = _this._getSocketInstanceByAccount(accountId, instanceIndex).synchronizationThrottler;
            _this._synchronizationHashes[synchronizationId] = hashes;
            _this._synchronizationHashes[synchronizationId].lastUpdated = Date.now();
            return syncThrottler.scheduleSynchronize(accountId, {
                requestId: synchronizationId,
                version: 2,
                type: 'synchronize',
                startingHistoryOrderTime,
                startingDealTime,
                instanceIndex,
                host
            }, hashes);
        })();
    }
    /**
   * Waits for server-side terminal state synchronization to complete
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} [instanceNumber] instance index number
   * @param {String} applicationPattern MetaApi application regular expression pattern, default is .*
   * @param {Number} timeoutInSeconds timeout in seconds, default is 300 seconds
   * @param {String} [application] application to synchronize with
   * @returns {Promise} promise which resolves when synchronization started
   */ waitSynchronized(accountId, instanceNumber, applicationPattern, timeoutInSeconds, application) {
        return this.rpcRequest(accountId, {
            type: 'waitSynchronized',
            applicationPattern,
            timeoutInSeconds,
            instanceIndex: instanceNumber,
            application: application || this._application
        }, timeoutInSeconds + 1);
    }
    /**
   * Market data subscription
   * @typedef {Object} MarketDataSubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   * @property {string} [timeframe] when subscription type is candles, defines the timeframe according to which the
   * candles must be generated. Allowed values for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h,
   * 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @property {number} [intervalInMilliseconds] defines how frequently the terminal will stream data to client. If not
   * set, then the value configured in account will be used
   */ /**
   * Subscribes on market data of specified symbol
   * @param {String} accountId id of the MetaTrader account
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update
   * @param {String} [reliability] account reliability
   * @returns {Promise} promise which resolves when subscription request was processed
   */ subscribeToMarketData(accountId, symbol, subscriptions, reliability) {
        return this.rpcRequestAllInstances(accountId, {
            type: 'subscribeToMarketData',
            symbol,
            subscriptions
        }, reliability);
    }
    /**
   * Refreshes market data subscriptions on the server to prevent them from expiring
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Array} subscriptions array of subscriptions to refresh
   */ refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptions) {
        return this.rpcRequest(accountId, {
            type: 'refreshMarketDataSubscriptions',
            subscriptions,
            instanceIndex: instanceNumber
        });
    }
    /**
   * Market data unsubscription
   * @typedef {Object} MarketDataUnsubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   */ /**
   * Unsubscribes from market data of specified symbol
   * @param {String} accountId id of the MetaTrader account
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @param {String} [reliability] account reliability
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */ unsubscribeFromMarketData(accountId, symbol, subscriptions, reliability) {
        return this.rpcRequestAllInstances(accountId, {
            type: 'unsubscribeFromMarketData',
            symbol,
            subscriptions
        }, reliability);
    }
    /**
   * Retrieves symbols available on an account
   * @param {String} accountId id of the MetaTrader account to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */ getSymbols(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getSymbols'
            });
            return response.symbols;
        })();
    }
    /**
   * Retrieves specification for a symbol
   * @param {String} accountId id of the MetaTrader account to retrieve symbol specification for
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */ getSymbolSpecification(accountId, symbol) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getSymbolSpecification',
                symbol
            });
            return response.specification;
        })();
    }
    /**
   * Retrieves price for a symbol
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {String} symbol symbol to retrieve price for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */ getSymbolPrice(accountId, symbol, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getSymbolPrice',
                symbol,
                keepSubscription
            });
            return response.price;
        })();
    }
    /**
   * Retrieves price for a symbol
   * @param {string} accountId id of the MetaTrader account to retrieve candle for
   * @param {string} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */ getCandle(accountId, symbol, timeframe, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getCandle',
                symbol,
                timeframe,
                keepSubscription
            });
            return response.candle;
        })();
    }
    /**
   * Retrieves latest tick for a symbol. MT4 G1 accounts do not support this API
   * @param {string} accountId id of the MetaTrader account to retrieve symbol tick for
   * @param {string} symbol symbol to retrieve tick for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */ getTick(accountId, symbol, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getTick',
                symbol,
                keepSubscription
            });
            return response.tick;
        })();
    }
    /**
   * Retrieves latest order book for a symbol. MT4 accounts do not support this API
   * @param {string} accountId id of the MetaTrader account to retrieve symbol order book for
   * @param {string} symbol symbol to retrieve order book for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderBook>} promise which resolves when order book is retrieved
   */ getBook(accountId, symbol, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getBook',
                symbol,
                keepSubscription
            });
            return response.book;
        })();
    }
    /**
   * Forces refresh of most recent quote updates for symbols subscribed to by the terminal
   * @param {string} accountId id of the MetaTrader account
   * @returns {Promise<string[]>} promise which resolves with recent quote symbols that was initiated to process
   */ refreshTerminalState(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'refreshTerminalState'
            });
            return response.symbols;
        })();
    }
    /**
   * Forces refresh and retrieves latest quotes for a subset of symbols the terminal is subscribed to
   * @param {string} accountId id of the MetaTrader account
   * @param {string[]} symbols quote symbols to refresh
   * @returns {Promise<RefreshedQuotes>} refreshed quotes and basic account information info
   */ refreshSymbolQuotes(accountId, symbols) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'refreshSymbolQuotes',
                symbols
            });
            return response.refreshedQuotes;
        })();
    }
    /**
   * Sends client uptime stats to the server.
   * @param {String} accountId id of the MetaTrader account to save uptime
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */ saveUptime(accountId, uptime) {
        return this.rpcRequest(accountId, {
            type: 'saveUptime',
            uptime
        });
    }
    /**
   * Unsubscribe from account
   * @param {String} accountId id of the MetaTrader account to unsubscribe
   * @returns {Promise} promise which resolves when socket unsubscribed
   */ unsubscribe(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            const region = _this.getAccountRegion(accountId);
            _this._latencyService.onUnsubscribe(accountId);
            const updateEventsToRemove = Object.keys(_this._updateEvents).filter((key)=>key.startsWith(accountId));
            updateEventsToRemove.forEach((key)=>delete _this._updateEvents[key]);
            if (_this._socketInstances[region]) {
                yield Promise.all(Object.keys(_this._socketInstances[region]).map(function() {
                    var _ref = _async_to_generator(function*(instanceNumber) {
                        try {
                            yield _this._subscriptionManager.unsubscribe(accountId, Number(instanceNumber));
                            delete _this._socketInstancesByAccounts[instanceNumber][accountId];
                        } catch (err) {
                            if (![
                                'TimeoutError',
                                'NotFoundError'
                            ].includes(err.name)) {
                                _this._logger.warn(`${accountId}:${instanceNumber}: failed to unsubscribe`, err);
                            }
                        }
                    });
                    return function(instanceNumber) {
                        return _ref.apply(this, arguments);
                    };
                }()));
            }
        })();
    }
    /**
   * Current server time (see https://metaapi.cloud/docs/client/models/serverTime/)
   * @typedef {Object} ServerTime
   * @property {Date} time current server time
   * @property {String} brokerTime current broker time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} [lastQuoteTime] last quote time
   * @property {String} [lastQuoteBrokerTime] last quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * Returns server time for a specified MetaTrader account
   * @param {string} accountId id of the MetaTrader account to return server time for
   * @returns {Promise<ServerTime>} promise resolving with server time
   */ getServerTime(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getServerTime'
            });
            return response.serverTime;
        })();
    }
    /**
   * Margin required to open a trade (see https://metaapi.cloud/docs/client/models/margin/)
   * @typedef {Object} Margin
   * @property {number} [margin] margin required to open a trade. If margin can not be calculated, then this field is
   * not defined
   */ /**
   * Contains order to calculate margin for (see https://metaapi.cloud/docs/client/models/marginOrder/)
   * @typedef {Object} MarginOrder
   * @property {string} symbol order symbol
   * @property {string} type order type, one of ORDER_TYPE_BUY or ORDER_TYPE_SELL
   * @property {number} volume order volume, must be greater than 0
   * @property {number} openPrice order open price, must be greater than 0
   */ /**
   * Calculates margin required to open a trade on the specified trading account
   * @param {string} accountId id of the trading account to calculate margin for
   * @param {string} application application to send the request to
   * @param {string} reliability account reliability
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */ calculateMargin(accountId, application, reliability, order) {
        var _this = this;
        return _async_to_generator(function*() {
            let response;
            if (application === 'RPC') {
                response = yield _this.rpcRequest(accountId, {
                    application,
                    type: 'calculateMargin',
                    order
                });
            } else {
                response = yield _this.rpcRequestAllInstances(accountId, {
                    application,
                    type: 'calculateMargin',
                    order
                }, reliability);
            }
            return response.margin;
        })();
    }
    /**
   * Calls onUnsubscribeRegion listener event 
   * @param {String} accountId account id
   * @param {String} region account region to unsubscribe
   */ unsubscribeAccountRegion(accountId, region) {
        var _this = this;
        return _async_to_generator(function*() {
            const unsubscribePromises = [];
            for (let listener of _this._synchronizationListeners[accountId] || []){
                unsubscribePromises.push(Promise.resolve(_async_to_generator(function*() {
                    yield _this._processEvent(()=>listener.onUnsubscribeRegion(region), `${accountId}:${region}:onUnsubscribeRegion`, true);
                })()).catch((err)=>_this._logger.error(`${accountId}:${region}: Failed to notify listener ` + 'about onUnsubscribeRegion event', err)));
            }
            yield Promise.all(unsubscribePromises);
        })();
    }
    /**
   * Adds synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to add
   */ addSynchronizationListener(accountId, listener) {
        this._logger.trace(`${accountId}: Added synchronization listener`);
        let listeners = this._synchronizationListeners[accountId];
        if (!listeners) {
            listeners = [];
            this._synchronizationListeners[accountId] = listeners;
        }
        listeners.push(listener);
    }
    /**
   * Removes synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to remove
   */ removeSynchronizationListener(accountId, listener) {
        this._logger.trace(`${accountId}: Removed synchronization listener`);
        let listeners = this._synchronizationListeners[accountId];
        if (!listeners) {
            listeners = [];
        }
        listeners = listeners.filter((l)=>l !== listener);
        this._synchronizationListeners[accountId] = listeners;
    }
    /**
   * Adds latency listener
   * @param {LatencyListener} listener latency listener to add
   */ addLatencyListener(listener) {
        this._latencyListeners.push(listener);
    }
    /**
   * Removes latency listener
   * @param {LatencyListener} listener latency listener to remove
   */ removeLatencyListener(listener) {
        this._latencyListeners = this._latencyListeners.filter((l)=>l !== listener);
    }
    /**
   * Adds reconnect listener
   * @param {ReconnectListener} listener reconnect listener to add
   * @param {String} accountId account id of listener
   */ addReconnectListener(listener, accountId) {
        this._reconnectListeners.push({
            accountId,
            listener
        });
    }
    /**
   * Removes reconnect listener
   * @param {ReconnectListener} listener listener to remove
   */ removeReconnectListener(listener) {
        this._reconnectListeners = this._reconnectListeners.filter((l)=>l.listener !== listener);
    }
    /**
   * Removes all listeners. Intended for use in unit tests.
   */ removeAllListeners() {
        this._synchronizationListeners = {};
        this._reconnectListeners = [];
    }
    /**
   * Clears account or replica data from client records and unsubscribes
   * @param {string} accountId account id to process the removal of
   */ onAccountDeleted(accountId) {
        this._subscriptionManager.cancelAccount(accountId);
        this._latencyService.onUnsubscribe(accountId);
        const masterAccountId = this._accountsByReplicaId[accountId];
        if (masterAccountId) {
            if (masterAccountId === accountId) {
                const regionData = this._accountReplicas[masterAccountId];
                const replicas = Object.values(regionData);
                Object.keys(this._synchronizationIdByInstance).filter((instance)=>instance.startsWith(`${masterAccountId}`)).forEach((instance)=>delete this._synchronizationIdByInstance[instance]);
                replicas.forEach((replica)=>{
                    Object.values(this._socketInstancesByAccounts).forEach((instance)=>{
                        delete instance[replica];
                    });
                    delete this._accountsByReplicaId[replica];
                    delete this._regionsByAccounts[replica];
                });
                delete this._accountReplicas[masterAccountId];
            } else {
                Object.values(this._socketInstancesByAccounts).forEach((instance)=>{
                    delete instance[accountId];
                });
                const regionData = this._regionsByAccounts[accountId];
                if (regionData) {
                    const region = regionData.region;
                    Object.keys(this._synchronizationIdByInstance).filter((instance)=>instance.startsWith(`${masterAccountId}:${region}`)).forEach((instance)=>delete this._synchronizationIdByInstance[instance]);
                    delete this._accountReplicas[masterAccountId][region];
                }
                delete this._accountsByReplicaId[accountId];
                delete this._regionsByAccounts[accountId];
            }
        }
    }
    /**
   * Queues an account packet for processing
   * @param {Object} packet packet to process
   */ queuePacket(packet) {
        const accountId = packet.accountId;
        const packets = this._packetOrderer.restoreOrder(packet).filter((p)=>p.type !== 'noop');
        if (this._sequentialEventProcessing && packet.sequenceNumber !== undefined) {
            const events = packets.map((packetItem)=>()=>Promise.resolve(this._processSynchronizationPacket(packetItem)));
            if (!this._eventQueues[accountId]) {
                this._eventQueues[accountId] = events;
                this._callAccountEvents(accountId);
            } else {
                this._eventQueues[accountId] = this._eventQueues[accountId].concat(events);
            }
        } else {
            packets.forEach((packetItem)=>this._processSynchronizationPacket(packetItem));
        }
    }
    /**
   * Queues account event for processing
   * @param {String} accountId account id
   * @param {String} name event label name
   * @param {Function} callable async or regular function to execute
   */ queueEvent(accountId, name, callable) {
        let event = ()=>this._processEvent(callable, `${accountId}:${name}`);
        if (this._sequentialEventProcessing) {
            if (!this._eventQueues[accountId]) {
                this._eventQueues[accountId] = [
                    event
                ];
                this._callAccountEvents(accountId);
            } else {
                this._eventQueues[accountId].push(event);
            }
        } else {
            event();
        }
    }
    _callAccountEvents(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._eventQueues[accountId]) {
                while(_this._eventQueues[accountId].length){
                    yield _this._eventQueues[accountId][0]();
                    _this._eventQueues[accountId].shift();
                }
                delete _this._eventQueues[accountId];
            }
        })();
    }
    _reconnect(instanceNumber, socketInstanceIndex, region) {
        var _this = this;
        return _async_to_generator(function*() {
            const instance = _this.socketInstances[region][instanceNumber][socketInstanceIndex];
            if (instance) {
                while(!instance.socket.connected && !instance.isReconnecting && instance.connected){
                    yield _this._tryReconnect(instanceNumber, socketInstanceIndex, region);
                }
            }
        })();
    }
    _tryReconnect(instanceNumber, socketInstanceIndex, region) {
        const instance = this.socketInstances[region][instanceNumber][socketInstanceIndex];
        instance.reconnectWaitTime = Math.min(instance.reconnectWaitTime * 2, 30000);
        var _this = this;
        return new Promise((resolve)=>setTimeout(/*#__PURE__*/ _async_to_generator(function*() {
                if (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
                    try {
                        instance.sessionId = randomstring.generate(32);
                        const clientId = Math.random();
                        instance.socket.close();
                        instance.socket.io.opts.extraHeaders['Client-Id'] = clientId;
                        instance.socket.io.opts.query.clientId = clientId;
                        instance.isReconnecting = true;
                        instance.socket.io.uri = yield _this._getServerUrl(instanceNumber, socketInstanceIndex, region);
                        instance.socket.connect();
                    } catch (error) {
                        instance.isReconnecting = false;
                    }
                }
                resolve();
            }), instance.reconnectWaitTime));
    }
    /**
   * Simulataneously sends RPC requests to all synchronized instances
   * @param {String} accountId metatrader account id
   * @param {Object} request base request data
   * @param {String} [reliability] account reliability
   * @param {Number} [timeoutInSeconds] request timeout in seconds
   */ rpcRequestAllInstances(accountId, request, reliability, timeoutInSeconds) {
        var _this = this;
        return _async_to_generator(function*() {
            if (reliability === 'high') {
                try {
                    return yield any([
                        0,
                        1
                    ].map((instanceNumber)=>{
                        return _this.rpcRequest(accountId, Object.assign({}, request, {
                            instanceIndex: instanceNumber
                        }), timeoutInSeconds);
                    }));
                } catch (error) {
                    throw error.errors[0];
                }
            } else {
                return yield _this.rpcRequest(accountId, request, timeoutInSeconds);
            }
        })();
    }
    /**
   * Makes a RPC request
   * @param {String} accountId metatrader account id
   * @param {Object} request base request data
   * @param {Number} [timeoutInSeconds] request timeout in seconds
   */ //eslint-disable-next-line complexity, max-statements
    rpcRequest(accountId, request, timeoutInSeconds) {
        var _this = this;
        return _async_to_generator(function*() {
            const ignoredRequestTypes = [
                'subscribe',
                'synchronize',
                'refreshMarketDataSubscriptions',
                'unsubscribe'
            ];
            const primaryAccountId = _this._accountsByReplicaId[accountId];
            let connectedInstance = _this._latencyService.getActiveAccountInstances(primaryAccountId)[0];
            if (!ignoredRequestTypes.includes(request.type)) {
                if (!connectedInstance) {
                    connectedInstance = yield _this._latencyService.waitConnectedInstance(accountId);
                }
                const activeRegion = connectedInstance.split(':')[1];
                accountId = _this._accountReplicas[primaryAccountId][activeRegion];
            }
            let socketInstanceIndex = null;
            let instanceNumber = 0;
            const region = _this.getAccountRegion(accountId);
            _this._refreshAccountRegion(accountId);
            if (request.instanceIndex !== undefined) {
                instanceNumber = request.instanceIndex;
            } else {
                if (connectedInstance) {
                    instanceNumber = Number(connectedInstance.split(':')[2]);
                }
                if (request.application !== 'RPC') {
                    request = Object.assign({}, request, {
                        instanceIndex: instanceNumber
                    });
                }
            }
            if (!_this._socketInstancesByAccounts[instanceNumber]) {
                _this._socketInstancesByAccounts[instanceNumber] = {};
            }
            if (!_this._socketInstances[region]) {
                _this._socketInstances[region] = {};
            }
            if (!_this._socketInstances[region][instanceNumber]) {
                _this._socketInstances[region][instanceNumber] = [];
            }
            if (_this._socketInstancesByAccounts[instanceNumber][accountId] !== undefined) {
                socketInstanceIndex = _this._socketInstancesByAccounts[instanceNumber][accountId];
            } else {
                _this._logger.debug(`${accountId}:${instanceNumber}: creating socket instance on RPC request`);
                yield _this._createSocketInstanceByAccount(accountId, instanceNumber);
                socketInstanceIndex = _this._socketInstancesByAccounts[instanceNumber][accountId];
            }
            const instance = _this._socketInstances[region][instanceNumber][socketInstanceIndex];
            if (!instance.connected) {
                _this._logger.debug(`${accountId}:${instanceNumber}: connecting socket instance on RPC request`);
                yield _this.connect(instanceNumber, region);
            } else if (!_this.connected(instanceNumber, socketInstanceIndex, region)) {
                yield instance.connectResult;
            }
            if (request.type === 'subscribe') {
                request.sessionId = instance.sessionId;
            }
            if ([
                'trade',
                'subscribe'
            ].includes(request.type)) {
                return _this._makeRequest(accountId, instanceNumber, request, timeoutInSeconds);
            }
            let retryCounter = 0;
            while(true){
                try {
                    return yield _this._makeRequest(accountId, instanceNumber, request, timeoutInSeconds);
                } catch (err) {
                    if (err.name === 'TooManyRequestsError') {
                        let calcRetryCounter = retryCounter;
                        let calcRequestTime = 0;
                        while(calcRetryCounter < _this._retries){
                            calcRetryCounter++;
                            calcRequestTime += Math.min(Math.pow(2, calcRetryCounter) * _this._minRetryDelayInSeconds, _this._maxRetryDelayInSeconds) * 1000;
                        }
                        const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
                        if (Date.now() + calcRequestTime > retryTime && retryCounter < _this._retries) {
                            if (Date.now() < retryTime) {
                                yield new Promise((res)=>setTimeout(res, retryTime - Date.now()));
                            }
                            retryCounter++;
                        } else {
                            throw err;
                        }
                    } else if ([
                        'NotSynchronizedError',
                        'TimeoutError',
                        'NotAuthenticatedError',
                        'InternalError'
                    ].includes(err.name) && retryCounter < _this._retries) {
                        yield new Promise((res)=>setTimeout(res, Math.min(Math.pow(2, retryCounter) * _this._minRetryDelayInSeconds, _this._maxRetryDelayInSeconds) * 1000));
                        retryCounter++;
                    } else {
                        throw err;
                    }
                    if (_this._socketInstancesByAccounts[instanceNumber][accountId] === undefined) {
                        throw err;
                    }
                }
            }
        })();
    }
    _makeRequest(accountId, instanceNumber, request, timeoutInSeconds) {
        const socketInstance = this._getSocketInstanceByAccount(accountId, instanceNumber);
        let requestId = request.requestId || randomstring.generate(32);
        request.timestamps = {
            clientProcessingStarted: new Date()
        };
        let result = Promise.race([
            new Promise((resolve, reject)=>socketInstance.requestResolves[requestId] = {
                    resolve,
                    reject,
                    type: request.type
                }),
            new Promise((resolve, reject)=>setTimeout(()=>{
                    reject(new TimeoutError(`MetaApi websocket client request ${request.requestId} of type ${request.type} ` + 'timed out. Please make sure your account is connected to broker before retrying your request.'));
                    delete socketInstance.requestResolves[requestId];
                }, timeoutInSeconds * 1000 || this._requestTimeout))
        ]);
        request.accountId = accountId;
        request.application = request.application || this._application;
        if (!request.requestId) {
            request.requestId = requestId;
        }
        if (request.type === 'unsubscribe' || request.application === 'RPC' || request.instanceIndex === socketInstance.instanceNumber) {
            this._logger.debug(()=>`${accountId}: Sending request: ${JSON.stringify(request)}`);
            socketInstance.socket.emit('request', request);
            return result;
        } else {
            this._logger.trace(()=>`${accountId}:${request.instanceIndex}: skipping request because it is being sent to ` + `the socket of the wrong instance index, request=${JSON.stringify(request)}`);
            return result;
        }
    }
    // eslint-disable-next-line complexity
    _convertError(data) {
        if (data.error === 'ValidationError') {
            return new ValidationError(data.message, data.details);
        } else if (data.error === 'NotFoundError') {
            return new NotFoundError(data.message);
        } else if (data.error === 'NotSynchronizedError') {
            return new NotSynchronizedError(data.message);
        } else if (data.error === 'TimeoutError') {
            return new TimeoutError(data.message);
        } else if (data.error === 'NotAuthenticatedError') {
            return new NotConnectedError(data.message);
        } else if (data.error === 'ForbiddenError') {
            return new ForbiddenError(data.message);
        } else if (data.error === 'TradeError') {
            return new TradeError(data.message, data.numericCode, data.stringCode);
        } else if (data.error === 'UnauthorizedError') {
            this.close();
            return new UnauthorizedError(data.message);
        } else if (data.error === 'TooManyRequestsError') {
            return new TooManyRequestsError(data.message, data.metadata);
        } else {
            return new InternalError(data.message);
        }
    }
    // eslint-disable-next-line complexity
    _convertIsoTimeToDate(packet) {
        // eslint-disable-next-line guard-for-in
        for(let field in packet){
            let value = packet[field];
            if (typeof value === 'string' && field.match(/time$|Time$/) && !field.match(/brokerTime$|BrokerTime$|timeframe$/)) {
                packet[field] = new Date(value);
            }
            if (Array.isArray(value)) {
                for (let item of value){
                    this._convertIsoTimeToDate(item);
                }
            }
            if (typeof value === 'object') {
                this._convertIsoTimeToDate(value);
            }
        }
        if (packet && packet.timestamps) {
            // eslint-disable-next-line guard-for-in
            for(let field in packet.timestamps){
                packet.timestamps[field] = new Date(packet.timestamps[field]);
            }
        }
        if (packet && packet.type === 'prices') {
            for (let price of packet.prices || []){
                if (price.timestamps) {
                    // eslint-disable-next-line guard-for-in
                    for(let field in price.timestamps){
                        price.timestamps[field] = new Date(price.timestamps[field]);
                    }
                }
            }
        }
    }
    /**
   * MetaTrader symbol specification. Contains symbol specification (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolSpecification/)
   * @typedef {Object} MetatraderSymbolSpecification
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} tickSize tick size
   * @property {Number} minVolume minimum order volume for the symbol
   * @property {Number} maxVolume maximum order volume for the symbol
   * @property {Number} volumeStep order volume step for the symbol
   * @property {Array<String>} list of allowed order filling modes. Can contain ORDER_FILLING_FOK, ORDER_FILLING_IOC or
   * both. See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode for more
   * details.
   * @property {String} deal execution mode. Possible values are SYMBOL_TRADE_EXECUTION_REQUEST,
   * SYMBOL_TRADE_EXECUTION_INSTANT, SYMBOL_TRADE_EXECUTION_MARKET, SYMBOL_TRADE_EXECUTION_EXCHANGE. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_execution for more
   * details.
   * @property {Number} contractSize trade contract size
   * @property {MetatraderSessions} quoteSessions quote sessions, indexed by day of week
   * @property {MetatraderSessions} tradeSessions trade sessions, indexed by day of week
   * @property {String} [tradeMode] order execution type. Possible values are SYMBOL_TRADE_MODE_DISABLED,
   * SYMBOL_TRADE_MODE_LONGONLY, SYMBOL_TRADE_MODE_SHORTONLY, SYMBOL_TRADE_MODE_CLOSEONLY, SYMBOL_TRADE_MODE_FULL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_mode for more
   * details
   * @property {Number} [bondAccruedInterest] accrued interest – accumulated coupon interest, i.e. part of the coupon
   * interest calculated in proportion to the number of days since the coupon bond issuance or the last coupon interest
   * payment
   * @property {Number} [bondFaceValue] face value – initial bond value set by the issuer
   * @property {Number} [optionStrike] the strike price of an option. The price at which an option buyer can buy (in a
   * Call option) or sell (in a Put option) the underlying asset, and the option seller is obliged to sell or buy the
   * appropriate amount of the underlying asset.
   * @property {Number} [optionPriceSensivity] option/warrant sensitivity shows by how many points the price of the
   * option's underlying asset should change so that the price of the option changes by one point
   * @property {Number} [liquidityRate] liquidity Rate is the share of the asset that can be used for the margin
   * @property {Number} initialMargin initial margin means the amount in the margin currency required for opening a
   * position with the volume of one lot. It is used for checking a client's assets when he or she enters the market
   * @property {Number} maintenanceMargin the maintenance margin. If it is set, it sets the margin amount in the margin
   * currency of the symbol, charged from one lot. It is used for checking a client's assets when his/her account state
   * changes. If the maintenance margin is equal to 0, the initial margin is used
   * @property {Number} hedgedMargin contract size or margin value per one lot of hedged positions (oppositely directed
   * positions of one symbol). Two margin calculation methods are possible for hedged positions. The calculation method
   * is defined by the broker
   * @property {Boolean} [hedgedMarginUsesLargerLeg] calculating hedging margin using the larger leg (Buy or Sell)
   * @property {String} marginCurrency margin currency
   * @property {String} priceCalculationMode contract price calculation mode. One of SYMBOL_CALC_MODE_UNKNOWN,
   * SYMBOL_CALC_MODE_FOREX, SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE, SYMBOL_CALC_MODE_FUTURES, SYMBOL_CALC_MODE_CFD,
   * SYMBOL_CALC_MODE_CFDINDEX, SYMBOL_CALC_MODE_CFDLEVERAGE, SYMBOL_CALC_MODE_EXCH_STOCKS,
   * SYMBOL_CALC_MODE_EXCH_FUTURES, SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS, SYMBOL_CALC_MODE_EXCH_BONDS,
   * SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX, SYMBOL_CALC_MODE_EXCH_BONDS_MOEX, SYMBOL_CALC_MODE_SERV_COLLATERAL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_calc_mode for more details
   * @property {String} baseCurrency base currency
   * @property {String} [profitCurrency] profit currency
   * @property {String} swapMode swap calculation model. Allowed values are SYMBOL_SWAP_MODE_DISABLED,
   * SYMBOL_SWAP_MODE_POINTS, SYMBOL_SWAP_MODE_CURRENCY_SYMBOL, SYMBOL_SWAP_MODE_CURRENCY_MARGIN,
   * SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT, SYMBOL_SWAP_MODE_INTEREST_CURRENT, SYMBOL_SWAP_MODE_INTEREST_OPEN,
   * SYMBOL_SWAP_MODE_REOPEN_CURRENT, SYMBOL_SWAP_MODE_REOPEN_BID. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_swap_mode for more details
   * @property {Number} [swapLong] long swap value
   * @property {Number} [swapShort] short swap value
   * @property {String} [swapRollover3Days] day of week to charge 3 days swap rollover. Allowed values are SUNDAY,
   * MONDAY, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, NONE
   * @property {Array<String>} allowedExpirationModes allowed order expiration modes. Allowed values are
   * SYMBOL_EXPIRATION_GTC, SYMBOL_EXPIRATION_DAY, SYMBOL_EXPIRATION_SPECIFIED, SYMBOL_EXPIRATION_SPECIFIED_DAY.
   * See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_expiration_mode for more
   * details
   * @property {Array<String>} allowedOrderTypes allowed order types. Allowed values are SYMBOL_ORDER_MARKET,
   * SYMBOL_ORDER_LIMIT, SYMBOL_ORDER_STOP, SYMBOL_ORDER_STOP_LIMIT, SYMBOL_ORDER_SL, SYMBOL_ORDER_TP,
   * SYMBOL_ORDER_CLOSEBY. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_order_mode for more details
   * @property {String} orderGTCMode if the expirationMode property is set to SYMBOL_EXPIRATION_GTC (good till
   * canceled), the expiration of pending orders, as well as of Stop Loss/Take Profit orders should be additionally set
   * using this enumeration. Allowed values are SYMBOL_ORDERS_GTC, SYMBOL_ORDERS_DAILY,
   * SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_order_gtc_mode for more
   * details
   * @property {Number} digits digits after a decimal point
   * @property {Number} point point size
   * @property {String} [path] path in the symbol tree
   * @property {String} description symbol description
   * @property {Date} [startTime] date of the symbol trade beginning (usually used for futures)
   * @property {Date} [expirationTime] date of the symbol trade end (usually used for futures)
   * @property {number} [pipSize] size of a pip. Pip size is defined for spot and CFD symbols only
   * @property {number} stopsLevel minimal distance from the current market price to stop price (SL, TP, open price) in
   * points. The SL, TP, open price can not be placed closer to market price than this distance
   * @property {number} freezeLevel distance in points from market price to pending order open price to freeze updates
   * on the pending order. If the distance between order open price and current market price is less than this value,
   * then you are not allowed to modify the pending order
   */ /**
   * Metatrader trade or quote session container, indexed by weekday
   * @typedef {Object} MetatraderSessions
   * @property {Array<MetatraderSession>} [SUNDAY] array of sessions for SUNDAY
   * @property {Array<MetatraderSession>} [MONDAY] array of sessions for MONDAY
   * @property {Array<MetatraderSession>} [TUESDAY] array of sessions for TUESDAY
   * @property {Array<MetatraderSession>} [WEDNESDAY] array of sessions for WEDNESDAY
   * @property {Array<MetatraderSession>} [THURSDAY] array of sessions for THURSDAY
   * @property {Array<MetatraderSession>} [FRIDAY] array of sessions for FRIDAY
   * @property {Array<MetatraderSession>} [SATURDAY] array of sessions for SATURDAY
   */ /**
   * Metatrader trade or quote session
   * @typedef {Object} MetatraderSession
   * @property {String} from session start time, in hh.mm.ss.SSS format
   * @property {String} to session end time, in hh.mm.ss.SSS format
   */ /**
   * MetaTrader symbol price. Contains current price for a symbol (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolPrice/)
   * @typedef {Object} MetatraderSymbolPrice
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} bid bid price
   * @property {Number} ask ask price
   * @property {Number} profitTickValue tick value for a profitable position
   * @property {Number} lossTickValue tick value for a losing position
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {Date} time quote time, in ISO format
   * @property {String} brokerTime time quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * MetaTrader candle
   * @typedef {Object} MetatraderCandle
   * @property {string} symbol symbol (e.g. currency pair or an index)
   * @property {string} timeframe timeframe candle was generated for, e.g. 1h. One of 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m,
   * 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn
   * @property {Date} time candle opening time
   * @property {string} brokerTime candle opening time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} open open price
   * @property {number} high high price
   * @property {number} low low price
   * @property {number} close close price
   * @property {number} tickVolume tick volume, i.e. number of ticks inside the candle
   * @property {number} spread spread in points
   * @property {number} volume trade volume
   */ /**
   * MetaTrader tick data
   * @typedef {Object} MetatraderTick
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} [bid] bid price
   * @property {number} [ask] ask price
   * @property {number} [last] last deal price
   * @property {number} [volume] volume for the current last deal price
   * @property {string} side is tick a result of buy or sell deal, one of buy or sell
   */ /**
   * MetaTrader order book
   * @typedef {Object} MetatraderBook
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Array<MetatraderBookEntry>} book list of order book entries
   */ /**
   * MetaTrader order book entry
   * @typedef {Object} MetatraderBookEntry
   * @property {string} type entry type, one of BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET,
   * BOOK_TYPE_BUY_MARKET
   * @property {number} price price
   * @property {number} volume volume
   */ // eslint-disable-next-line complexity,max-statements
    _processSynchronizationPacket(data) {
        var _this = this;
        return _async_to_generator(function*() {
            try {
                const instanceNumber = data.instanceIndex || 0;
                const socketInstance = _this._getSocketInstanceByAccount(data.accountId, instanceNumber);
                if (data.synchronizationId && socketInstance) {
                    socketInstance.synchronizationThrottler.updateSynchronizationId(data.synchronizationId);
                }
                const region = _this.getAccountRegion(data.accountId);
                const primaryAccountId = _this._accountsByReplicaId[data.accountId];
                let instanceId = _this._accountsByReplicaId[data.accountId] + ':' + region + ':' + instanceNumber + ':' + (data.host || 0);
                let instanceIndex = region + ':' + instanceNumber + ':' + (data.host || 0);
                const isOnlyActiveInstance = ()=>{
                    const activeInstanceIds = Object.keys(_this._connectedHosts).filter((instance)=>instance.startsWith(primaryAccountId + ':' + region + ':' + instanceNumber));
                    return !activeInstanceIds.length || activeInstanceIds.length === 1 && activeInstanceIds[0] === instanceId;
                };
                const cancelDisconnectTimer = ()=>{
                    if (_this._statusTimers[instanceId]) {
                        clearTimeout(_this._statusTimers[instanceId]);
                    }
                };
                const resetDisconnectTimer = ()=>{
                    cancelDisconnectTimer();
                    _this._statusTimers[instanceId] = setTimeout(()=>{
                        if (isOnlyActiveInstance()) {
                            _this._subscriptionManager.onTimeout(data.accountId, 0);
                            _this._subscriptionManager.onTimeout(data.accountId, 1);
                        }
                        _this.queueEvent(primaryAccountId, `${instanceIndex}:onDisconnected`, ()=>onDisconnected(true));
                        clearTimeout(_this._statusTimers[instanceId]);
                    }, 60000);
                };
                // eslint-disable-next-line complexity
                const onDisconnected = function() {
                    var _ref = _async_to_generator(function*(isTimeout = false) {
                        if (_this._connectedHosts[instanceId]) {
                            _this._latencyService.onDisconnected(instanceId);
                            if (isOnlyActiveInstance()) {
                                for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                                    yield _this._processEvent(()=>listener.onDisconnected(instanceIndex), `${primaryAccountId}:${instanceIndex}:onDisconnected`);
                                }
                            }
                            _this._packetOrderer.onStreamClosed(instanceId);
                            if (socketInstance) {
                                socketInstance.synchronizationThrottler.removeIdByParameters(data.accountId, instanceNumber, data.host);
                            }
                            for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                                yield _this._processEvent(()=>listener.onStreamClosed(instanceIndex), `${primaryAccountId}:${instanceIndex}:onStreamClosed`);
                            }
                            delete _this._connectedHosts[instanceId];
                            if (isOnlyActiveInstance() && !isTimeout) {
                                yield _this._subscriptionManager.onDisconnected(data.accountId, 0);
                                yield _this._subscriptionManager.onDisconnected(data.accountId, 1);
                            }
                        }
                    });
                    return function onDisconnected() {
                        return _ref.apply(this, arguments);
                    };
                }();
                if (data.type === 'authenticated') {
                    resetDisconnectTimer();
                    if (!data.sessionId || socketInstance && data.sessionId === socketInstance.sessionId) {
                        _this._latencyService.onConnected(instanceId);
                        _this._connectedHosts[instanceId] = data.host;
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onConnected(instanceIndex, data.replicas), `${primaryAccountId}:${instanceIndex}:onConnected`);
                        }
                        _this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
                        if (data.replicas === 1) {
                            _this._subscriptionManager.cancelAccount(data.accountId);
                        } else {
                            _this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
                        }
                    }
                } else if (data.type === 'disconnected') {
                    cancelDisconnectTimer();
                    yield onDisconnected();
                } else if (data.type === 'synchronizationStarted') {
                    _this._updateEvents[instanceId] = [];
                    _this._synchronizationFlags[data.synchronizationId] = {
                        accountId: data.accountId,
                        instanceNumber,
                        specificationsUpdated: data.specificationsHashIndex === undefined,
                        positionsUpdated: data.positionsHashIndex === undefined,
                        ordersUpdated: data.ordersHashIndex === undefined
                    };
                    _this._synchronizationIdByInstance[instanceId] = data.synchronizationId;
                    const specificationsHash = data.specificationsHashIndex !== undefined ? _this._synchronizationHashes[data.synchronizationId] && _this._synchronizationHashes[data.synchronizationId].specificationsHashes[data.specificationsHashIndex] : undefined;
                    const positionsHash = data.positionsHashIndex !== undefined ? _this._synchronizationHashes[data.synchronizationId] && _this._synchronizationHashes[data.synchronizationId].positionsHashes[data.positionsHashIndex] : undefined;
                    const ordersHash = data.ordersHashIndex !== undefined ? _this._synchronizationHashes[data.synchronizationId] && _this._synchronizationHashes[data.synchronizationId].ordersHashes[data.ordersHashIndex] : undefined;
                    delete _this._synchronizationHashes[data.synchronizationId];
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onSynchronizationStarted`);
                    }
                } else if (data.type === 'accountInformation') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    if (data.accountInformation) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            try {
                                yield _this._processEvent(()=>listener.onAccountInformationUpdated(instanceIndex, data.accountInformation), `${primaryAccountId}:${instanceIndex}:onAccountInformationUpdated`, true);
                                // eslint-disable-next-line max-depth
                                if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].positionsUpdated) {
                                    yield _this._processEvent(()=>listener.onPositionsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPositionsSynchronized`, true);
                                    // eslint-disable-next-line max-depth
                                    if (!_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                                        yield _this._processEvent(()=>listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                                    }
                                }
                            } catch (err) {
                                _this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about accountInformation event', err);
                            }
                        }
                        if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].positionsUpdated && !_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                            delete _this._synchronizationFlags[data.synchronizationId];
                        }
                    }
                } else if (data.type === 'deals') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let deal of data.deals || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onDealAdded(instanceIndex, deal), `${primaryAccountId}:${instanceIndex}:onDealAdded`);
                        }
                    }
                } else if (data.type === 'orders') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        try {
                            yield _this._processEvent(()=>listener.onPendingOrdersReplaced(instanceIndex, data.orders || []), `${primaryAccountId}:${instanceIndex}:onPendingOrdersReplaced`, true);
                            yield _this._processEvent(()=>listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                        } catch (err) {
                            _this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about orders event', err);
                        }
                    }
                    if (_this._synchronizationFlags[data.synchronizationId]) {
                        delete _this._synchronizationFlags[data.synchronizationId];
                    }
                } else if (data.type === 'historyOrders') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let historyOrder of data.historyOrders || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onHistoryOrderAdded(instanceIndex, historyOrder), `${primaryAccountId}:${instanceIndex}:onHistoryOrderAdded`);
                        }
                    }
                } else if (data.type === 'positions') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        try {
                            yield _this._processEvent(()=>listener.onPositionsReplaced(instanceIndex, data.positions || []), `${primaryAccountId}:${instanceIndex}:onPositionsReplaced`, true);
                            yield _this._processEvent(()=>listener.onPositionsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPositionsSynchronized`, true);
                            if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                                yield _this._processEvent(()=>listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                            }
                        } catch (err) {
                            _this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about positions event', err);
                        }
                    }
                    if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                        delete _this._synchronizationFlags[data.synchronizationId];
                    }
                } else if (data.type === 'update') {
                    if (_this._updateEvents[instanceId]) {
                        _this._updateEvents[instanceId].push(data);
                    }
                    if (data.accountInformation) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onAccountInformationUpdated(instanceIndex, data.accountInformation), `${primaryAccountId}:${instanceIndex}:onAccountInformationUpdated`);
                        }
                    }
                    const updatedPositions = data.updatedPositions || [];
                    const removedPositionIds = data.removedPositionIds || [];
                    if (updatedPositions.length || removedPositionIds.length) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPositionsUpdated(instanceIndex, updatedPositions, removedPositionIds), `${primaryAccountId}:${instanceIndex}:onPositionsUpdated`);
                        }
                    }
                    for (let position of updatedPositions){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPositionUpdated(instanceIndex, position), `${primaryAccountId}:${instanceIndex}:onPositionUpdated`);
                        }
                    }
                    for (let positionId of removedPositionIds){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPositionRemoved(instanceIndex, positionId), `${primaryAccountId}:${instanceIndex}:onPositionRemoved`);
                        }
                    }
                    const updatedOrders = data.updatedOrders || [];
                    const completedOrderIds = data.completedOrderIds || [];
                    if (updatedOrders.length || completedOrderIds.length) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPendingOrdersUpdated(instanceIndex, updatedOrders, completedOrderIds), `${primaryAccountId}:${instanceIndex}:onPendingOrdersUpdated`);
                        }
                    }
                    for (let order of updatedOrders){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPendingOrderUpdated(instanceIndex, order), `${primaryAccountId}:${instanceIndex}:onPendingOrderUpdated`);
                        }
                    }
                    for (let orderId of completedOrderIds){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPendingOrderCompleted(instanceIndex, orderId), `${primaryAccountId}:${instanceIndex}:onPendingOrderCompleted`);
                        }
                    }
                    for (let historyOrder of data.historyOrders || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onHistoryOrderAdded(instanceIndex, historyOrder), `${primaryAccountId}:${instanceIndex}:onHistoryOrderAdded`);
                        }
                    }
                    for (let deal of data.deals || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onDealAdded(instanceIndex, deal), `${primaryAccountId}:${instanceIndex}:onDealAdded`);
                        }
                    }
                    if (data.timestamps) {
                        data.timestamps.clientProcessingFinished = new Date();
                        // eslint-disable-next-line max-depth
                        for (let listener of _this._latencyListeners || []){
                            yield _this._processEvent(()=>listener.onUpdate(data.accountId, data.timestamps), `${primaryAccountId}:${instanceIndex}:onUpdate`);
                        }
                    }
                } else if (data.type === 'dealSynchronizationFinished') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        delete _this._synchronizationIdByInstance[instanceId];
                        return;
                    }
                    _this._latencyService.onDealsSynchronized(instanceId);
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        if (socketInstance) {
                            socketInstance.synchronizationThrottler.removeSynchronizationId(data.synchronizationId);
                        }
                        yield _this._processEvent(()=>listener.onDealsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onDealsSynchronized`);
                    }
                    if (_this._updateEvents[instanceId]) {
                        _this._updateEvents[instanceId] = _this._updateEvents[instanceId].map((packet)=>()=>Promise.resolve(_this._processSynchronizationPacket(packet)));
                        if (_this._eventQueues[primaryAccountId]) {
                            _this._eventQueues[primaryAccountId] = _this._updateEvents[instanceId].concat(_this._eventQueues[primaryAccountId]);
                            delete _this._updateEvents[instanceId];
                        } else {
                            _this._eventQueues[primaryAccountId] = _this._updateEvents[instanceId];
                            delete _this._updateEvents[instanceId];
                            _this._callAccountEvents(primaryAccountId);
                        }
                    }
                } else if (data.type === 'orderSynchronizationFinished') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onHistoryOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onHistoryOrdersSynchronized`);
                    }
                } else if (data.type === 'status') {
                    if (!_this._connectedHosts[instanceId]) {
                        if (_this._statusTimers[instanceId] && data.authenticated && (_this._subscriptionManager.isDisconnectedRetryMode(data.accountId, instanceNumber) || !_this._subscriptionManager.isAccountSubscribing(data.accountId, instanceNumber))) {
                            _this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
                            yield new Promise((res)=>setTimeout(res, 10));
                            // eslint-disable-next-line no-console
                            _this._logger.info('it seems like we are not connected to a running API ' + 'server yet, retrying subscription for account ' + instanceId);
                            _this.ensureSubscribe(data.accountId, instanceNumber);
                        }
                    } else {
                        resetDisconnectTimer();
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onBrokerConnectionStatusChanged(instanceIndex, !!data.connected), `${primaryAccountId}:${instanceIndex}:onBrokerConnectionStatusChanged`);
                        }
                        if (data.healthStatus) {
                            // eslint-disable-next-line max-depth
                            for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                                yield _this._processEvent(()=>listener.onHealthStatus(instanceIndex, data.healthStatus), `${primaryAccountId}:${instanceIndex}:onHealthStatus`);
                            }
                        }
                    }
                } else if (data.type === 'downgradeSubscription') {
                    _this._logger.info(`${primaryAccountId}:${instanceIndex}: Market data subscriptions for symbol ` + `${data.symbol} were downgraded by the server due to rate limits. Updated subscriptions: ` + `${JSON.stringify(data.updates)}, removed subscriptions: ${JSON.stringify(data.unsubscriptions)}. ` + 'Please read https://metaapi.cloud/docs/client/rateLimiting/ for more details.');
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onSubscriptionDowngraded(instanceIndex, data.symbol, data.updates, data.unsubscriptions), `${primaryAccountId}:${instanceIndex}:onSubscriptionDowngraded`);
                    }
                } else if (data.type === 'specifications') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onSymbolSpecificationsUpdated(instanceIndex, data.specifications || [], data.removedSymbols || []), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationsUpdated`);
                    }
                    for (let specification of data.specifications || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onSymbolSpecificationUpdated(instanceIndex, specification), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationUpdated`);
                        }
                    }
                    for (let removedSymbol of data.removedSymbols || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onSymbolSpecificationRemoved(instanceIndex, removedSymbol), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationRemoved`);
                        }
                    }
                } else if (data.type === 'prices') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    let prices = data.prices || [];
                    let candles = data.candles || [];
                    let ticks = data.ticks || [];
                    let books = data.books || [];
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        if (prices.length) {
                            yield _this._processEvent(()=>listener.onSymbolPricesUpdated(instanceIndex, prices, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onSymbolPricesUpdated`);
                        }
                        if (candles.length) {
                            yield _this._processEvent(()=>listener.onCandlesUpdated(instanceIndex, candles, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onCandlesUpdated`);
                        }
                        if (ticks.length) {
                            yield _this._processEvent(()=>listener.onTicksUpdated(instanceIndex, ticks, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onTicksUpdated`);
                        }
                        if (books.length) {
                            yield _this._processEvent(()=>listener.onBooksUpdated(instanceIndex, books, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onBooksUpdated`);
                        }
                    }
                    for (let price of prices){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onSymbolPriceUpdated(instanceIndex, price), `${primaryAccountId}:${instanceIndex}:onSymbolPriceUpdated`);
                        }
                    }
                    for (let price of prices){
                        if (price.timestamps) {
                            price.timestamps.clientProcessingFinished = new Date();
                            // eslint-disable-next-line max-depth
                            for (let listener of _this._latencyListeners || []){
                                yield _this._processEvent(()=>listener.onSymbolPrice(data.accountId, price.symbol, price.timestamps), `${primaryAccountId}:${instanceIndex}:onSymbolPrice`);
                            }
                        }
                    }
                }
            } catch (err) {
                _this._logger.error('Failed to process incoming synchronization packet', err);
            }
        })();
    }
    _processEvent(callable, label, throwError) {
        var _this = this;
        return _async_to_generator(function*() {
            const startTime = Date.now();
            let isLongEvent = false;
            let isEventDone = false;
            const checkLongEvent = function() {
                var _ref = _async_to_generator(function*() {
                    yield new Promise((res)=>setTimeout(res, 1000));
                    if (!isEventDone) {
                        isLongEvent = true;
                        _this._logger.warn(`${label}: event is taking more than 1 second to process`);
                    }
                });
                return function checkLongEvent() {
                    return _ref.apply(this, arguments);
                };
            }();
            checkLongEvent();
            try {
                yield callable();
            } catch (err) {
                if (throwError) {
                    throw err;
                }
                _this._logger.error(`${label}: event failed with error`, err);
            }
            isEventDone = true;
            if (isLongEvent) {
                _this._logger.warn(`${label}: finished in ${Math.floor((Date.now() - startTime) / 1000)} seconds`);
            }
        })();
    }
    _fireReconnected(instanceNumber, socketInstanceIndex, region) {
        var _this = this;
        return _async_to_generator(function*() {
            try {
                const reconnectListeners = [];
                for (let listener of _this._reconnectListeners){
                    if (_this._socketInstancesByAccounts[instanceNumber][listener.accountId] === socketInstanceIndex && _this.getAccountRegion(listener.accountId) === region) {
                        reconnectListeners.push(listener);
                    }
                }
                Object.keys(_this._synchronizationFlags).forEach((synchronizationId)=>{
                    const accountId = _this._synchronizationFlags[synchronizationId].accountId;
                    if (_this._socketInstancesByAccounts[instanceNumber][accountId] === socketInstanceIndex && _this._synchronizationFlags[synchronizationId].instanceNumber === instanceNumber && _this._regionsByAccounts[accountId] && _this._regionsByAccounts[accountId].region === region) {
                        delete _this._synchronizationFlags[synchronizationId];
                    }
                });
                const reconnectAccountIds = reconnectListeners.map((listener)=>listener.accountId);
                _this._subscriptionManager.onReconnected(instanceNumber, socketInstanceIndex, reconnectAccountIds);
                _this._packetOrderer.onReconnected(reconnectAccountIds);
                for (let listener of reconnectListeners){
                    Promise.resolve(listener.listener.onReconnected(region, instanceNumber)).catch((err)=>_this._logger.error('Failed to notify reconnect listener', err));
                }
            } catch (err) {
                _this._logger.error('Failed to process reconnected event', err);
            }
        })();
    }
    _getSocketInstanceByAccount(accountId, instanceNumber) {
        const region = this.getAccountRegion(accountId);
        return this._socketInstances[region][instanceNumber][this._socketInstancesByAccounts[instanceNumber][accountId]];
    }
    getUrlSettings(instanceNumber, region) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._url) {
                return {
                    url: _this._url,
                    isSharedClientApi: true
                };
            }
            const urlSettings = yield _this._domainClient.getSettings();
            const getUrl = (hostname)=>`https://${hostname}.${region}-${String.fromCharCode(97 + Number(instanceNumber))}.${urlSettings.domain}`;
            let url;
            if (_this._useSharedClientApi) {
                url = getUrl(_this._hostname);
            } else {
                url = getUrl(urlSettings.hostname);
            }
            const isSharedClientApi = url === getUrl(_this._hostname);
            return {
                url,
                isSharedClientApi
            };
        })();
    }
    // eslint-disable-next-line complexity
    _getServerUrl(instanceNumber, socketInstanceIndex, region) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._url) {
                return _this._url;
            }
            while(_this.socketInstances[region][instanceNumber][socketInstanceIndex].connected){
                try {
                    const urlSettings = yield _this.getUrlSettings(instanceNumber, region);
                    const url = urlSettings.url;
                    const isSharedClientApi = urlSettings.isSharedClientApi;
                    let logMessage = 'Connecting MetaApi websocket client to the MetaApi server ' + `via ${url} ${isSharedClientApi ? 'shared' : 'dedicated'} server.`;
                    if (_this._firstConnect && !isSharedClientApi) {
                        logMessage += ' Please note that it can take up to 3 minutes for your dedicated server to start for the ' + 'first time. During this time it is OK if you see some connection errors.';
                        _this._firstConnect = false;
                    }
                    _this._logger.info(logMessage);
                    return url;
                } catch (err) {
                    _this._logger.error('Failed to retrieve server URL', err);
                    yield new Promise((res)=>setTimeout(res, 1000));
                }
            }
        })();
    }
    _throttleRequest(type, accountId, instanceNumber, timeInMs) {
        this._lastRequestsTime[instanceNumber] = this._lastRequestsTime[instanceNumber] || {};
        this._lastRequestsTime[instanceNumber][type] = this._lastRequestsTime[instanceNumber][type] || {};
        let lastTime = this._lastRequestsTime[instanceNumber][type][accountId];
        if (!lastTime || lastTime < Date.now() - timeInMs) {
            this._lastRequestsTime[instanceNumber][type][accountId] = Date.now();
            return !!lastTime;
        }
        return false;
    }
    _refreshAccountRegion(accountId) {
        if (this._regionsByAccounts[accountId]) {
            this._regionsByAccounts[accountId].lastUsed = Date.now();
        }
    }
    //eslint-disable-next-line complexity
    _createSocketInstanceByAccount(accountId, instanceNumber) {
        var _this = this;
        return _async_to_generator(function*() {
            const region = _this.getAccountRegion(accountId);
            if (_this._socketInstancesByAccounts[instanceNumber][accountId] === undefined) {
                let socketInstanceIndex = null;
                while(_this._subscribeLock && (new Date(_this._subscribeLock.recommendedRetryTime).getTime() > Date.now() && _this.subscribedAccountIds(instanceNumber, undefined, region).length < _this._subscribeLock.lockedAtAccounts || new Date(_this._subscribeLock.lockedAtTime).getTime() + _this._subscribeCooldownInSeconds * 1000 > Date.now() && _this.subscribedAccountIds(instanceNumber, undefined, region).length >= _this._subscribeLock.lockedAtAccounts)){
                    yield new Promise((res)=>setTimeout(res, 1000));
                }
                for(let index = 0; index < _this._socketInstances[region][instanceNumber].length; index++){
                    const accountCounter = _this.getAssignedAccounts(instanceNumber, index, region).length;
                    const instance = _this.socketInstances[region][instanceNumber][index];
                    if (instance.subscribeLock) {
                        if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER' && (new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() || _this.subscribedAccountIds(instanceNumber, index, region).length >= instance.subscribeLock.lockedAtAccounts)) {
                            continue;
                        }
                        if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER' && new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() && _this.subscribedAccountIds(instanceNumber, index, region).length >= instance.subscribeLock.lockedAtAccounts) {
                            continue;
                        }
                    }
                    if (accountCounter < _this._maxAccountsPerInstance) {
                        socketInstanceIndex = index;
                        break;
                    }
                }
                if (socketInstanceIndex === null) {
                    socketInstanceIndex = _this._socketInstances[region][instanceNumber].length;
                    yield _this.connect(instanceNumber, region);
                }
                _this._socketInstancesByAccounts[instanceNumber][accountId] = socketInstanceIndex;
            }
        })();
    }
    _clearAccountCacheJob() {
        const date = Date.now();
        Object.keys(this._regionsByAccounts).forEach((replicaId)=>{
            const data = this._regionsByAccounts[replicaId];
            if (data && data.connections === 0 && date - data.lastUsed > 2 * 60 * 60 * 1000) {
                const primaryAccountId = this._accountsByReplicaId[replicaId];
                const replicas = Object.values(this._accountReplicas[primaryAccountId] || {});
                replicas.forEach((replica)=>{
                    delete this._accountsByReplicaId[replica];
                    delete this._regionsByAccounts[replica];
                });
                delete this._accountReplicas[primaryAccountId];
            }
        });
    }
    _clearInactiveSyncDataJob() {
        const date = Date.now();
        Object.keys(this._synchronizationHashes).keys((synchronizationId)=>{
            if (this._synchronizationHashes[synchronizationId].lastUpdated < date - 30 * 60 * 1000) {
                delete this._synchronizationHashes[synchronizationId];
            }
        });
    }
    /**
   * @typedef MetaApiWebsocketClientOptions MetaApi websocket client options
   * @property {Boolean} [disableInternalJobs] Whether to not run internal interval jobs. Used for tests only
   */ /**
   * Constructs MetaApi websocket API client instance
   * @param {MetaApi} metaApi metaApi instance
   * @param {DomainClient} domainClient domain client
   * @param {String} token authorization token
   * @param {MetaApiWebsocketClientOptions} opts websocket client options
   */ // eslint-disable-next-line complexity,max-statements
    constructor(metaApi, domainClient, token, opts){
        const validator = new OptionsValidator();
        opts = opts || {};
        opts.packetOrderingTimeout = validator.validateNonZero(opts.packetOrderingTimeout, 60, 'packetOrderingTimeout');
        opts.synchronizationThrottler = opts.synchronizationThrottler || {};
        this._domainClient = domainClient;
        this._application = opts.application || 'MetaApi';
        this._domain = opts.domain || 'agiliumtrade.agiliumtrade.ai';
        this._region = opts.region;
        this._hostname = 'mt-client-api-v1';
        this._metaApi = metaApi;
        this._url = null;
        this._requestTimeout = validator.validateNonZero(opts.requestTimeout, 60, 'requestTimeout') * 1000;
        this._connectTimeout = validator.validateNonZero(opts.connectTimeout, 60, 'connectTimeout') * 1000;
        const retryOpts = opts.retryOpts || {};
        this._retries = validator.validateNumber(retryOpts.retries, 5, 'retryOpts.retries');
        this._minRetryDelayInSeconds = validator.validateNonZero(retryOpts.minDelayInSeconds, 1, 'retryOpts.minDelayInSeconds');
        this._maxRetryDelayInSeconds = validator.validateNonZero(retryOpts.maxDelayInSeconds, 30, 'retryOpts.maxDelayInSeconds');
        this._maxAccountsPerInstance = 100;
        this._subscribeCooldownInSeconds = validator.validateNonZero(retryOpts.subscribeCooldownInSeconds, 600, 'retryOpts.subscribeCooldownInSeconds');
        this._sequentialEventProcessing = true;
        this._useSharedClientApi = validator.validateBoolean(opts.useSharedClientApi, false, 'useSharedClientApi');
        this._unsubscribeThrottlingInterval = validator.validateNonZero(opts.unsubscribeThrottlingIntervalInSeconds, 10, 'unsubscribeThrottlingIntervalInSeconds') * 1000;
        this._socketMinimumReconnectTimeout = 500;
        this._latencyService = new LatencyService(this, token, this._connectTimeout);
        this._token = token;
        this._synchronizationListeners = {};
        this._latencyListeners = [];
        this._reconnectListeners = [];
        this._connectedHosts = {};
        this._socketInstances = {};
        this._socketInstancesByAccounts = {};
        this._regionsByAccounts = {};
        this._accountsByReplicaId = {};
        this._accountReplicas = {};
        this._synchronizationThrottlerOpts = opts.synchronizationThrottler;
        this._subscriptionManager = new SubscriptionManager(this, metaApi);
        this._statusTimers = {};
        this._eventQueues = {};
        this._synchronizationFlags = {};
        this._synchronizationIdByInstance = {};
        this._subscribeLock = null;
        this._firstConnect = true;
        this._lastRequestsTime = {};
        this._packetOrderer = new PacketOrderer(this, opts.packetOrderingTimeout);
        this._packetOrderer.start();
        this._synchronizationHashes = {};
        this._updateEvents = {};
        if (opts.packetLogger && opts.packetLogger.enabled) {
            this._packetLogger = new PacketLogger(opts.packetLogger);
            this._packetLogger.start();
        }
        this._logger = LoggerManager.getLogger('MetaApiWebsocketClient');
        if (!opts.disableInternalJobs) {
            this._clearAccountCacheInterval = setInterval(this._clearAccountCacheJob.bind(this), 30 * 60 * 1000);
            this._clearInactiveSyncDataJob = setInterval(this._clearInactiveSyncDataJob.bind(this), 5 * 60 * 1000);
        }
    }
};
/**
 * MetaApi websocket API client (see https://metaapi.cloud/docs/client/websocket/overview/)
 */ export { MetaApiWebsocketClient as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBzb2NrZXRJTyBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vdGltZW91dEVycm9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yLCBOb3RGb3VuZEVycm9yLCBJbnRlcm5hbEVycm9yLCBVbmF1dGhvcml6ZWRFcnJvciwgVG9vTWFueVJlcXVlc3RzRXJyb3IsIEZvcmJpZGRlbkVycm9yfVxuICBmcm9tICcuLi9lcnJvckhhbmRsZXInO1xuaW1wb3J0IE9wdGlvbnNWYWxpZGF0b3IgZnJvbSAnLi4vb3B0aW9uc1ZhbGlkYXRvcic7XG5pbXBvcnQgTm90U3luY2hyb25pemVkRXJyb3IgZnJvbSAnLi9ub3RTeW5jaHJvbml6ZWRFcnJvcic7XG5pbXBvcnQgTm90Q29ubmVjdGVkRXJyb3IgZnJvbSAnLi9ub3RDb25uZWN0ZWRFcnJvcic7XG5pbXBvcnQgVHJhZGVFcnJvciBmcm9tICcuL3RyYWRlRXJyb3InO1xuaW1wb3J0IFBhY2tldE9yZGVyZXIgZnJvbSAnLi9wYWNrZXRPcmRlcmVyJztcbmltcG9ydCBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgZnJvbSAnLi9zeW5jaHJvbml6YXRpb25UaHJvdHRsZXInO1xuaW1wb3J0IFN1YnNjcmlwdGlvbk1hbmFnZXIgZnJvbSAnLi9zdWJzY3JpcHRpb25NYW5hZ2VyJztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgYW55IGZyb20gJ3Byb21pc2UuYW55JztcbmltcG9ydCBMYXRlbmN5U2VydmljZSBmcm9tICcuL2xhdGVuY3lTZXJ2aWNlJztcblxubGV0IFBhY2tldExvZ2dlcjtcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyAvLyBkb24ndCBpbXBvcnQgUGFja2V0TG9nZ2VyIGZvciBicm93c2VyIHZlcnNpb25cbiAgUGFja2V0TG9nZ2VyID0gcmVxdWlyZSgnLi9wYWNrZXRMb2dnZXInKS5kZWZhdWx0O1xufVxuXG4vKipcbiAqIE1ldGFBcGkgd2Vic29ja2V0IEFQSSBjbGllbnQgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L292ZXJ2aWV3LylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YUFwaVdlYnNvY2tldENsaWVudCB7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIE1ldGFBcGlXZWJzb2NrZXRDbGllbnRPcHRpb25zIE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBvcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Rpc2FibGVJbnRlcm5hbEpvYnNdIFdoZXRoZXIgdG8gbm90IHJ1biBpbnRlcm5hbCBpbnRlcnZhbCBqb2JzLiBVc2VkIGZvciB0ZXN0cyBvbmx5XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgd2Vic29ja2V0IEFQSSBjbGllbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtNZXRhQXBpfSBtZXRhQXBpIG1ldGFBcGkgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtEb21haW5DbGllbnR9IGRvbWFpbkNsaWVudCBkb21haW4gY2xpZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBhdXRob3JpemF0aW9uIHRva2VuXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudE9wdGlvbnN9IG9wdHMgd2Vic29ja2V0IGNsaWVudCBvcHRpb25zXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSxtYXgtc3RhdGVtZW50c1xuICBjb25zdHJ1Y3RvcihtZXRhQXBpLCBkb21haW5DbGllbnQsIHRva2VuLCBvcHRzKSB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IE9wdGlvbnNWYWxpZGF0b3IoKTtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBvcHRzLnBhY2tldE9yZGVyaW5nVGltZW91dCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5wYWNrZXRPcmRlcmluZ1RpbWVvdXQsIDYwLCAncGFja2V0T3JkZXJpbmdUaW1lb3V0Jyk7XG4gICAgb3B0cy5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgPSBvcHRzLnN5bmNocm9uaXphdGlvblRocm90dGxlciB8fCB7fTtcbiAgICB0aGlzLl9kb21haW5DbGllbnQgPSBkb21haW5DbGllbnQ7XG4gICAgdGhpcy5fYXBwbGljYXRpb24gPSBvcHRzLmFwcGxpY2F0aW9uIHx8ICdNZXRhQXBpJztcbiAgICB0aGlzLl9kb21haW4gPSBvcHRzLmRvbWFpbiB8fCAnYWdpbGl1bXRyYWRlLmFnaWxpdW10cmFkZS5haSc7XG4gICAgdGhpcy5fcmVnaW9uID0gb3B0cy5yZWdpb247XG4gICAgdGhpcy5faG9zdG5hbWUgPSAnbXQtY2xpZW50LWFwaS12MSc7XG4gICAgdGhpcy5fbWV0YUFwaSA9IG1ldGFBcGk7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0VGltZW91dCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5yZXF1ZXN0VGltZW91dCwgNjAsICdyZXF1ZXN0VGltZW91dCcpICogMTAwMDtcbiAgICB0aGlzLl9jb25uZWN0VGltZW91dCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy5jb25uZWN0VGltZW91dCwgNjAsICdjb25uZWN0VGltZW91dCcpICogMTAwMDtcbiAgICBjb25zdCByZXRyeU9wdHMgPSBvcHRzLnJldHJ5T3B0cyB8fCB7fTtcbiAgICB0aGlzLl9yZXRyaWVzID0gdmFsaWRhdG9yLnZhbGlkYXRlTnVtYmVyKHJldHJ5T3B0cy5yZXRyaWVzLCA1LCAncmV0cnlPcHRzLnJldHJpZXMnKTtcbiAgICB0aGlzLl9taW5SZXRyeURlbGF5SW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZXRyeU9wdHMubWluRGVsYXlJblNlY29uZHMsIDEsXG4gICAgICAncmV0cnlPcHRzLm1pbkRlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4UmV0cnlEZWxheUluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmV0cnlPcHRzLm1heERlbGF5SW5TZWNvbmRzLCAzMCxcbiAgICAgICdyZXRyeU9wdHMubWF4RGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9tYXhBY2NvdW50c1Blckluc3RhbmNlID0gMTAwO1xuICAgIHRoaXMuX3N1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZXRyeU9wdHMuc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMsIDYwMCwgXG4gICAgICAncmV0cnlPcHRzLnN1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyA9IHRydWU7XG4gICAgdGhpcy5fdXNlU2hhcmVkQ2xpZW50QXBpID0gdmFsaWRhdG9yLnZhbGlkYXRlQm9vbGVhbihvcHRzLnVzZVNoYXJlZENsaWVudEFwaSwgZmFsc2UsICd1c2VTaGFyZWRDbGllbnRBcGknKTtcbiAgICB0aGlzLl91bnN1YnNjcmliZVRocm90dGxpbmdJbnRlcnZhbCA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ob3B0cy51bnN1YnNjcmliZVRocm90dGxpbmdJbnRlcnZhbEluU2Vjb25kcywgMTAsXG4gICAgICAndW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWxJblNlY29uZHMnKSAqIDEwMDA7XG4gICAgdGhpcy5fc29ja2V0TWluaW11bVJlY29ubmVjdFRpbWVvdXQgPSA1MDA7XG4gICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2UgPSBuZXcgTGF0ZW5jeVNlcnZpY2UodGhpcywgdG9rZW4sIHRoaXMuX2Nvbm5lY3RUaW1lb3V0KTtcbiAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWNvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9jb25uZWN0ZWRIb3N0cyA9IHt9O1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlcyA9IHt9O1xuICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHMgPSB7fTtcbiAgICB0aGlzLl9yZWdpb25zQnlBY2NvdW50cyA9IHt9O1xuICAgIHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWQgPSB7fTtcbiAgICB0aGlzLl9hY2NvdW50UmVwbGljYXMgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzID0gb3B0cy5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXI7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlciA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMsIG1ldGFBcGkpO1xuICAgIHRoaXMuX3N0YXR1c1RpbWVycyA9IHt9O1xuICAgIHRoaXMuX2V2ZW50UXVldWVzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3MgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2UgPSB7fTtcbiAgICB0aGlzLl9zdWJzY3JpYmVMb2NrID0gbnVsbDtcbiAgICB0aGlzLl9maXJzdENvbm5lY3QgPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0c1RpbWUgPSB7fTtcbiAgICB0aGlzLl9wYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldE9yZGVyZXIodGhpcywgb3B0cy5wYWNrZXRPcmRlcmluZ1RpbWVvdXQpO1xuICAgIHRoaXMuX3BhY2tldE9yZGVyZXIuc3RhcnQoKTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXMgPSB7fTtcbiAgICB0aGlzLl91cGRhdGVFdmVudHMgPSB7fTtcbiAgICBpZihvcHRzLnBhY2tldExvZ2dlciAmJiBvcHRzLnBhY2tldExvZ2dlci5lbmFibGVkKSB7XG4gICAgICB0aGlzLl9wYWNrZXRMb2dnZXIgPSBuZXcgUGFja2V0TG9nZ2VyKG9wdHMucGFja2V0TG9nZ2VyKTtcbiAgICAgIHRoaXMuX3BhY2tldExvZ2dlci5zdGFydCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignTWV0YUFwaVdlYnNvY2tldENsaWVudCcpO1xuICAgIGlmICghb3B0cy5kaXNhYmxlSW50ZXJuYWxKb2JzKSB7XG4gICAgICB0aGlzLl9jbGVhckFjY291bnRDYWNoZUludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fY2xlYXJBY2NvdW50Q2FjaGVKb2IuYmluZCh0aGlzKSwgMzAgKiA2MCAqIDEwMDApO1xuICAgICAgdGhpcy5fY2xlYXJJbmFjdGl2ZVN5bmNEYXRhSm9iID0gc2V0SW50ZXJ2YWwodGhpcy5fY2xlYXJJbmFjdGl2ZVN5bmNEYXRhSm9iLmJpbmQodGhpcyksIDUgKiA2MCAqIDEwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0YXJ0cyB0aGUgYWNjb3VudCBzeW5jaHJvbml6YXRpb24gcHJvY2VzcyBvbiBhbiBvdXQgb2Ygb3JkZXIgcGFja2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciBleHBlY3RlZCBzL25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFNlcXVlbmNlTnVtYmVyIGFjdHVhbCBzL25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBwYWNrZXQgZGF0YVxuICAgKiBAcGFyYW0ge0RhdGV9IHJlY2VpdmVkQXQgdGltZSB0aGUgcGFja2V0IHdhcyByZWNlaXZlZCBhdFxuICAgKi9cbiAgb25PdXRPZk9yZGVyUGFja2V0KGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCwgZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciwgYWN0dWFsU2VxdWVuY2VOdW1iZXIsIHBhY2tldCwgcmVjZWl2ZWRBdCkge1xuICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmlzU3Vic2NyaXB0aW9uQWN0aXZlKGFjY291bnRJZCkpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlY2VpdmVkIGFuIG91dCBvZiBvcmRlciAnICtcbiAgICAgICAgYHBhY2tldCB0eXBlICR7cGFja2V0LnR5cGV9IGZvciBhY2NvdW50IGlkICR7YWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9LiBFeHBlY3RlZCBzL24gYCArXG4gICAgICAgIGAke2V4cGVjdGVkU2VxdWVuY2VOdW1iZXJ9IGRvZXMgbm90IG1hdGNoIHRoZSBhY3R1YWwgb2YgJHthY3R1YWxTZXF1ZW5jZU51bWJlcn1gKTtcbiAgICAgIHRoaXMuZW5zdXJlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhdGNoIHNlcnZlciBVUkwgZm9yIHVzZSBpbiB1bml0IHRlc3RzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgcGF0Y2hlZCBzZXJ2ZXIgVVJMXG4gICAqL1xuICBzZXQgdXJsKHVybCkge1xuICAgIHRoaXMuX3VybCA9IHVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZWJzb2NrZXQgY2xpZW50IHByZWRlZmluZWQgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWRlZmluZWQgcmVnaW9uXG4gICAqL1xuICBnZXQgcmVnaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBzb2NrZXQgaW5zdGFuY2UgZGljdGlvbmFyaWVzXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBsaXN0IG9mIHNvY2tldCBpbnN0YW5jZSBkaWN0aW9uYXJpZXNcbiAgICovXG4gIGdldCBzb2NrZXRJbnN0YW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEluc3RhbmNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWN0aW9uYXJ5IG9mIHNvY2tldCBpbnN0YW5jZXMgYnkgYWNjb3VudCBpZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSBkaWN0aW9uYXJ5IG9mIHNvY2tldCBpbnN0YW5jZXMgYnkgYWNjb3VudCBpZHNcbiAgICovXG4gIGdldCBzb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpY3Rpb25hcnkgb2YgYWNjb3VudCByZXBsaWNhcyBieSByZWdpb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBkaWN0aW9uYXJ5IG9mIGFjY291bnQgcmVwbGljYXMgYnkgcmVnaW9uXG4gICAqL1xuICBnZXQgYWNjb3VudFJlcGxpY2FzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50UmVwbGljYXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGljdGlvbmFyeSBvZiBwcmltYXJ5IGFjY291bnQgaWRzIGJ5IHJlcGxpY2EgaWRzXG4gICAqIEByZXR1cm4ge09iamVjdH0gZGljdGlvbmFyeSBvZiBwcmltYXJ5IGFjY291bnQgaWRzIGJ5IHJlcGxpY2EgaWRzXG4gICAqL1xuICBnZXQgYWNjb3VudHNCeVJlcGxpY2FJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNsZWFyIGFjY291bnQgY2FjaGUgam9iLiBVc2VkIGZvciB0ZXN0c1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gY2xlYXIgYWNjb3VudCBjYWNoZSBqb2JcbiAgICovXG4gIGdldCBjbGVhckFjY291bnRDYWNoZUpvYigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xlYXJBY2NvdW50Q2FjaGVKb2IuYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN1YnNjcmliZWQgYWNjb3VudCBpZHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIHN1YnNjcmliZWQgYWNjb3VudCBpZHNcbiAgICovXG4gIHN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pIHtcbiAgICBjb25zdCBjb25uZWN0ZWRJZHMgPSBbXTtcbiAgICBpZih0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fY29ubmVjdGVkSG9zdHMpLmZvckVhY2goaW5zdGFuY2VJZCA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IGluc3RhbmNlSWQuc3BsaXQoJzonKVswXTtcbiAgICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgICAgICBpZighY29ubmVjdGVkSWRzLmluY2x1ZGVzKGFjY291bnRJZCkgJiYgXG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCAmJiAoXG4gICAgICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleCB8fCBcbiAgICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gdW5kZWZpbmVkKSAmJiBhY2NvdW50UmVnaW9uID09PSByZWdpb24pIHtcbiAgICAgICAgICBjb25uZWN0ZWRJZHMucHVzaChhY2NvdW50SWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3RlZElkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiBzdGF0dXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAqL1xuICBjb25uZWN0ZWQoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl0gJiYgXG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0ubGVuZ3RoID4gc29ja2V0SW5zdGFuY2VJbmRleCA/IFxuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdIDogbnVsbDtcbiAgICByZXR1cm4gKGluc3RhbmNlICYmIGluc3RhbmNlLnNvY2tldCAmJiBpbnN0YW5jZS5zb2NrZXQuY29ubmVjdGVkKSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgYWNjb3VudHMgYXNzaWduZWQgdG8gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm5zIFxuICAgKi9cbiAgZ2V0QXNzaWduZWRBY2NvdW50cyhpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgY29uc3QgYWNjb3VudElkcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBhY2NvdW50UmVnaW9uID0gdGhpcy5nZXRBY2NvdW50UmVnaW9uKGtleSk7XG4gICAgICBpZiAoYWNjb3VudFJlZ2lvbiA9PT0gcmVnaW9uICYmXG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2tleV0gPT09IHNvY2tldEluc3RhbmNlSW5kZXgpIHtcbiAgICAgICAgYWNjb3VudElkcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY291bnRJZHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY2NvdW50IHJlZ2lvbiBieSBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHJldHVybnMge1N0cmluZ30gYWNjb3VudCByZWdpb25cbiAgICovXG4gIGdldEFjY291bnRSZWdpb24oYWNjb3VudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0gJiYgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXS5yZWdpb247XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhY2NvdW50IGNhY2hlIGluZm9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXBsaWNhcyBhY2NvdW50IHJlcGxpY2FzXG4gICAqL1xuICBhZGRBY2NvdW50Q2FjaGUoYWNjb3VudElkLCByZXBsaWNhcykge1xuICAgIHRoaXMuX2FjY291bnRSZXBsaWNhc1thY2NvdW50SWRdID0gcmVwbGljYXM7XG4gICAgT2JqZWN0LmtleXMocmVwbGljYXMpLmZvckVhY2gocmVnaW9uID0+IHtcbiAgICAgIGNvbnN0IHJlcGxpY2FJZCA9IHJlcGxpY2FzW3JlZ2lvbl07XG4gICAgICBpZiAoIXRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW3JlcGxpY2FJZF0pIHtcbiAgICAgICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYUlkXSA9IHtcbiAgICAgICAgICByZWdpb24sXG4gICAgICAgICAgY29ubmVjdGlvbnM6IDEsXG4gICAgICAgICAgbGFzdFVzZWQ6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW3JlcGxpY2FJZF0uY29ubmVjdGlvbnMrKztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbcmVwbGljYUlkXSA9IGFjY291bnRJZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFjY291bnQgY2FjaGUgaW5mb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcGxpY2FzIGFjY291bnQgcmVwbGljYXNcbiAgICovXG4gIHVwZGF0ZUFjY291bnRDYWNoZShhY2NvdW50SWQsIHJlcGxpY2FzKSB7XG4gICAgY29uc3Qgb2xkUmVwbGljYXMgPSB0aGlzLl9hY2NvdW50UmVwbGljYXNbYWNjb3VudElkXTtcbiAgICBpZihvbGRSZXBsaWNhcyl7XG4gICAgICBjb25zdCBjb25uZWN0aW9uQ291bnQgPSB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdLmNvbm5lY3Rpb25zO1xuICAgICAgT2JqZWN0LmtleXMob2xkUmVwbGljYXMpLmZvckVhY2gocmVnaW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVwbGljYUlkID0gcmVwbGljYXNbcmVnaW9uXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbcmVwbGljYUlkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW3JlcGxpY2FJZF07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2FjY291bnRSZXBsaWNhc1thY2NvdW50SWRdID0gcmVwbGljYXM7XG4gICAgICBPYmplY3Qua2V5cyhyZXBsaWNhcykuZm9yRWFjaChyZWdpb24gPT4ge1xuICAgICAgICBjb25zdCByZXBsaWNhSWQgPSByZXBsaWNhc1tyZWdpb25dO1xuICAgICAgICB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhSWRdID0ge1xuICAgICAgICAgIHJlZ2lvbixcbiAgICAgICAgICBjb25uZWN0aW9uczogY29ubmVjdGlvbkNvdW50LFxuICAgICAgICAgIGxhc3RVc2VkOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbcmVwbGljYUlkXSA9IGFjY291bnRJZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFjY291bnQgcmVnaW9uIGluZm9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqL1xuICByZW1vdmVBY2NvdW50Q2FjaGUoYWNjb3VudElkKSB7XG4gICAgaWYodGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXSkge1xuICAgICAgaWYodGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXS5jb25uZWN0aW9ucyA+IDApIHtcbiAgICAgICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXS5jb25uZWN0aW9ucy0tOyBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ja3Mgc3Vic2NyaXB0aW9uIGZvciBhIHNvY2tldCBpbnN0YW5jZSBiYXNlZCBvbiBUb29NYW55UmVxdWVzdHNFcnJvciBtZXRhZGF0YVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnaW9uIHNlcnZlciByZWdpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIFRvb01hbnlSZXF1ZXN0c0Vycm9yIG1ldGFkYXRhXG4gICAqL1xuICBhc3luYyBsb2NrU29ja2V0SW5zdGFuY2UoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbiwgbWV0YWRhdGEpIHtcbiAgICBpZiAobWV0YWRhdGEudHlwZSA9PT0gJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfVVNFUicpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZUxvY2sgPSB7XG4gICAgICAgIHJlY29tbWVuZGVkUmV0cnlUaW1lOiBtZXRhZGF0YS5yZWNvbW1lbmRlZFJldHJ5VGltZSxcbiAgICAgICAgbG9ja2VkQXRBY2NvdW50czogdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbnN0YW5jZU51bWJlciwgdW5kZWZpbmVkLCByZWdpb24pLmxlbmd0aCxcbiAgICAgICAgbG9ja2VkQXRUaW1lOiBEYXRlLm5vdygpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVkQWNjb3VudHMgPSB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pO1xuICAgICAgaWYgKHN1YnNjcmliZWRBY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3Qgc29ja2V0SW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICAgICAgc29ja2V0SW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl1bc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgICAgIGluc3RhbmNlLnN1YnNjcmliZUxvY2sgPSB7XG4gICAgICAgICAgcmVjb21tZW5kZWRSZXRyeVRpbWU6IG1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lLFxuICAgICAgICAgIHR5cGU6IG1ldGFkYXRhLnR5cGUsXG4gICAgICAgICAgbG9ja2VkQXRBY2NvdW50czogc3Vic2NyaWJlZEFjY291bnRzLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBNZXRhQXBpIHNlcnZlciB2aWEgc29ja2V0LmlvIHByb3RvY29sXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgKi9cbiAgYXN5bmMgY29ubmVjdChpbnN0YW5jZU51bWJlciwgcmVnaW9uKSB7XG4gICAgbGV0IGNsaWVudElkID0gTWF0aC5yYW5kb20oKTtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICByZXNvbHZlID0gcmVzO1xuICAgIH0pO1xuICAgIGNvbnN0IHNvY2tldEluc3RhbmNlSW5kZXggPSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0ubGVuZ3RoO1xuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgaWQ6IHNvY2tldEluc3RhbmNlSW5kZXgsXG4gICAgICByZWNvbm5lY3RXYWl0VGltZTogdGhpcy5fc29ja2V0TWluaW11bVJlY29ubmVjdFRpbWVvdXQsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgcmVxdWVzdFJlc29sdmVzOiB7fSxcbiAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgIGNvbm5lY3RSZXN1bHQ6IHJlc3VsdCxcbiAgICAgIHNlc3Npb25JZDogcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKSxcbiAgICAgIGlzUmVjb25uZWN0aW5nOiBmYWxzZSxcbiAgICAgIHNvY2tldDogbnVsbCxcbiAgICAgIHN5bmNocm9uaXphdGlvblRocm90dGxlcjogbmV3IFN5bmNocm9uaXphdGlvblRocm90dGxlcih0aGlzLCBzb2NrZXRJbnN0YW5jZUluZGV4LCBpbnN0YW5jZU51bWJlciwgcmVnaW9uLFxuICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25UaHJvdHRsZXJPcHRzKSxcbiAgICAgIHN1YnNjcmliZUxvY2s6IG51bGwsXG4gICAgICBpbnN0YW5jZU51bWJlclxuICAgIH07XG4gICAgaW5zdGFuY2UuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0ucHVzaChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnN0YXJ0KCk7XG4gICAgY29uc3Qgc2VydmVyVXJsID0gYXdhaXQgdGhpcy5fZ2V0U2VydmVyVXJsKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pO1xuICAgIGNvbnN0IHNvY2tldEluc3RhbmNlID0gc29ja2V0SU8oc2VydmVyVXJsLCB7XG4gICAgICBwYXRoOiAnL3dzJyxcbiAgICAgIHJlY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiAxMDAwLFxuICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDUwMDAsXG4gICAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogSW5maW5pdHksXG4gICAgICB0aW1lb3V0OiB0aGlzLl9jb25uZWN0VGltZW91dCxcbiAgICAgIGV4dHJhSGVhZGVyczoge1xuICAgICAgICAnQ2xpZW50LUlkJzogY2xpZW50SWRcbiAgICAgIH0sXG4gICAgICBxdWVyeToge1xuICAgICAgICAnYXV0aC10b2tlbic6IHRoaXMuX3Rva2VuLFxuICAgICAgICBjbGllbnRJZDogY2xpZW50SWQsXG4gICAgICAgIHByb3RvY29sOiAzXG4gICAgICB9XG4gICAgfSk7XG4gICAgaW5zdGFuY2Uuc29ja2V0ID0gc29ja2V0SW5zdGFuY2U7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTogTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3RlZCB0byB0aGUgTWV0YUFwaSBzZXJ2ZXJgKTtcbiAgICAgIGluc3RhbmNlLnJlY29ubmVjdFdhaXRUaW1lID0gdGhpcy5fc29ja2V0TWluaW11bVJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZXNvbHZlZCkge1xuICAgICAgICBpbnN0YW5jZS5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2ZpcmVSZWNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgICB9XG4gICAgICBpZiAoIWluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgICBpbnN0YW5jZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbigncmVjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCByZWNvbm5lY3RlZGApO1xuICAgICAgYXdhaXQgdGhpcy5fZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBpbnN0YW5jZS5pZCwgcmVnaW9uKTtcbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignY29ubmVjdF9lcnJvcicsIGFzeW5jIChlcnIpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTogTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3Rpb24gZXJyb3JgLCBlcnIpO1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3RfdGltZW91dCcsIGFzeW5jICh0aW1lb3V0KSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBjb25uZWN0aW9uIHRpbWVvdXRgKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIWluc3RhbmNlLnJlc29sdmVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Rpc2Nvbm5lY3QnLCBhc3luYyAocmVhc29uKSA9PiB7XG4gICAgICBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIub25EaXNjb25uZWN0KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTogTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBgICtcbiAgICAgICAgYE1ldGFBcGkgc2VydmVyIGJlY2F1c2Ugb2YgJHtyZWFzb259YCk7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5fcmVjb25uZWN0KGluc3RhbmNlTnVtYmVyLCBpbnN0YW5jZS5pZCwgcmVnaW9uKTtcbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignZXJyb3InLCBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTogTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IGVycm9yYCwgZXJyb3IpO1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3Jlc3BvbnNlJywgZGF0YSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCgpID0+IGAke2RhdGEuYWNjb3VudElkfTogUmVzcG9uc2UgcmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICByZXF1ZXN0SWQ6IGRhdGEucmVxdWVzdElkLCB0aW1lc3RhbXBzOiBkYXRhLnRpbWVzdGFtcHN9KX1gKTtcbiAgICAgIGxldCByZXF1ZXN0UmVzb2x2ZSA9IChpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdIHx8IHtyZXNvbHZlOiAoKSA9PiB7fSwgcmVqZWN0OiAoKSA9PiB7fX0pO1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tkYXRhLnJlcXVlc3RJZF07XG4gICAgICB0aGlzLl9jb252ZXJ0SXNvVGltZVRvRGF0ZShkYXRhKTtcbiAgICAgIHJlcXVlc3RSZXNvbHZlLnJlc29sdmUoZGF0YSk7XG4gICAgICBpZiAoZGF0YS50aW1lc3RhbXBzICYmIHJlcXVlc3RSZXNvbHZlLnR5cGUpIHtcbiAgICAgICAgZGF0YS50aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVxdWVzdFJlc29sdmUudHlwZSA9PT0gJ3RyYWRlJyA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLm9uVHJhZGUoZGF0YS5hY2NvdW50SWQsIGRhdGEudGltZXN0YW1wcykgOlxuICAgICAgICAgICAgICBsaXN0ZW5lci5vblJlc3BvbnNlKGRhdGEuYWNjb3VudElkLCByZXF1ZXN0UmVzb2x2ZS50eXBlLCBkYXRhLnRpbWVzdGFtcHMpKVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3Mgb25SZXNwb25zZSBldmVudCBmb3IgYWNjb3VudCAnICtcbiAgICAgICAgICAgICAgZGF0YS5hY2NvdW50SWQgKyAnLCByZXF1ZXN0IHR5cGUgJyArIHJlcXVlc3RSZXNvbHZlLnR5cGUsIGVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzb2NrZXRJbnN0YW5jZS5vbigncHJvY2Vzc2luZ0Vycm9yJywgZGF0YSA9PiB7XG4gICAgICBsZXQgcmVxdWVzdFJlc29sdmUgPSAoaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXSB8fCB7cmVzb2x2ZTogKCkgPT4ge30sIHJlamVjdDogKCkgPT4ge319KTtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdO1xuICAgICAgcmVxdWVzdFJlc29sdmUucmVqZWN0KHRoaXMuX2NvbnZlcnRFcnJvcihkYXRhKSk7XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBzb2NrZXRJbnN0YW5jZS5vbignc3luY2hyb25pemF0aW9uJywgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuaW5zdGFuY2VJbmRleCAmJiBkYXRhLmluc3RhbmNlSW5kZXggIT09IGluc3RhbmNlTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZSgoKSA9PiBgJHtkYXRhLmFjY291bnRJZH06JHtkYXRhLmluc3RhbmNlTnVtYmVyfTogcmVjZWl2ZWQgcGFja2V0IHdpdGggd3JvbmcgaW5zdGFuY2UgYCArXG4gICAgICAgICAgYGluZGV4IHZpYSBhIHNvY2tldCB3aXRoIGluc3RhbmNlIG51bWJlciBvZiAke2luc3RhbmNlTnVtYmVyfSwgZGF0YT0ke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGU6IGRhdGEudHlwZSwgc2VxdWVuY2VOdW1iZXI6IGRhdGEuc2VxdWVuY2VOdW1iZXIsIHNlcXVlbmNlVGltZXN0YW1wOiBkYXRhLnNlcXVlbmNlVGltZXN0YW1wLFxuICAgICAgICAgICAgc3luY2hyb25pemF0aW9uSWQ6IGRhdGEuc3luY2hyb25pemF0aW9uSWQsIGFwcGxpY2F0aW9uOiBkYXRhLmFwcGxpY2F0aW9uLCBob3N0OiBkYXRhLmhvc3QsXG4gICAgICAgICAgICBzcGVjaWZpY2F0aW9uc1VwZGF0ZWQ6IGRhdGEuc3BlY2lmaWNhdGlvbnNVcGRhdGVkLCBwb3NpdGlvbnNVcGRhdGVkOiBkYXRhLnBvc2l0aW9uc1VwZGF0ZWQsXG4gICAgICAgICAgICBvcmRlcnNVcGRhdGVkOiBkYXRhLm9yZGVyc1VwZGF0ZWQsXG4gICAgICAgICAgICBzcGVjaWZpY2F0aW9uczogZGF0YS5zcGVjaWZpY2F0aW9ucyA/IChkYXRhLnNwZWNpZmljYXRpb25zIHx8IFtdKS5sZW5ndGggOiB1bmRlZmluZWR9KX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tkYXRhLmFjY291bnRJZF0pIHtcbiAgICAgICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbZGF0YS5hY2NvdW50SWRdID0ge3JlZ2lvbiwgY29ubmVjdGlvbnM6IDAsIGxhc3RVc2VkOiBEYXRlLm5vdygpfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZSgoKSA9PiBgJHtkYXRhLmFjY291bnRJZH06JHtkYXRhLmluc3RhbmNlSW5kZXh9OiBTeW5jIHBhY2tldCByZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSwgc2VxdWVuY2VOdW1iZXI6IGRhdGEuc2VxdWVuY2VOdW1iZXIsIHNlcXVlbmNlVGltZXN0YW1wOiBkYXRhLnNlcXVlbmNlVGltZXN0YW1wLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25JZDogZGF0YS5zeW5jaHJvbml6YXRpb25JZCwgYXBwbGljYXRpb246IGRhdGEuYXBwbGljYXRpb24sIGhvc3Q6IGRhdGEuaG9zdCwgXG4gICAgICAgIHNwZWNpZmljYXRpb25zVXBkYXRlZDogZGF0YS5zcGVjaWZpY2F0aW9uc1VwZGF0ZWQsIHBvc2l0aW9uc1VwZGF0ZWQ6IGRhdGEucG9zaXRpb25zVXBkYXRlZCxcbiAgICAgICAgb3JkZXJzVXBkYXRlZDogZGF0YS5vcmRlcnNVcGRhdGVkLCBcbiAgICAgICAgc3BlY2lmaWNhdGlvbnM6IGRhdGEuc3BlY2lmaWNhdGlvbnMgPyAoZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSkubGVuZ3RoIDogdW5kZWZpbmVkfSl9LCBgICtcbiAgICAgICAgYGFjdGl2ZSBsaXN0ZW5lcnM6ICR7KHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1tkYXRhLmFjY291bnRJZF0gfHwgW10pLmxlbmd0aH1gKTtcbiAgICAgIGxldCBhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMgPSBpbnN0YW5jZS5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIuYWN0aXZlU3luY2hyb25pemF0aW9uSWRzOyBcbiAgICAgIGlmICghZGF0YS5zeW5jaHJvbml6YXRpb25JZCB8fCBhY3RpdmVTeW5jaHJvbml6YXRpb25JZHMuaW5jbHVkZXMoZGF0YS5zeW5jaHJvbml6YXRpb25JZCkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhY2tldExvZ2dlcikge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3BhY2tldExvZ2dlci5sb2dQYWNrZXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWdub3JlZFBhY2tldFR5cGVzID0gWydkaXNjb25uZWN0ZWQnLCAnc3RhdHVzJywgJ2tlZXBhbGl2ZSddO1xuICAgICAgICBpZiAoIXRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuaXNTdWJzY3JpcHRpb25BY3RpdmUoZGF0YS5hY2NvdW50SWQpICYmIFxuICAgICAgICAgICFpZ25vcmVkUGFja2V0VHlwZXMuaW5jbHVkZXMoZGF0YS50eXBlKSkge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHtkYXRhLmFjY291bnRJZH06IFBhY2tldCBhcnJpdmVkIHRvIGluYWN0aXZlIGNvbm5lY3Rpb24sIGF0dGVtcHRpbmdgICtcbiAgICAgICAgICAgIGAgdW5zdWJzY3JpYmUsIHBhY2tldDogJHtkYXRhLnR5cGV9YCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3Rocm90dGxlUmVxdWVzdCgndW5zdWJzY3JpYmUnLCBkYXRhLmFjY291bnRJZCwgZGF0YS5pbnN0YW5jZUluZGV4LCBcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlVGhyb3R0bGluZ0ludGVydmFsKSkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZShkYXRhLmFjY291bnRJZCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7ZGF0YS5hY2NvdW50SWR9OiR7ZGF0YS5pbnN0YW5jZUluZGV4IHx8IDB9OiBmYWlsZWQgdG8gdW5zdWJzY3JpYmVgLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb252ZXJ0SXNvVGltZVRvRGF0ZShkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudHlwZSA9ICdub29wJztcbiAgICAgIH1cbiAgICAgIHRoaXMucXVldWVQYWNrZXQoZGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgY29ubmVjdGlvbiB0byBNZXRhQXBpIHNlcnZlclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc29ja2V0SW5zdGFuY2VzKS5mb3JFYWNoKHJlZ2lvbiA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSkuZm9yRWFjaChpbnN0YW5jZU51bWJlciA9PiB7XG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXS5mb3JFYWNoKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICBmb3IgKGxldCByZXF1ZXN0UmVzb2x2ZSBvZiBPYmplY3QudmFsdWVzKGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlcykpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdFJlc29sdmUucmVqZWN0KG5ldyBFcnJvcignTWV0YUFwaSBjb25uZWN0aW9uIGNsb3NlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdID0ge307XG4gICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXSA9IFtdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3BhY2tldE9yZGVyZXIuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBjbGllbnRcbiAgICovXG4gIHN0b3AoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jbGVhckFjY291bnRDYWNoZUludGVydmFsKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NsZWFySW5hY3RpdmVTeW5jRGF0YUpvYik7XG4gICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCBpbmZvcm1hdGlvbiBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge0dldEFjY291bnRJbmZvcm1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXSBhZGRpdGlvbmFsIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb3JtYXRpb24oYWNjb3VudElkLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEFjY291bnRJbmZvcm1hdGlvbicsIC4uLm9wdGlvbnN9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYWNjb3VudEluZm9ybWF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcG9zaXRpb25zIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7R2V0UG9zaXRpb25zT3B0aW9uc30gW29wdGlvbnNdIGFkZGl0aW9uYWwgcmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJQb3NpdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYXJyYXkgb2Ygb3BlbiBwb3NpdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9ucyhhY2NvdW50SWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0UG9zaXRpb25zJywgLi4ub3B0aW9uc30pO1xuICAgIHJldHVybiByZXNwb25zZS5wb3NpdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzcGVjaWZpYyBwb3NpdGlvbiBmb3IgYSBNZXRhVHJhZGVyIGFjY291bnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEBwYXJhbSB7R2V0UG9zaXRpb25PcHRpb25zfSBbb3B0aW9uc10gYWRkaXRpb25hbCByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyUG9zaXRpb24+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIE1ldGFUcmFkZXIgcG9zaXRpb24gZm91bmRcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9uKGFjY291bnRJZCwgcG9zaXRpb25JZCwgb3B0aW9ucykge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRQb3NpdGlvbicsIHBvc2l0aW9uSWQsIC4uLm9wdGlvbnN9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvcGVuIG9yZGVycyBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge0dldE9yZGVyc09wdGlvbnN9IFtvcHRpb25zXSBhZGRpdGlvbmFsIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PE1ldGF0cmFkZXJPcmRlcj4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG9wZW4gTWV0YVRyYWRlciBvcmRlcnNcbiAgICovXG4gIGFzeW5jIGdldE9yZGVycyhhY2NvdW50SWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0T3JkZXJzJywgLi4ub3B0aW9uc30pO1xuICAgIHJldHVybiByZXNwb25zZS5vcmRlcnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzcGVjaWZpYyBvcGVuIG9yZGVyIGZvciBhIE1ldGFUcmFkZXIgYWNjb3VudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yZGVySWQgb3JkZXIgaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEBwYXJhbSB7R2V0T3JkZXJPcHRpb25zfSBbb3B0aW9uc10gYWRkaXRpb25hbCByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxNZXRhdHJhZGVyT3JkZXI+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1ldGF0cmFkZXIgb3JkZXIgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldE9yZGVyKGFjY291bnRJZCwgb3JkZXJJZCwgb3B0aW9ucykge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRPcmRlcicsIG9yZGVySWQsIC4uLm9wdGlvbnN9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uub3JkZXI7XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBoaXN0b3J5IG9yZGVycyBzZWFyY2ggcXVlcnkgcmVzcG9uc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckhpc3RvcnlPcmRlcnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyT3JkZXI+fSBoaXN0b3J5T3JkZXJzIGFycmF5IG9mIGhpc3Rvcnkgb3JkZXJzIHJldHVybmVkXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3luY2hyb25pemluZyBmbGFnIGluZGljYXRpbmcgdGhhdCBoaXN0b3J5IG9yZGVyIGluaXRpYWwgc3luY2hyb25pemF0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIGFuZCB0aHVzIHNlYXJjaCByZXN1bHRzIG1heSBiZSBpbmNvbXBsZXRlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgdGlja2V0IG51bWJlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRpY2tldCB0aWNrZXQgbnVtYmVyIChvcmRlciBpZClcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRIaXN0b3J5T3JkZXJzQnlUaWNrZXQoYWNjb3VudElkLCB0aWNrZXQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0JywgdGlja2V0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpc3RvcnlPcmRlcnM6IHJlc3BvbnNlLmhpc3RvcnlPcmRlcnMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaXN0b3J5IG9mIGNvbXBsZXRlZCBvcmRlcnMgZm9yIGEgc3BlY2lmaWMgcG9zaXRpb24gaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWRcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckhpc3RvcnlPcmRlcnM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGhpc3Rvcnkgb3JkZXJzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbihhY2NvdW50SWQsIHBvc2l0aW9uSWQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24nLFxuICAgICAgcG9zaXRpb25JZH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHRpbWUgcmFuZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlKGFjY291bnRJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvZmZzZXQgPSAwLCBsaW1pdCA9IDEwMDApIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0SGlzdG9yeU9yZGVyc0J5VGltZVJhbmdlJyxcbiAgICAgIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0LCBsaW1pdH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciBoaXN0b3J5IGRlYWxzIHNlYXJjaCBxdWVyeSByZXNwb25zZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyRGVhbHNcbiAgICogQHByb3BlcnR5IHtBcnJheTxNZXRhdHJhZGVyRGVhbD59IGRlYWxzIGFycmF5IG9mIGhpc3RvcnkgZGVhbHMgcmV0dXJuZWRcbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBzeW5jaHJvbml6aW5nIGZsYWcgaW5kaWNhdGluZyB0aGF0IGRlYWwgaW5pdGlhbCBzeW5jaHJvbml6YXRpb24gaXMgc3RpbGwgaW4gcHJvZ3Jlc3NcbiAgICogYW5kIHRodXMgc2VhcmNoIHJlc3VsdHMgbWF5IGJlIGluY29tcGxldGVcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgZGVhbFxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyRGVhbFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gaWQgZGVhbCBpZCAodGlja2V0IG51bWJlcilcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgZGVhbCB0eXBlIChvbmUgb2YgREVBTF9UWVBFX0JVWSwgREVBTF9UWVBFX1NFTEwsIERFQUxfVFlQRV9CQUxBTkNFLCBERUFMX1RZUEVfQ1JFRElULFxuICAgKiBERUFMX1RZUEVfQ0hBUkdFLCBERUFMX1RZUEVfQ09SUkVDVElPTiwgREVBTF9UWVBFX0JPTlVTLCBERUFMX1RZUEVfQ09NTUlTU0lPTiwgREVBTF9UWVBFX0NPTU1JU1NJT05fREFJTFksXG4gICAqIERFQUxfVFlQRV9DT01NSVNTSU9OX01PTlRITFksIERFQUxfVFlQRV9DT01NSVNTSU9OX0FHRU5UX0RBSUxZLCBERUFMX1RZUEVfQ09NTUlTU0lPTl9BR0VOVF9NT05USExZLFxuICAgKiBERUFMX1RZUEVfSU5URVJFU1QsIERFQUxfVFlQRV9CVVlfQ0FOQ0VMRUQsIERFQUxfVFlQRV9TRUxMX0NBTkNFTEVELCBERUFMX0RJVklERU5ELCBERUFMX0RJVklERU5EX0ZSQU5LRUQsXG4gICAqIERFQUxfVEFYKS4gU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvZGVhbHByb3BlcnRpZXMjZW51bV9kZWFsX3R5cGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGVudHJ5VHlwZSBkZWFsIGVudHJ5IHR5cGUgKG9uZSBvZiBERUFMX0VOVFJZX0lOLCBERUFMX0VOVFJZX09VVCwgREVBTF9FTlRSWV9JTk9VVCxcbiAgICogREVBTF9FTlRSWV9PVVRfQlkpLiBTZWUgaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9kZWFscHJvcGVydGllcyNlbnVtX2RlYWxfZW50cnlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzeW1ib2xdIHN5bWJvbCBkZWFsIHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFttYWdpY10gZGVhbCBtYWdpYyBudW1iZXIsIGlkZW50aWZpZXMgdGhlIEVBIHdoaWNoIGluaXRpYXRlZCB0aGUgZGVhbFxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgdGltZSB0aGUgZGVhbCB3YXMgY29uZHVjdGVkIGF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXJUaW1lIHRpbWUgdGltZSB0aGUgZGVhbCB3YXMgY29uZHVjdGVkIGF0LCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3ZvbHVtZV0gZGVhbCB2b2x1bWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwcmljZV0gdGhlIHByaWNlIHRoZSBkZWFsIHdhcyBjb25kdWN0ZWQgYXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb21taXNzaW9uXSBkZWFsIGNvbW1pc3Npb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzd2FwXSBkZWFsIHN3YXBcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByb2ZpdCBkZWFsIHByb2ZpdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3Bvc2l0aW9uSWRdIGlkIG9mIHBvc2l0aW9uIHRoZSBkZWFsIHJlbGF0ZXMgdG9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtvcmRlcklkXSBpZCBvZiBvcmRlciB0aGUgZGVhbCByZWxhdGVzIHRvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29tbWVudF0gZGVhbCBjb21tZW50LiBUaGUgc3VtIG9mIHRoZSBsaW5lIGxlbmd0aHMgb2YgdGhlIGNvbW1lbnQgYW5kIHRoZSBjbGllbnRJZFxuICAgKiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAyNi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9jbGllbnRJZFVzYWdlL1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2Jyb2tlckNvbW1lbnRdIGN1cnJlbnQgY29tbWVudCB2YWx1ZSBvbiBicm9rZXIgc2lkZSAocG9zc2libHkgb3ZlcnJpZGVuIGJ5IHRoZSBicm9rZXIpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY2xpZW50SWRdIGNsaWVudC1hc3NpZ25lZCBpZC4gVGhlIGlkIHZhbHVlIGNhbiBiZSBhc3NpZ25lZCB3aGVuIHN1Ym1pdHRpbmcgYSB0cmFkZSBhbmRcbiAgICogd2lsbCBiZSBwcmVzZW50IG9uIHBvc2l0aW9uLCBoaXN0b3J5IG9yZGVycyBhbmQgaGlzdG9yeSBkZWFscyByZWxhdGVkIHRvIHRoZSB0cmFkZS4gWW91IGNhbiB1c2UgdGhpcyBmaWVsZCB0byBiaW5kXG4gICAqIHlvdXIgdHJhZGVzIHRvIG9iamVjdHMgaW4geW91ciBhcHBsaWNhdGlvbiBhbmQgdGhlbiB0cmFjayB0cmFkZSBwcm9ncmVzcy4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZVxuICAgKiBjb21tZW50IGFuZCB0aGUgY2xpZW50SWQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAgKiBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBsYXRmb3JtIHBsYXRmb3JtIGlkIChtdDQgb3IgbXQ1KVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3JlYXNvbl0gb3B0aW9uYWwgZGVhbCBleGVjdXRpb24gcmVhc29uLiBPbmUgb2YgREVBTF9SRUFTT05fQ0xJRU5ULCBERUFMX1JFQVNPTl9NT0JJTEUsXG4gICAqIERFQUxfUkVBU09OX1dFQiwgREVBTF9SRUFTT05fRVhQRVJULCBERUFMX1JFQVNPTl9TTCwgREVBTF9SRUFTT05fVFAsIERFQUxfUkVBU09OX1NPLCBERUFMX1JFQVNPTl9ST0xMT1ZFUixcbiAgICogREVBTF9SRUFTT05fVk1BUkdJTiwgREVBTF9SRUFTT05fU1BMSVQsIERFQUxfUkVBU09OX1VOS05PV04uIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL2RlYWxwcm9wZXJ0aWVzI2VudW1fZGVhbF9yZWFzb24uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlXSBjdXJyZW50IGV4Y2hhbmdlIHJhdGUgb2YgYWNjb3VudCBjdXJyZW5jeSBpbnRvIGFjY291bnQgYmFzZVxuICAgKiBjdXJyZW5jeSAoVVNEIGlmIHlvdSBkaWQgbm90IG92ZXJyaWRlIGl0KVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3N0b3BMb3NzXSBkZWFsIHN0b3AgbG9zcy4gRm9yIE1UNSBvcGVuaW5nIGRlYWwgdGhpcyBpcyB0aGUgU0wgb2YgdGhlIG9yZGVyIG9wZW5pbmcgdGhlIFxuICAgKiBwb3NpdGlvbi4gRm9yIE1UNCBkZWFscyBvciBNVDUgY2xvc2luZyBkZWFsIHRoaXMgaXMgdGhlIGxhc3Qga25vd24gcG9zaXRpb24gU0wuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFrZVByb2ZpdF0gZGVhbCB0YWtlIHByb2ZpdC4gRm9yIE1UNSBvcGVuaW5nIGRlYWwgdGhpcyBpcyB0aGUgVFAgb2YgdGhlIG9yZGVyIG9wZW5pbmcgdGhlIFxuICAgKiBwb3NpdGlvbi4gRm9yIE1UNCBkZWFscyBvciBNVDUgY2xvc2luZyBkZWFsIHRoaXMgaXMgdGhlIGxhc3Qga25vd24gcG9zaXRpb24gVFAuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGVhbHMgd2l0aCBhIHNwZWNpZmljIHRpY2tldCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRpY2tldCB0aWNrZXQgbnVtYmVyIChkZWFsIGlkIGZvciBNVDUgb3Igb3JkZXIgaWQgZm9yIE1UNClcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckRlYWxzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBkZWFscyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0RGVhbHNCeVRpY2tldChhY2NvdW50SWQsIHRpY2tldCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5VGlja2V0JywgdGlja2V0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yeSBkZWFscyBmb3IgYSBzcGVjaWZpYyBwb3NpdGlvbiBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyRGVhbHM+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHJlcXVlc3QgcmVzdWx0cyBjb250YWluaW5nIGRlYWxzIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXREZWFsc0J5UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldERlYWxzQnlQb3NpdGlvbicsIHBvc2l0aW9uSWR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhbHM6IHJlc3BvbnNlLmRlYWxzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggZm9yIGEgc3BlY2lmaWMgdGltZSByYW5nZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0VGltZSBzdGFydCBvZiB0aW1lIHJhbmdlLCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtEYXRlfSBlbmRUaW1lIGVuZCBvZiB0aW1lIHJhbmdlLCBleGNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBwYWdpbmF0aW9uIG9mZnNldCwgZGVmYXVsdCBpcyAwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBwYWdpbmF0aW9uIGxpbWl0LCBkZWZhdWx0IGlzIDEwMDBcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckRlYWxzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBkZWFscyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0RGVhbHNCeVRpbWVSYW5nZShhY2NvdW50SWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0ID0gMCwgbGltaXQgPSAxMDAwKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldERlYWxzQnlUaW1lUmFuZ2UnLCBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLCBvZmZzZXQsIGxpbWl0fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgb3JkZXIgYW5kIHRyYW5zYWN0aW9uIGhpc3Rvcnkgb2YgYSBzcGVjaWZpZWQgYXBwbGljYXRpb24gYW5kIHJlbW92ZXMgdGhlIGFwcGxpY2F0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZW1vdmUgaGlzdG9yeSBhbmQgYXBwbGljYXRpb24gZm9yXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGhpc3RvcnkgaXMgY2xlYXJlZFxuICAgKi9cbiAgcmVtb3ZlQXBwbGljYXRpb24oYWNjb3VudElkKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAncmVtb3ZlQXBwbGljYXRpb24nfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0YVRyYWRlciB0cmFkZSByZXNwb25zZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyVHJhZGVSZXNwb25zZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbnVtZXJpY0NvZGUgbnVtZXJpYyByZXNwb25zZSBjb2RlLCBzZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZXJyb3Jzd2FybmluZ3MvZW51bV90cmFkZV9yZXR1cm5fY29kZXMgYW5kXG4gICAqIGh0dHBzOi8vYm9vay5tcWw0LmNvbS9hcHBlbmRpeC9lcnJvcnMuIFJlc3BvbnNlIGNvZGVzIHdoaWNoIGluZGljYXRlIHN1Y2Nlc3MgYXJlIDAsIDEwMDA4LTEwMDEwLCAxMDAyNS4gVGhlIHJlc3RcbiAgICogY29kZXMgYXJlIGVycm9yc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gc3RyaW5nQ29kZSBzdHJpbmcgcmVzcG9uc2UgY29kZSwgc2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vycm9yc3dhcm5pbmdzL2VudW1fdHJhZGVfcmV0dXJuX2NvZGVzIGFuZFxuICAgKiBodHRwczovL2Jvb2subXFsNC5jb20vYXBwZW5kaXgvZXJyb3JzLiBSZXNwb25zZSBjb2RlcyB3aGljaCBpbmRpY2F0ZSBzdWNjZXNzIGFyZSBFUlJfTk9fRVJST1IsXG4gICAqIFRSQURFX1JFVENPREVfUExBQ0VELCBUUkFERV9SRVRDT0RFX0RPTkUsIFRSQURFX1JFVENPREVfRE9ORV9QQVJUSUFMLCBUUkFERV9SRVRDT0RFX05PX0NIQU5HRVMuIFRoZSByZXN0IGNvZGVzIGFyZVxuICAgKiBlcnJvcnMuXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIGh1bWFuLXJlYWRhYmxlIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yZGVySWQgb3JkZXIgaWQgd2hpY2ggd2FzIGNyZWF0ZWQvbW9kaWZpZWQgZHVyaW5nIHRoZSB0cmFkZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZCB3aGljaCB3YXMgbW9kaWZpZWQgZHVyaW5nIHRoZSB0cmFkZVxuICAgKi9cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHRyYWRlIG9uIGEgY29ubmVjdGVkIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gZXhlY3V0ZSB0cmFkZSBmb3JcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyVHJhZGV9IHRyYWRlIHRyYWRlIHRvIGV4ZWN1dGUgKHNlZSBkb2NzIGZvciBwb3NzaWJsZSB0cmFkZSB0eXBlcylcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthcHBsaWNhdGlvbl0gYXBwbGljYXRpb24gdG8gdXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsaWFiaWxpdHldIGFjY291bnQgcmVsaWFiaWxpdHlcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRyYWRlUmVzcG9uc2U+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRyYWRlIHJlc3VsdFxuICAgKiBAdGhyb3dzIHtUcmFkZUVycm9yfSBvbiB0cmFkZSBlcnJvciwgY2hlY2sgZXJyb3IgcHJvcGVydGllcyBmb3IgZXJyb3IgY29kZSBkZXRhaWxzXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBhc3luYyB0cmFkZShhY2NvdW50SWQsIHRyYWRlLCBhcHBsaWNhdGlvbiwgcmVsaWFiaWxpdHkpIHtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgaWYoYXBwbGljYXRpb24gPT09ICdSUEMnKSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHt0eXBlOiAndHJhZGUnLCB0cmFkZSwgYXBwbGljYXRpb259KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLCB7dHlwZTogJ3RyYWRlJywgdHJhZGUsXG4gICAgICAgIGFwcGxpY2F0aW9uOiBhcHBsaWNhdGlvbiB8fCB0aGlzLl9hcHBsaWNhdGlvbiwgcmVxdWVzdElkOiByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpfSwgcmVsaWFiaWxpdHkpO1xuICAgIH1cbiAgICByZXNwb25zZS5yZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlIHx8IHt9O1xuICAgIHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgPSByZXNwb25zZS5yZXNwb25zZS5zdHJpbmdDb2RlIHx8IHJlc3BvbnNlLnJlc3BvbnNlLmRlc2NyaXB0aW9uO1xuICAgIHJlc3BvbnNlLnJlc3BvbnNlLm51bWVyaWNDb2RlID0gcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgIT09IHVuZGVmaW5lZCA/IHJlc3BvbnNlLnJlc3BvbnNlLm51bWVyaWNDb2RlIDpcbiAgICAgIHJlc3BvbnNlLnJlc3BvbnNlLmVycm9yO1xuICAgIGlmIChbJ0VSUl9OT19FUlJPUicsICdUUkFERV9SRVRDT0RFX1BMQUNFRCcsICdUUkFERV9SRVRDT0RFX0RPTkUnLCAnVFJBREVfUkVUQ09ERV9ET05FX1BBUlRJQUwnLFxuICAgICAgJ1RSQURFX1JFVENPREVfTk9fQ0hBTkdFUyddLmluY2x1ZGVzKHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgfHwgcmVzcG9uc2UucmVzcG9uc2UuZGVzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzcG9uc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUcmFkZUVycm9yKHJlc3BvbnNlLnJlc3BvbnNlLm1lc3NhZ2UsIHJlc3BvbnNlLnJlc3BvbnNlLm51bWVyaWNDb2RlLCByZXNwb25zZS5yZXNwb25zZS5zdHJpbmdDb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhc2sgdGhhdCBlbnN1cmVzIHRoZSBhY2NvdW50IGdldHMgc3Vic2NyaWJlZCB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZCB0byBzdWJzY3JpYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKi9cbiAgZW5zdXJlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLnNjaGVkdWxlU3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gdGhlIE1ldGF0cmFkZXIgdGVybWluYWwgZXZlbnRzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzdWJzY3JpYmUgdG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiBzdGFydGVkXG4gICAqL1xuICBzdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLnN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgdGVybWluYWwgdG8gc3RhcnQgc3luY2hyb25pemF0aW9uIHByb2Nlc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHN5bmNocm9uaXplXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob3N0IG5hbWUgb2YgaG9zdCB0byBzeW5jaHJvbml6ZSB3aXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcGFyYW0ge0RhdGV9IHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSBmcm9tIHdoYXQgZGF0ZSB0byBzdGFydCBzeW5jaHJvbml6aW5nIGhpc3Rvcnkgb3JkZXJzIGZyb20uIElmIG5vdCBzcGVjaWZpZWQsXG4gICAqIHRoZSBlbnRpcmUgb3JkZXIgaGlzdG9yeSB3aWxsIGJlIGRvd25sb2FkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRpbmdEZWFsVGltZSBmcm9tIHdoYXQgZGF0ZSB0byBzdGFydCBkZWFsIHN5bmNocm9uaXphdGlvbiBmcm9tLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIGFsbFxuICAgKiBoaXN0b3J5IGRlYWxzIHdpbGwgYmUgZG93bmxvYWRlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0SGFzaGVzIGZ1bmN0aW9uIHRvIGdldCB0ZXJtaW5hbCBzdGF0ZSBoYXNoZXNcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBzeW5jaHJvbml6YXRpb24gc3RhcnRlZFxuICAgKi9cbiAgYXN5bmMgc3luY2hyb25pemUoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4LCBob3N0LCBzeW5jaHJvbml6YXRpb25JZCwgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lLCBzdGFydGluZ0RlYWxUaW1lLCAgXG4gICAgaGFzaGVzKSB7XG4gICAgaWYodGhpcy5fZ2V0U29ja2V0SW5zdGFuY2VCeUFjY291bnQoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBjcmVhdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gc3luY2hyb25pemVgKTtcbiAgICAgIGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNUaHJvdHRsZXIgPSB0aGlzLl9nZXRTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChhY2NvdW50SWQsIGluc3RhbmNlSW5kZXgpXG4gICAgICAuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tzeW5jaHJvbml6YXRpb25JZF0gPSBoYXNoZXM7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW3N5bmNocm9uaXphdGlvbklkXS5sYXN0VXBkYXRlZCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHN5bmNUaHJvdHRsZXIuc2NoZWR1bGVTeW5jaHJvbml6ZShhY2NvdW50SWQsIHtyZXF1ZXN0SWQ6IHN5bmNocm9uaXphdGlvbklkLCB2ZXJzaW9uOiAyLFxuICAgICAgdHlwZTogJ3N5bmNocm9uaXplJywgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lLCBzdGFydGluZ0RlYWxUaW1lLCBpbnN0YW5jZUluZGV4LCBob3N0fSwgaGFzaGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3Igc2VydmVyLXNpZGUgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIHRvIGNvbXBsZXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzeW5jaHJvbml6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlTnVtYmVyXSBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwcGxpY2F0aW9uUGF0dGVybiBNZXRhQXBpIGFwcGxpY2F0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCBkZWZhdWx0IGlzIC4qXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMDAgc2Vjb25kc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwcGxpY2F0aW9uXSBhcHBsaWNhdGlvbiB0byBzeW5jaHJvbml6ZSB3aXRoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHdhaXRTeW5jaHJvbml6ZWQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgYXBwbGljYXRpb25QYXR0ZXJuLCB0aW1lb3V0SW5TZWNvbmRzLCBhcHBsaWNhdGlvbikge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3dhaXRTeW5jaHJvbml6ZWQnLCBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVvdXRJblNlY29uZHMsXG4gICAgICBpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlciwgYXBwbGljYXRpb246IGFwcGxpY2F0aW9uIHx8IHRoaXMuX2FwcGxpY2F0aW9ufSxcbiAgICB0aW1lb3V0SW5TZWNvbmRzICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogTWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmtldERhdGFTdWJzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgc3Vic2NyaXB0aW9uIHR5cGUsIG9uZSBvZiBxdW90ZXMsIGNhbmRsZXMsIHRpY2tzLCBvciBtYXJrZXREZXB0aFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpbWVmcmFtZV0gd2hlbiBzdWJzY3JpcHRpb24gdHlwZSBpcyBjYW5kbGVzLCBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZVxuICAgKiBjYW5kbGVzIG11c3QgYmUgZ2VuZXJhdGVkLiBBbGxvd2VkIHZhbHVlcyBmb3IgTVQ1IGFyZSAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSwgMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCxcbiAgICogNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtbi4gQWxsb3dlZCB2YWx1ZXMgZm9yIE1UNCBhcmUgMW0sIDVtLCAxNW0gMzBtLCAxaCwgNGgsIDFkLCAxdywgMW1uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW50ZXJ2YWxJbk1pbGxpc2Vjb25kc10gZGVmaW5lcyBob3cgZnJlcXVlbnRseSB0aGUgdGVybWluYWwgd2lsbCBzdHJlYW0gZGF0YSB0byBjbGllbnQuIElmIG5vdFxuICAgKiBzZXQsIHRoZW4gdGhlIHZhbHVlIGNvbmZpZ3VyZWQgaW4gYWNjb3VudCB3aWxsIGJlIHVzZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb24gdG8gY3JlYXRlIG9yIHVwZGF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlbGlhYmlsaXR5XSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZFxuICAgKi9cbiAgc3Vic2NyaWJlVG9NYXJrZXREYXRhKGFjY291bnRJZCwgc3ltYm9sLCBzdWJzY3JpcHRpb25zLCByZWxpYWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLFxuICAgICAge3R5cGU6ICdzdWJzY3JpYmVUb01hcmtldERhdGEnLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnN9LCByZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaGVzIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgb24gdGhlIHNlcnZlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBleHBpcmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gcmVmcmVzaFxuICAgKi9cbiAgcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdyZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMnLCBzdWJzY3JpcHRpb25zLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZXQgZGF0YSB1bnN1YnNjcmlwdGlvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXJrZXREYXRhVW5zdWJzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgc3Vic2NyaXB0aW9uIHR5cGUsIG9uZSBvZiBxdW90ZXMsIGNhbmRsZXMsIHRpY2tzLCBvciBtYXJrZXREZXB0aFxuICAgKi9cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsaWFiaWxpdHldIGFjY291bnQgcmVsaWFiaWxpdHlcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoYWNjb3VudElkLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIHJlbGlhYmlsaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHt0eXBlOiAndW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YScsIHN5bWJvbCwgc3Vic2NyaXB0aW9uc30sXG4gICAgICByZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHN5bWJvbHMgYXZhaWxhYmxlIG9uIGFuIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbHMgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3ltYm9scyBhcmUgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRTeW1ib2xzKGFjY291bnRJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xzJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5zeW1ib2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzcGVjaWZpY2F0aW9uIGZvciBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNwZWNpZmljYXRpb24gaXMgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRTeW1ib2xTcGVjaWZpY2F0aW9uKGFjY291bnRJZCwgc3ltYm9sKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFN5bWJvbFNwZWNpZmljYXRpb24nLCBzeW1ib2x9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uuc3BlY2lmaWNhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJpY2UgZm9yIGEgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgcHJpY2UgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHByaWNlIGZvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdWJzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBhY2NvdW50IHdpbGwgZ2V0IGEgbG9uZy10ZXJtIHN1YnNjcmlwdGlvbiB0byBzeW1ib2wgbWFya2V0XG4gICAqIGRhdGEuIExvbmctdGVybSBzdWJzY3JpcHRpb24gbWVhbnMgdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzIHlvdSB3aWxsIGdldCB1cGRhdGVkIHZhbHVlIGZhc3Rlci4gSWYgc2V0IHRvIGZhbHNlIG9yXG4gICAqIG5vdCBzZXQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBzZXQgdG8gZXhwaXJlIGluIDEyIG1pbnV0ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xQcmljZT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBwcmljZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFN5bWJvbFByaWNlKGFjY291bnRJZCwgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9uID0gZmFsc2UpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0U3ltYm9sUHJpY2UnLCBzeW1ib2wsXG4gICAgICBrZWVwU3Vic2NyaXB0aW9ufSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnByaWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmljZSBmb3IgYSBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIGNhbmRsZSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgY2FuZGxlIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZWZyYW1lIGRlZmluZXMgdGhlIHRpbWVmcmFtZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGNhbmRsZSBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXMgZm9yXG4gICAqIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWQgdmFsdWVzXG4gICAqIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdWJzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBhY2NvdW50IHdpbGwgZ2V0IGEgbG9uZy10ZXJtIHN1YnNjcmlwdGlvbiB0byBzeW1ib2wgbWFya2V0XG4gICAqIGRhdGEuIExvbmctdGVybSBzdWJzY3JpcHRpb24gbWVhbnMgdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzIHlvdSB3aWxsIGdldCB1cGRhdGVkIHZhbHVlIGZhc3Rlci4gSWYgc2V0IHRvIGZhbHNlIG9yXG4gICAqIG5vdCBzZXQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBzZXQgdG8gZXhwaXJlIGluIDEyIG1pbnV0ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJDYW5kbGU+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY2FuZGxlIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0Q2FuZGxlKGFjY291bnRJZCwgc3ltYm9sLCB0aW1lZnJhbWUsIGtlZXBTdWJzY3JpcHRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRDYW5kbGUnLCBzeW1ib2wsIHRpbWVmcmFtZSxcbiAgICAgIGtlZXBTdWJzY3JpcHRpb259KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuY2FuZGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3QgdGljayBmb3IgYSBzeW1ib2wuIE1UNCBHMSBhY2NvdW50cyBkbyBub3Qgc3VwcG9ydCB0aGlzIEFQSVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHRpY2sgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2sgZm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN1YnNjcmlwdGlvbiBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGFjY291bnQgd2lsbCBnZXQgYSBsb25nLXRlcm0gc3Vic2NyaXB0aW9uIHRvIHN5bWJvbCBtYXJrZXRcbiAgICogZGF0YS4gTG9uZy10ZXJtIHN1YnNjcmlwdGlvbiBtZWFucyB0aGF0IG9uIHN1YnNlcXVlbnQgY2FsbHMgeW91IHdpbGwgZ2V0IHVwZGF0ZWQgdmFsdWUgZmFzdGVyLiBJZiBzZXQgdG8gZmFsc2Ugb3JcbiAgICogbm90IHNldCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIHNldCB0byBleHBpcmUgaW4gMTIgbWludXRlcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRpY2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGljayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFRpY2soYWNjb3VudElkLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRUaWNrJywgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9ufSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRpY2s7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGxhdGVzdCBvcmRlciBib29rIGZvciBhIHN5bWJvbC4gTVQ0IGFjY291bnRzIGRvIG5vdCBzdXBwb3J0IHRoaXMgQVBJXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgb3JkZXIgYm9vayBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgb3JkZXIgYm9vayBmb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwU3Vic2NyaXB0aW9uIGlmIHNldCB0byB0cnVlLCB0aGUgYWNjb3VudCB3aWxsIGdldCBhIGxvbmctdGVybSBzdWJzY3JpcHRpb24gdG8gc3ltYm9sIG1hcmtldFxuICAgKiBkYXRhLiBMb25nLXRlcm0gc3Vic2NyaXB0aW9uIG1lYW5zIHRoYXQgb24gc3Vic2VxdWVudCBjYWxscyB5b3Ugd2lsbCBnZXQgdXBkYXRlZCB2YWx1ZSBmYXN0ZXIuIElmIHNldCB0byBmYWxzZSBvclxuICAgKiBub3Qgc2V0LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgc2V0IHRvIGV4cGlyZSBpbiAxMiBtaW51dGVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQm9vaz59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBvcmRlciBib29rIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0Qm9vayhhY2NvdW50SWQsIHN5bWJvbCwga2VlcFN1YnNjcmlwdGlvbiA9IGZhbHNlKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEJvb2snLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb259KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYm9vaztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgcmVmcmVzaCBvZiBtb3N0IHJlY2VudCBxdW90ZSB1cGRhdGVzIGZvciBzeW1ib2xzIHN1YnNjcmliZWQgdG8gYnkgdGhlIHRlcm1pbmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCByZWNlbnQgcXVvdGUgc3ltYm9scyB0aGF0IHdhcyBpbml0aWF0ZWQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgYXN5bmMgcmVmcmVzaFRlcm1pbmFsU3RhdGUoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ3JlZnJlc2hUZXJtaW5hbFN0YXRlJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5zeW1ib2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyByZWZyZXNoIGFuZCByZXRyaWV2ZXMgbGF0ZXN0IHF1b3RlcyBmb3IgYSBzdWJzZXQgb2Ygc3ltYm9scyB0aGUgdGVybWluYWwgaXMgc3Vic2NyaWJlZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gc3ltYm9scyBxdW90ZSBzeW1ib2xzIHRvIHJlZnJlc2hcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVmcmVzaGVkUXVvdGVzPn0gcmVmcmVzaGVkIHF1b3RlcyBhbmQgYmFzaWMgYWNjb3VudCBpbmZvcm1hdGlvbiBpbmZvXG4gICAqL1xuICBhc3luYyByZWZyZXNoU3ltYm9sUXVvdGVzKGFjY291bnRJZCwgc3ltYm9scykge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdyZWZyZXNoU3ltYm9sUXVvdGVzJywgc3ltYm9sc30pO1xuICAgIHJldHVybiByZXNwb25zZS5yZWZyZXNoZWRRdW90ZXM7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHVwdGltZSBzdGF0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc2F2ZSB1cHRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwdGltZSB1cHRpbWUgc3RhdGlzdGljcyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1cHRpbWUgc3RhdGlzdGljcyBpcyBzdWJtaXR0ZWRcbiAgICovXG4gIHNhdmVVcHRpbWUoYWNjb3VudElkLCB1cHRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdzYXZlVXB0aW1lJywgdXB0aW1lfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNvY2tldCB1bnN1YnNjcmliZWRcbiAgICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGFjY291bnRJZCkge1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLm9uVW5zdWJzY3JpYmUoYWNjb3VudElkKTtcbiAgICBjb25zdCB1cGRhdGVFdmVudHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZUV2ZW50cykuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChhY2NvdW50SWQpKTtcbiAgICB1cGRhdGVFdmVudHNUb1JlbW92ZS5mb3JFYWNoKGtleSA9PiBkZWxldGUgdGhpcy5fdXBkYXRlRXZlbnRzW2tleV0pO1xuICAgIGlmKHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3Qua2V5cyh0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSkubWFwKGFzeW5jIGluc3RhbmNlTnVtYmVyID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLnVuc3Vic2NyaWJlKGFjY291bnRJZCwgTnVtYmVyKGluc3RhbmNlTnVtYmVyKSk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghKFsnVGltZW91dEVycm9yJywgJ05vdEZvdW5kRXJyb3InXS5pbmNsdWRlcyhlcnIubmFtZSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBmYWlsZWQgdG8gdW5zdWJzY3JpYmVgLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNlcnZlciB0aW1lIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9zZXJ2ZXJUaW1lLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gU2VydmVyVGltZVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgY3VycmVudCBzZXJ2ZXIgdGltZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSBjdXJyZW50IGJyb2tlciB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKiBAcHJvcGVydHkge0RhdGV9IFtsYXN0UXVvdGVUaW1lXSBsYXN0IHF1b3RlIHRpbWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtsYXN0UXVvdGVCcm9rZXJUaW1lXSBsYXN0IHF1b3RlIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlcnZlciB0aW1lIGZvciBhIHNwZWNpZmllZCBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBzZXJ2ZXIgdGltZSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8U2VydmVyVGltZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggc2VydmVyIHRpbWVcbiAgICovXG4gIGFzeW5jIGdldFNlcnZlclRpbWUoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFNlcnZlclRpbWUnfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnNlcnZlclRpbWU7XG4gIH1cblxuICAvKipcbiAgICogTWFyZ2luIHJlcXVpcmVkIHRvIG9wZW4gYSB0cmFkZSAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWFyZ2luLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWFyZ2luXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWFyZ2luXSBtYXJnaW4gcmVxdWlyZWQgdG8gb3BlbiBhIHRyYWRlLiBJZiBtYXJnaW4gY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIHRoaXMgZmllbGQgaXNcbiAgICogbm90IGRlZmluZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yIChzZWUgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tYXJnaW5PcmRlci8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmdpbk9yZGVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzeW1ib2wgb3JkZXIgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIG9yZGVyIHR5cGUsIG9uZSBvZiBPUkRFUl9UWVBFX0JVWSBvciBPUkRFUl9UWVBFX1NFTExcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSBvcmRlciB2b2x1bWUsIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG9wZW5QcmljZSBvcmRlciBvcGVuIHByaWNlLCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIG1hcmdpbiByZXF1aXJlZCB0byBvcGVuIGEgdHJhZGUgb24gdGhlIHNwZWNpZmllZCB0cmFkaW5nIGFjY291bnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgdHJhZGluZyBhY2NvdW50IHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBsaWNhdGlvbiBhcHBsaWNhdGlvbiB0byBzZW5kIHRoZSByZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWxpYWJpbGl0eSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEBwYXJhbSB7TWFyZ2luT3JkZXJ9IG9yZGVyIG9yZGVyIHRvIGNhbGN1bGF0ZSBtYXJnaW4gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1hcmdpbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggbWFyZ2luIGNhbGN1bGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgYXN5bmMgY2FsY3VsYXRlTWFyZ2luKGFjY291bnRJZCwgYXBwbGljYXRpb24sIHJlbGlhYmlsaXR5LCBvcmRlcikge1xuICAgIGxldCByZXNwb25zZTtcbiAgICBpZihhcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uLCB0eXBlOiAnY2FsY3VsYXRlTWFyZ2luJywgb3JkZXJ9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLCB7YXBwbGljYXRpb24sIHR5cGU6ICdjYWxjdWxhdGVNYXJnaW4nLCBvcmRlcn0sXG4gICAgICAgIHJlbGlhYmlsaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLm1hcmdpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBvblVuc3Vic2NyaWJlUmVnaW9uIGxpc3RlbmVyIGV2ZW50IFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvbiB0byB1bnN1YnNjcmliZVxuICAgKi9cbiAgYXN5bmMgdW5zdWJzY3JpYmVBY2NvdW50UmVnaW9uKGFjY291bnRJZCwgcmVnaW9uKSB7XG4gICAgY29uc3QgdW5zdWJzY3JpYmVQcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICB1bnN1YnNjcmliZVByb21pc2VzLnB1c2goXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uVW5zdWJzY3JpYmVSZWdpb24ocmVnaW9uKSxcbiAgICAgICAgICAgIGAke2FjY291bnRJZH06JHtyZWdpb259Om9uVW5zdWJzY3JpYmVSZWdpb25gLCB0cnVlKTtcbiAgICAgICAgfSkoKSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcihgJHthY2NvdW50SWR9OiR7cmVnaW9ufTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgICdhYm91dCBvblVuc3Vic2NyaWJlUmVnaW9uIGV2ZW50JywgZXJyKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHVuc3Vic2NyaWJlUHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50SWQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke2FjY291bnRJZH06IEFkZGVkIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lcmApO1xuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXSA9IGxpc3RlbmVycztcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyIGZvciBzcGVjaWZpYyBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N5bmNocm9uaXphdGlvbkxpc3RlbmVyfSBsaXN0ZW5lciBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50SWQsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke2FjY291bnRJZH06IFJlbW92ZWQgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyYCk7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbYWNjb3VudElkXSA9IGxpc3RlbmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxhdGVuY3kgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtMYXRlbmN5TGlzdGVuZXJ9IGxpc3RlbmVyIGxhdGVuY3kgbGlzdGVuZXIgdG8gYWRkXG4gICAqL1xuICBhZGRMYXRlbmN5TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGF0ZW5jeSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0xhdGVuY3lMaXN0ZW5lcn0gbGlzdGVuZXIgbGF0ZW5jeSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUxhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHJlY29ubmVjdCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1JlY29ubmVjdExpc3RlbmVyfSBsaXN0ZW5lciByZWNvbm5lY3QgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZCBvZiBsaXN0ZW5lclxuICAgKi9cbiAgYWRkUmVjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIsIGFjY291bnRJZCkge1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycy5wdXNoKHthY2NvdW50SWQsIGxpc3RlbmVyfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyByZWNvbm5lY3QgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtSZWNvbm5lY3RMaXN0ZW5lcn0gbGlzdGVuZXIgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3JlY29ubmVjdExpc3RlbmVycyA9IHRoaXMuX3JlY29ubmVjdExpc3RlbmVycy5maWx0ZXIobCA9PiBsLmxpc3RlbmVyICE9PSBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJbnRlbmRlZCBmb3IgdXNlIGluIHVuaXQgdGVzdHMuXG4gICAqL1xuICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFjY291bnQgb3IgcmVwbGljYSBkYXRhIGZyb20gY2xpZW50IHJlY29yZHMgYW5kIHVuc3Vic2NyaWJlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWQgdG8gcHJvY2VzcyB0aGUgcmVtb3ZhbCBvZlxuICAgKi9cbiAgb25BY2NvdW50RGVsZXRlZChhY2NvdW50SWQpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmNhbmNlbEFjY291bnQoYWNjb3VudElkKTtcbiAgICB0aGlzLl9sYXRlbmN5U2VydmljZS5vblVuc3Vic2NyaWJlKGFjY291bnRJZCk7XG4gICAgY29uc3QgbWFzdGVyQWNjb3VudElkID0gdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFthY2NvdW50SWRdO1xuICAgIGlmKG1hc3RlckFjY291bnRJZCkge1xuICAgICAgaWYobWFzdGVyQWNjb3VudElkID09PSBhY2NvdW50SWQpIHtcbiAgICAgICAgY29uc3QgcmVnaW9uRGF0YSA9IHRoaXMuX2FjY291bnRSZXBsaWNhc1ttYXN0ZXJBY2NvdW50SWRdO1xuICAgICAgICBjb25zdCByZXBsaWNhcyA9IE9iamVjdC52YWx1ZXMocmVnaW9uRGF0YSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZSlcbiAgICAgICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7bWFzdGVyQWNjb3VudElkfWApKVxuICAgICAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VdKTtcbiAgICAgICAgcmVwbGljYXMuZm9yRWFjaChyZXBsaWNhID0+IHtcbiAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGluc3RhbmNlW3JlcGxpY2FdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW3JlcGxpY2FdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50UmVwbGljYXNbbWFzdGVyQWNjb3VudElkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgZGVsZXRlIGluc3RhbmNlW2FjY291bnRJZF07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpb25EYXRhID0gdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXTtcbiAgICAgICAgaWYocmVnaW9uRGF0YSkge1xuICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbkRhdGEucmVnaW9uO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZSlcbiAgICAgICAgICAgIC5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2Uuc3RhcnRzV2l0aChgJHttYXN0ZXJBY2NvdW50SWR9OiR7cmVnaW9ufWApKVxuICAgICAgICAgICAgLmZvckVhY2goaW5zdGFuY2UgPT4gZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZV0pO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50UmVwbGljYXNbbWFzdGVyQWNjb3VudElkXVtyZWdpb25dO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2FjY291bnRJZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdO1xuICAgICAgfVxuICBcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBRdWV1ZXMgYW4gYWNjb3VudCBwYWNrZXQgZm9yIHByb2Nlc3NpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBwYWNrZXQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgcXVldWVQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYWNjb3VudElkID0gcGFja2V0LmFjY291bnRJZDtcbiAgICBjb25zdCBwYWNrZXRzID0gdGhpcy5fcGFja2V0T3JkZXJlci5yZXN0b3JlT3JkZXIocGFja2V0KS5maWx0ZXIocCA9PiBwLnR5cGUgIT09ICdub29wJyk7XG4gICAgaWYodGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZyAmJiBwYWNrZXQuc2VxdWVuY2VOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZXZlbnRzID0gcGFja2V0cy5tYXAocGFja2V0SXRlbSA9PiAoKSA9PiBcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0SXRlbSkpKTtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSkge1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gZXZlbnRzO1xuICAgICAgICB0aGlzLl9jYWxsQWNjb3VudEV2ZW50cyhhY2NvdW50SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXSA9IHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0uY29uY2F0KGV2ZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldHMuZm9yRWFjaChwYWNrZXRJdGVtID0+IHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0SXRlbSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZXMgYWNjb3VudCBldmVudCBmb3IgcHJvY2Vzc2luZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZXZlbnQgbGFiZWwgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYWJsZSBhc3luYyBvciByZWd1bGFyIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICovXG4gIHF1ZXVlRXZlbnQoYWNjb3VudElkLCBuYW1lLCBjYWxsYWJsZSkge1xuICAgIGxldCBldmVudCA9ICgpID0+IHRoaXMuX3Byb2Nlc3NFdmVudChjYWxsYWJsZSwgYCR7YWNjb3VudElkfToke25hbWV9YCk7XG4gICAgaWYodGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZykge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7IFxuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gW2V2ZW50XTtcbiAgICAgICAgdGhpcy5fY2FsbEFjY291bnRFdmVudHMoYWNjb3VudElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0ucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2NhbGxBY2NvdW50RXZlbnRzKGFjY291bnRJZCkge1xuICAgIGlmKHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0pIHtcbiAgICAgIHdoaWxlKHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0ubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF1bMF0oKTtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXS5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHdoaWxlICghaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCAmJiAhaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgJiYgaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RyeVJlY29ubmVjdChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdHJ5UmVjb25uZWN0KGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgIGluc3RhbmNlLnJlY29ubmVjdFdhaXRUaW1lID0gTWF0aC5taW4oaW5zdGFuY2UucmVjb25uZWN0V2FpdFRpbWUgKiAyLCAzMDAwMCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCAmJiAhaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgJiYgaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2Vzc2lvbklkID0gcmFuZG9tc3RyaW5nLmdlbmVyYXRlKDMyKTtcbiAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmlvLm9wdHMuZXh0cmFIZWFkZXJzWydDbGllbnQtSWQnXSA9IGNsaWVudElkO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby5vcHRzLnF1ZXJ5LmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby51cmkgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJVcmwoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbik7XG4gICAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSwgaW5zdGFuY2UucmVjb25uZWN0V2FpdFRpbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0YW5lb3VzbHkgc2VuZHMgUlBDIHJlcXVlc3RzIHRvIGFsbCBzeW5jaHJvbml6ZWQgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgbWV0YXRyYWRlciBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGJhc2UgcmVxdWVzdCBkYXRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsaWFiaWxpdHldIGFjY291bnQgcmVsaWFiaWxpdHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSByZXF1ZXN0IHRpbWVvdXQgaW4gc2Vjb25kc1xuICAgKi9cbiAgYXN5bmMgcnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHJlcXVlc3QsIHJlbGlhYmlsaXR5LCB0aW1lb3V0SW5TZWNvbmRzKSAge1xuICAgIGlmKHJlbGlhYmlsaXR5ID09PSAnaGlnaCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhbnkoWzAsIDFdLm1hcChpbnN0YW5jZU51bWJlciA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QsIFxuICAgICAgICAgICAge2luc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSksIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvci5lcnJvcnNbMF07IFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgUlBDIHJlcXVlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBtZXRhdHJhZGVyIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgYmFzZSByZXF1ZXN0IGRhdGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0SW5TZWNvbmRzXSByZXF1ZXN0IHRpbWVvdXQgaW4gc2Vjb25kc1xuICAgKi9cbiAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHNcbiAgYXN5bmMgcnBjUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBpZ25vcmVkUmVxdWVzdFR5cGVzID0gWydzdWJzY3JpYmUnLCAnc3luY2hyb25pemUnLCAncmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zJywgJ3Vuc3Vic2NyaWJlJ107XG4gICAgY29uc3QgcHJpbWFyeUFjY291bnRJZCA9IHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbYWNjb3VudElkXTtcbiAgICBsZXQgY29ubmVjdGVkSW5zdGFuY2UgPSB0aGlzLl9sYXRlbmN5U2VydmljZS5nZXRBY3RpdmVBY2NvdW50SW5zdGFuY2VzKHByaW1hcnlBY2NvdW50SWQpWzBdO1xuICAgIGlmKCFpZ25vcmVkUmVxdWVzdFR5cGVzLmluY2x1ZGVzKHJlcXVlc3QudHlwZSkpIHtcbiAgICAgIGlmICghY29ubmVjdGVkSW5zdGFuY2Upe1xuICAgICAgICBjb25uZWN0ZWRJbnN0YW5jZSA9IGF3YWl0IHRoaXMuX2xhdGVuY3lTZXJ2aWNlLndhaXRDb25uZWN0ZWRJbnN0YW5jZShhY2NvdW50SWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlUmVnaW9uID0gY29ubmVjdGVkSW5zdGFuY2Uuc3BsaXQoJzonKVsxXTtcbiAgICAgIGFjY291bnRJZCA9IHRoaXMuX2FjY291bnRSZXBsaWNhc1twcmltYXJ5QWNjb3VudElkXVthY3RpdmVSZWdpb25dO1xuICAgIH1cbiAgICBsZXQgc29ja2V0SW5zdGFuY2VJbmRleCA9IG51bGw7XG4gICAgbGV0IGluc3RhbmNlTnVtYmVyID0gMDtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICB0aGlzLl9yZWZyZXNoQWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGlmKHJlcXVlc3QuaW5zdGFuY2VJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0YW5jZU51bWJlciA9IHJlcXVlc3QuaW5zdGFuY2VJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoY29ubmVjdGVkSW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2VOdW1iZXIgPSBOdW1iZXIoY29ubmVjdGVkSW5zdGFuY2Uuc3BsaXQoJzonKVsyXSk7XG4gICAgICB9XG4gICAgICBpZihyZXF1ZXN0LmFwcGxpY2F0aW9uICE9PSAnUlBDJykge1xuICAgICAgICByZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCwge2luc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKCF0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl0gPSB7fTtcbiAgICB9XG4gICAgaWYoIXRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dKSB7XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSA9IHt9O1xuICAgIH1cbiAgICBpZighdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdKSB7XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0gPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBjcmVhdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gUlBDIHJlcXVlc3RgKTtcbiAgICAgIGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgIGlmICghaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlTnVtYmVyfTogY29ubmVjdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gUlBDIHJlcXVlc3RgKTtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdChpbnN0YW5jZU51bWJlciwgcmVnaW9uKTtcbiAgICB9IGVsc2UgaWYoIXRoaXMuY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pKSB7XG4gICAgICBhd2FpdCBpbnN0YW5jZS5jb25uZWN0UmVzdWx0O1xuICAgIH1cbiAgICBpZihyZXF1ZXN0LnR5cGUgPT09ICdzdWJzY3JpYmUnKSB7XG4gICAgICByZXF1ZXN0LnNlc3Npb25JZCA9IGluc3RhbmNlLnNlc3Npb25JZDtcbiAgICB9XG4gICAgaWYoWyd0cmFkZScsICdzdWJzY3JpYmUnXS5pbmNsdWRlcyhyZXF1ZXN0LnR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVJlcXVlc3QoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICAgIGxldCByZXRyeUNvdW50ZXIgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9tYWtlUmVxdWVzdChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCByZXF1ZXN0LCB0aW1lb3V0SW5TZWNvbmRzKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGlmKGVyci5uYW1lID09PSAnVG9vTWFueVJlcXVlc3RzRXJyb3InKSB7XG4gICAgICAgICAgbGV0IGNhbGNSZXRyeUNvdW50ZXIgPSByZXRyeUNvdW50ZXI7XG4gICAgICAgICAgbGV0IGNhbGNSZXF1ZXN0VGltZSA9IDA7XG4gICAgICAgICAgd2hpbGUoY2FsY1JldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICAgIGNhbGNSZXRyeUNvdW50ZXIrKztcbiAgICAgICAgICAgIGNhbGNSZXF1ZXN0VGltZSArPSBNYXRoLm1pbihNYXRoLnBvdygyLCBjYWxjUmV0cnlDb3VudGVyKSAqIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMsXG4gICAgICAgICAgICAgIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMpICogMTAwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmV0cnlUaW1lID0gbmV3IERhdGUoZXJyLm1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgICAgaWYgKERhdGUubm93KCkgKyBjYWxjUmVxdWVzdFRpbWUgPiByZXRyeVRpbWUgJiYgcmV0cnlDb3VudGVyIDwgdGhpcy5fcmV0cmllcykge1xuICAgICAgICAgICAgaWYoRGF0ZS5ub3coKSA8IHJldHJ5VGltZSkge1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIHJldHJ5VGltZSAtIERhdGUubm93KCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5Q291bnRlcisrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoWydOb3RTeW5jaHJvbml6ZWRFcnJvcicsICdUaW1lb3V0RXJyb3InLCAnTm90QXV0aGVudGljYXRlZEVycm9yJyxcbiAgICAgICAgICAnSW50ZXJuYWxFcnJvciddLmluY2x1ZGVzKGVyci5uYW1lKSAmJiBcbiAgICAgICAgICByZXRyeUNvdW50ZXIgPCB0aGlzLl9yZXRyaWVzKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeUNvdW50ZXIpICogXG4gICAgICAgICAgICB0aGlzLl9taW5SZXRyeURlbGF5SW5TZWNvbmRzLCB0aGlzLl9tYXhSZXRyeURlbGF5SW5TZWNvbmRzKSAqIDEwMDApKTtcbiAgICAgICAgICByZXRyeUNvdW50ZXIrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX21ha2VSZXF1ZXN0KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgIGxldCByZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZCB8fCByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHJlcXVlc3QudGltZXN0YW1wcyA9IHtjbGllbnRQcm9jZXNzaW5nU3RhcnRlZDogbmV3IERhdGUoKX07XG4gICAgbGV0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzb2NrZXRJbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbcmVxdWVzdElkXSA9IFxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0LCB0eXBlOiByZXF1ZXN0LnR5cGV9KSxcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IFRpbWVvdXRFcnJvcihgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlcXVlc3QgJHtyZXF1ZXN0LnJlcXVlc3RJZH0gb2YgdHlwZSAke3JlcXVlc3QudHlwZX0gYCArXG4gICAgICAgICAgJ3RpbWVkIG91dC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGFjY291bnQgaXMgY29ubmVjdGVkIHRvIGJyb2tlciBiZWZvcmUgcmV0cnlpbmcgeW91ciByZXF1ZXN0LicpKTtcbiAgICAgICAgZGVsZXRlIHNvY2tldEluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tyZXF1ZXN0SWRdO1xuICAgICAgfSwgKHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB8fCB0aGlzLl9yZXF1ZXN0VGltZW91dCkpXG4gICAgXSk7XG4gICAgcmVxdWVzdC5hY2NvdW50SWQgPSBhY2NvdW50SWQ7XG4gICAgcmVxdWVzdC5hcHBsaWNhdGlvbiA9IHJlcXVlc3QuYXBwbGljYXRpb24gfHwgdGhpcy5fYXBwbGljYXRpb247XG4gICAgaWYgKCFyZXF1ZXN0LnJlcXVlc3RJZCkge1xuICAgICAgcmVxdWVzdC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnR5cGUgPT09ICd1bnN1YnNjcmliZScgfHwgcmVxdWVzdC5hcHBsaWNhdGlvbiA9PT0gJ1JQQycgfHxcbiAgICAgIHJlcXVlc3QuaW5zdGFuY2VJbmRleCA9PT0gc29ja2V0SW5zdGFuY2UuaW5zdGFuY2VOdW1iZXIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygoKSA9PiBgJHthY2NvdW50SWR9OiBTZW5kaW5nIHJlcXVlc3Q6ICR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdCl9YCk7XG4gICAgICBzb2NrZXRJbnN0YW5jZS5zb2NrZXQuZW1pdCgncmVxdWVzdCcsIHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke2FjY291bnRJZH06JHtyZXF1ZXN0Lmluc3RhbmNlSW5kZXh9OiBza2lwcGluZyByZXF1ZXN0IGJlY2F1c2UgaXQgaXMgYmVpbmcgc2VudCB0byBgICtcbiAgICAgICAgYHRoZSBzb2NrZXQgb2YgdGhlIHdyb25nIGluc3RhbmNlIGluZGV4LCByZXF1ZXN0PSR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdCl9YCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9jb252ZXJ0RXJyb3IoZGF0YSkge1xuICAgIGlmIChkYXRhLmVycm9yID09PSAnVmFsaWRhdGlvbkVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLmRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdOb3RTeW5jaHJvbml6ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90U3luY2hyb25pemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IFRpbWVvdXRFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEF1dGhlbnRpY2F0ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Q29ubmVjdGVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdGb3JiaWRkZW5FcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgRm9yYmlkZGVuRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUcmFkZUVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBUcmFkZUVycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5udW1lcmljQ29kZSwgZGF0YS5zdHJpbmdDb2RlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdVbmF1dGhvcml6ZWRFcnJvcicpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLm1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgX2NvbnZlcnRJc29UaW1lVG9EYXRlKHBhY2tldCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKGxldCBmaWVsZCBpbiBwYWNrZXQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBhY2tldFtmaWVsZF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBmaWVsZC5tYXRjaCgvdGltZSR8VGltZSQvKSAmJiBcbiAgICAgICAgIWZpZWxkLm1hdGNoKC9icm9rZXJUaW1lJHxCcm9rZXJUaW1lJHx0aW1lZnJhbWUkLykpIHtcbiAgICAgICAgcGFja2V0W2ZpZWxkXSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudGltZXN0YW1wcykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgZm9yIChsZXQgZmllbGQgaW4gcGFja2V0LnRpbWVzdGFtcHMpIHtcbiAgICAgICAgcGFja2V0LnRpbWVzdGFtcHNbZmllbGRdID0gbmV3IERhdGUocGFja2V0LnRpbWVzdGFtcHNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudHlwZSA9PT0gJ3ByaWNlcycpIHtcbiAgICAgIGZvciAobGV0IHByaWNlIG9mIHBhY2tldC5wcmljZXMgfHwgW10pIHtcbiAgICAgICAgaWYgKHByaWNlLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gcHJpY2UudGltZXN0YW1wcykge1xuICAgICAgICAgICAgcHJpY2UudGltZXN0YW1wc1tmaWVsZF0gPSBuZXcgRGF0ZShwcmljZS50aW1lc3RhbXBzW2ZpZWxkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgc3ltYm9sIHNwZWNpZmljYXRpb24uIENvbnRhaW5zIHN5bWJvbCBzcGVjaWZpY2F0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbi8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpY2tTaXplIHRpY2sgc2l6ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWluVm9sdW1lIG1pbmltdW0gb3JkZXIgdm9sdW1lIGZvciB0aGUgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhWb2x1bWUgbWF4aW11bSBvcmRlciB2b2x1bWUgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZvbHVtZVN0ZXAgb3JkZXIgdm9sdW1lIHN0ZXAgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtBcnJheTxTdHJpbmc+fSBsaXN0IG9mIGFsbG93ZWQgb3JkZXIgZmlsbGluZyBtb2Rlcy4gQ2FuIGNvbnRhaW4gT1JERVJfRklMTElOR19GT0ssIE9SREVSX0ZJTExJTkdfSU9DIG9yXG4gICAqIGJvdGguIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9maWxsaW5nX21vZGUgZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlYWwgZXhlY3V0aW9uIG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgU1lNQk9MX1RSQURFX0VYRUNVVElPTl9SRVFVRVNULFxuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0lOU1RBTlQsIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fTUFSS0VULCBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0VYQ0hBTkdFLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9leGVjdXRpb24gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRyYWN0U2l6ZSB0cmFkZSBjb250cmFjdCBzaXplXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSBxdW90ZVNlc3Npb25zIHF1b3RlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSB0cmFkZVNlc3Npb25zIHRyYWRlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdHJhZGVNb2RlXSBvcmRlciBleGVjdXRpb24gdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSBTWU1CT0xfVFJBREVfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1RSQURFX01PREVfTE9OR09OTFksIFNZTUJPTF9UUkFERV9NT0RFX1NIT1JUT05MWSwgU1lNQk9MX1RSQURFX01PREVfQ0xPU0VPTkxZLCBTWU1CT0xfVFJBREVfTU9ERV9GVUxMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtib25kQWNjcnVlZEludGVyZXN0XSBhY2NydWVkIGludGVyZXN0IOKAkyBhY2N1bXVsYXRlZCBjb3Vwb24gaW50ZXJlc3QsIGkuZS4gcGFydCBvZiB0aGUgY291cG9uXG4gICAqIGludGVyZXN0IGNhbGN1bGF0ZWQgaW4gcHJvcG9ydGlvbiB0byB0aGUgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIGNvdXBvbiBib25kIGlzc3VhbmNlIG9yIHRoZSBsYXN0IGNvdXBvbiBpbnRlcmVzdFxuICAgKiBwYXltZW50XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYm9uZEZhY2VWYWx1ZV0gZmFjZSB2YWx1ZSDigJMgaW5pdGlhbCBib25kIHZhbHVlIHNldCBieSB0aGUgaXNzdWVyXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbb3B0aW9uU3RyaWtlXSB0aGUgc3RyaWtlIHByaWNlIG9mIGFuIG9wdGlvbi4gVGhlIHByaWNlIGF0IHdoaWNoIGFuIG9wdGlvbiBidXllciBjYW4gYnV5IChpbiBhXG4gICAqIENhbGwgb3B0aW9uKSBvciBzZWxsIChpbiBhIFB1dCBvcHRpb24pIHRoZSB1bmRlcmx5aW5nIGFzc2V0LCBhbmQgdGhlIG9wdGlvbiBzZWxsZXIgaXMgb2JsaWdlZCB0byBzZWxsIG9yIGJ1eSB0aGVcbiAgICogYXBwcm9wcmlhdGUgYW1vdW50IG9mIHRoZSB1bmRlcmx5aW5nIGFzc2V0LlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW29wdGlvblByaWNlU2Vuc2l2aXR5XSBvcHRpb24vd2FycmFudCBzZW5zaXRpdml0eSBzaG93cyBieSBob3cgbWFueSBwb2ludHMgdGhlIHByaWNlIG9mIHRoZVxuICAgKiBvcHRpb24ncyB1bmRlcmx5aW5nIGFzc2V0IHNob3VsZCBjaGFuZ2Ugc28gdGhhdCB0aGUgcHJpY2Ugb2YgdGhlIG9wdGlvbiBjaGFuZ2VzIGJ5IG9uZSBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xpcXVpZGl0eVJhdGVdIGxpcXVpZGl0eSBSYXRlIGlzIHRoZSBzaGFyZSBvZiB0aGUgYXNzZXQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIG1hcmdpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaW5pdGlhbE1hcmdpbiBpbml0aWFsIG1hcmdpbiBtZWFucyB0aGUgYW1vdW50IGluIHRoZSBtYXJnaW4gY3VycmVuY3kgcmVxdWlyZWQgZm9yIG9wZW5pbmcgYVxuICAgKiBwb3NpdGlvbiB3aXRoIHRoZSB2b2x1bWUgb2Ygb25lIGxvdC4gSXQgaXMgdXNlZCBmb3IgY2hlY2tpbmcgYSBjbGllbnQncyBhc3NldHMgd2hlbiBoZSBvciBzaGUgZW50ZXJzIHRoZSBtYXJrZXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1haW50ZW5hbmNlTWFyZ2luIHRoZSBtYWludGVuYW5jZSBtYXJnaW4uIElmIGl0IGlzIHNldCwgaXQgc2V0cyB0aGUgbWFyZ2luIGFtb3VudCBpbiB0aGUgbWFyZ2luXG4gICAqIGN1cnJlbmN5IG9mIHRoZSBzeW1ib2wsIGNoYXJnZWQgZnJvbSBvbmUgbG90LiBJdCBpcyB1c2VkIGZvciBjaGVja2luZyBhIGNsaWVudCdzIGFzc2V0cyB3aGVuIGhpcy9oZXIgYWNjb3VudCBzdGF0ZVxuICAgKiBjaGFuZ2VzLiBJZiB0aGUgbWFpbnRlbmFuY2UgbWFyZ2luIGlzIGVxdWFsIHRvIDAsIHRoZSBpbml0aWFsIG1hcmdpbiBpcyB1c2VkXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWRnZWRNYXJnaW4gY29udHJhY3Qgc2l6ZSBvciBtYXJnaW4gdmFsdWUgcGVyIG9uZSBsb3Qgb2YgaGVkZ2VkIHBvc2l0aW9ucyAob3Bwb3NpdGVseSBkaXJlY3RlZFxuICAgKiBwb3NpdGlvbnMgb2Ygb25lIHN5bWJvbCkuIFR3byBtYXJnaW4gY2FsY3VsYXRpb24gbWV0aG9kcyBhcmUgcG9zc2libGUgZm9yIGhlZGdlZCBwb3NpdGlvbnMuIFRoZSBjYWxjdWxhdGlvbiBtZXRob2RcbiAgICogaXMgZGVmaW5lZCBieSB0aGUgYnJva2VyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2hlZGdlZE1hcmdpblVzZXNMYXJnZXJMZWddIGNhbGN1bGF0aW5nIGhlZGdpbmcgbWFyZ2luIHVzaW5nIHRoZSBsYXJnZXIgbGVnIChCdXkgb3IgU2VsbClcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1hcmdpbkN1cnJlbmN5IG1hcmdpbiBjdXJyZW5jeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJpY2VDYWxjdWxhdGlvbk1vZGUgY29udHJhY3QgcHJpY2UgY2FsY3VsYXRpb24gbW9kZS4gT25lIG9mIFNZTUJPTF9DQUxDX01PREVfVU5LTk9XTixcbiAgICogU1lNQk9MX0NBTENfTU9ERV9GT1JFWCwgU1lNQk9MX0NBTENfTU9ERV9GT1JFWF9OT19MRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9GVVRVUkVTLCBTWU1CT0xfQ0FMQ19NT0RFX0NGRCxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9DRkRJTkRFWCwgU1lNQk9MX0NBTENfTU9ERV9DRkRMRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9FWENIX1NUT0NLUyxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9FWENIX0ZVVFVSRVMsIFNZTUJPTF9DQUxDX01PREVfRVhDSF9GVVRVUkVTX0ZPUlRTLCBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfQk9ORFMsXG4gICAqIFNZTUJPTF9DQUxDX01PREVfRVhDSF9TVE9DS1NfTU9FWCwgU1lNQk9MX0NBTENfTU9ERV9FWENIX0JPTkRTX01PRVgsIFNZTUJPTF9DQUxDX01PREVfU0VSVl9DT0xMQVRFUkFMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9jYWxjX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYmFzZUN1cnJlbmN5IGJhc2UgY3VycmVuY3lcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcm9maXRDdXJyZW5jeV0gcHJvZml0IGN1cnJlbmN5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzd2FwTW9kZSBzd2FwIGNhbGN1bGF0aW9uIG1vZGVsLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX1NXQVBfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9QT0lOVFMsIFNZTUJPTF9TV0FQX01PREVfQ1VSUkVOQ1lfU1lNQk9MLCBTWU1CT0xfU1dBUF9NT0RFX0NVUlJFTkNZX01BUkdJTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9DVVJSRU5DWV9ERVBPU0lULCBTWU1CT0xfU1dBUF9NT0RFX0lOVEVSRVNUX0NVUlJFTlQsIFNZTUJPTF9TV0FQX01PREVfSU5URVJFU1RfT1BFTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQ1VSUkVOVCwgU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQklELiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9zd2FwX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBMb25nXSBsb25nIHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzd2FwU2hvcnRdIHNob3J0IHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzd2FwUm9sbG92ZXIzRGF5c10gZGF5IG9mIHdlZWsgdG8gY2hhcmdlIDMgZGF5cyBzd2FwIHJvbGxvdmVyLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1VOREFZLFxuICAgKiBNT05EQVksIFRVRVNEQVksIFdFRE5FU0RBWSwgVEhVUkRBWSwgRlJJREFZLCBTQVRVUkRBWSwgTk9ORVxuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IGFsbG93ZWRFeHBpcmF0aW9uTW9kZXMgYWxsb3dlZCBvcmRlciBleHBpcmF0aW9uIG1vZGVzLiBBbGxvd2VkIHZhbHVlcyBhcmVcbiAgICogU1lNQk9MX0VYUElSQVRJT05fR1RDLCBTWU1CT0xfRVhQSVJBVElPTl9EQVksIFNZTUJPTF9FWFBJUkFUSU9OX1NQRUNJRklFRCwgU1lNQk9MX0VYUElSQVRJT05fU1BFQ0lGSUVEX0RBWS5cbiAgICogU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjc3ltYm9sX2V4cGlyYXRpb25fbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gYWxsb3dlZE9yZGVyVHlwZXMgYWxsb3dlZCBvcmRlciB0eXBlcy4gQWxsb3dlZCB2YWx1ZXMgYXJlIFNZTUJPTF9PUkRFUl9NQVJLRVQsXG4gICAqIFNZTUJPTF9PUkRFUl9MSU1JVCwgU1lNQk9MX09SREVSX1NUT1AsIFNZTUJPTF9PUkRFUl9TVE9QX0xJTUlULCBTWU1CT0xfT1JERVJfU0wsIFNZTUJPTF9PUkRFUl9UUCxcbiAgICogU1lNQk9MX09SREVSX0NMT1NFQlkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9vcmRlcl9tb2RlIGZvciBtb3JlIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yZGVyR1RDTW9kZSBpZiB0aGUgZXhwaXJhdGlvbk1vZGUgcHJvcGVydHkgaXMgc2V0IHRvIFNZTUJPTF9FWFBJUkFUSU9OX0dUQyAoZ29vZCB0aWxsXG4gICAqIGNhbmNlbGVkKSwgdGhlIGV4cGlyYXRpb24gb2YgcGVuZGluZyBvcmRlcnMsIGFzIHdlbGwgYXMgb2YgU3RvcCBMb3NzL1Rha2UgUHJvZml0IG9yZGVycyBzaG91bGQgYmUgYWRkaXRpb25hbGx5IHNldFxuICAgKiB1c2luZyB0aGlzIGVudW1lcmF0aW9uLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX09SREVSU19HVEMsIFNZTUJPTF9PUkRFUlNfREFJTFksXG4gICAqIFNZTUJPTF9PUkRFUlNfREFJTFlfRVhDTFVESU5HX1NUT1BTLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9vcmRlcl9ndGNfbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaWdpdHMgZGlnaXRzIGFmdGVyIGEgZGVjaW1hbCBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcG9pbnQgcG9pbnQgc2l6ZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3BhdGhdIHBhdGggaW4gdGhlIHN5bWJvbCB0cmVlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBzeW1ib2wgZGVzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtEYXRlfSBbc3RhcnRUaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgYmVnaW5uaW5nICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW2V4cGlyYXRpb25UaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgZW5kICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGlwU2l6ZV0gc2l6ZSBvZiBhIHBpcC4gUGlwIHNpemUgaXMgZGVmaW5lZCBmb3Igc3BvdCBhbmQgQ0ZEIHN5bWJvbHMgb25seVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RvcHNMZXZlbCBtaW5pbWFsIGRpc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgbWFya2V0IHByaWNlIHRvIHN0b3AgcHJpY2UgKFNMLCBUUCwgb3BlbiBwcmljZSkgaW5cbiAgICogcG9pbnRzLiBUaGUgU0wsIFRQLCBvcGVuIHByaWNlIGNhbiBub3QgYmUgcGxhY2VkIGNsb3NlciB0byBtYXJrZXQgcHJpY2UgdGhhbiB0aGlzIGRpc3RhbmNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmVlemVMZXZlbCBkaXN0YW5jZSBpbiBwb2ludHMgZnJvbSBtYXJrZXQgcHJpY2UgdG8gcGVuZGluZyBvcmRlciBvcGVuIHByaWNlIHRvIGZyZWV6ZSB1cGRhdGVzXG4gICAqIG9uIHRoZSBwZW5kaW5nIG9yZGVyLiBJZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBvcmRlciBvcGVuIHByaWNlIGFuZCBjdXJyZW50IG1hcmtldCBwcmljZSBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZSxcbiAgICogdGhlbiB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIG1vZGlmeSB0aGUgcGVuZGluZyBvcmRlclxuICAgKi9cblxuICAvKipcbiAgICogTWV0YXRyYWRlciB0cmFkZSBvciBxdW90ZSBzZXNzaW9uIGNvbnRhaW5lciwgaW5kZXhlZCBieSB3ZWVrZGF5XG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTZXNzaW9uc1xuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1NVTkRBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFNVTkRBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW01PTkRBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIE1PTkRBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1RVRVNEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBUVUVTREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbV0VETkVTREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgV0VETkVTREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbVEhVUlNEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBUSFVSU0RBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW0ZSSURBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIEZSSURBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1NBVFVSREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgU0FUVVJEQVlcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGF0cmFkZXIgdHJhZGUgb3IgcXVvdGUgc2Vzc2lvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyU2Vzc2lvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnJvbSBzZXNzaW9uIHN0YXJ0IHRpbWUsIGluIGhoLm1tLnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHRvIHNlc3Npb24gZW5kIHRpbWUsIGluIGhoLm1tLnNzLlNTUyBmb3JtYXRcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgc3ltYm9sIHByaWNlLiBDb250YWlucyBjdXJyZW50IHByaWNlIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWV0YXRyYWRlclN5bWJvbFByaWNlLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclN5bWJvbFByaWNlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJpZCBiaWQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzayBhc2sgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByb2ZpdFRpY2tWYWx1ZSB0aWNrIHZhbHVlIGZvciBhIHByb2ZpdGFibGUgcG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvc3NUaWNrVmFsdWUgdGljayB2YWx1ZSBmb3IgYSBsb3NpbmcgcG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSBxdW90ZSB0aW1lLCBpbiBJU08gZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXJUaW1lIHRpbWUgcXVvdGUgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgY2FuZGxlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJDYW5kbGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVmcmFtZSB0aW1lZnJhbWUgY2FuZGxlIHdhcyBnZW5lcmF0ZWQgZm9yLCBlLmcuIDFoLiBPbmUgb2YgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sXG4gICAqIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW5cbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIGNhbmRsZSBvcGVuaW5nIHRpbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJyb2tlclRpbWUgY2FuZGxlIG9wZW5pbmcgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG9wZW4gb3BlbiBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBoaWdoIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgbG93IHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjbG9zZSBjbG9zZSBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdGlja1ZvbHVtZSB0aWNrIHZvbHVtZSwgaS5lLiBudW1iZXIgb2YgdGlja3MgaW5zaWRlIHRoZSBjYW5kbGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNwcmVhZCBzcHJlYWQgaW4gcG9pbnRzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b2x1bWUgdHJhZGUgdm9sdW1lXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHRpY2sgZGF0YVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyVGlja1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBicm9rZXJUaW1lIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmlkXSBiaWQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFthc2tdIGFzayBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RdIGxhc3QgZGVhbCBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZvbHVtZV0gdm9sdW1lIGZvciB0aGUgY3VycmVudCBsYXN0IGRlYWwgcHJpY2VcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZGUgaXMgdGljayBhIHJlc3VsdCBvZiBidXkgb3Igc2VsbCBkZWFsLCBvbmUgb2YgYnV5IG9yIHNlbGxcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgb3JkZXIgYm9va1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyQm9va1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBicm9rZXJUaW1lIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlckJvb2tFbnRyeT59IGJvb2sgbGlzdCBvZiBvcmRlciBib29rIGVudHJpZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgb3JkZXIgYm9vayBlbnRyeVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyQm9va0VudHJ5XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIGVudHJ5IHR5cGUsIG9uZSBvZiBCT09LX1RZUEVfU0VMTCwgQk9PS19UWVBFX0JVWSwgQk9PS19UWVBFX1NFTExfTUFSS0VULFxuICAgKiBCT09LX1RZUEVfQlVZX01BUktFVFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJpY2UgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSB2b2x1bWVcbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHNcbiAgYXN5bmMgX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnN0YW5jZU51bWJlciA9IGRhdGEuaW5zdGFuY2VJbmRleCB8fCAwO1xuICAgICAgY29uc3Qgc29ja2V0SW5zdGFuY2UgPSB0aGlzLl9nZXRTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgc29ja2V0SW5zdGFuY2UpIHtcbiAgICAgICAgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnVwZGF0ZVN5bmNocm9uaXphdGlvbklkKGRhdGEuc3luY2hyb25pemF0aW9uSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRBY2NvdW50UmVnaW9uKGRhdGEuYWNjb3VudElkKTtcbiAgICAgIGNvbnN0IHByaW1hcnlBY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2RhdGEuYWNjb3VudElkXTtcbiAgICAgIGxldCBpbnN0YW5jZUlkID0gdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtkYXRhLmFjY291bnRJZF0gKyAnOicgKyBcbiAgICAgICAgcmVnaW9uICsgJzonICsgaW5zdGFuY2VOdW1iZXIgKyAnOicgKyAoZGF0YS5ob3N0IHx8IDApO1xuICAgICAgbGV0IGluc3RhbmNlSW5kZXggPSByZWdpb24gKyAnOicgKyBpbnN0YW5jZU51bWJlciArICc6JyArIChkYXRhLmhvc3QgfHwgMCk7XG5cbiAgICAgIGNvbnN0IGlzT25seUFjdGl2ZUluc3RhbmNlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBhY3RpdmVJbnN0YW5jZUlkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2Nvbm5lY3RlZEhvc3RzKS5maWx0ZXIoaW5zdGFuY2UgPT4gXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhcnRzV2l0aChwcmltYXJ5QWNjb3VudElkICsgJzonICsgcmVnaW9uICsgJzonICsgaW5zdGFuY2VOdW1iZXIpKTtcbiAgICAgICAgcmV0dXJuICFhY3RpdmVJbnN0YW5jZUlkcy5sZW5ndGggfHwgYWN0aXZlSW5zdGFuY2VJZHMubGVuZ3RoID09PSAxICYmIGFjdGl2ZUluc3RhbmNlSWRzWzBdID09PSBpbnN0YW5jZUlkO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY2FuY2VsRGlzY29ubmVjdFRpbWVyID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc2V0RGlzY29ubmVjdFRpbWVyID0gKCkgPT4ge1xuICAgICAgICBjYW5jZWxEaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgdGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzT25seUFjdGl2ZUluc3RhbmNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25UaW1lb3V0KGRhdGEuYWNjb3VudElkLCAwKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25UaW1lb3V0KGRhdGEuYWNjb3VudElkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5xdWV1ZUV2ZW50KHByaW1hcnlBY2NvdW50SWQsIGAke2luc3RhbmNlSW5kZXh9Om9uRGlzY29ubmVjdGVkYCwgKCkgPT4gb25EaXNjb25uZWN0ZWQodHJ1ZSkpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0pO1xuICAgICAgICB9LCA2MDAwMCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgICAgY29uc3Qgb25EaXNjb25uZWN0ZWQgPSBhc3luYyAoaXNUaW1lb3V0ID0gZmFsc2UpID0+IHsgXG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWRIb3N0c1tpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLm9uRGlzY29ubmVjdGVkKGluc3RhbmNlSWQpO1xuICAgICAgICAgIGlmIChpc09ubHlBY3RpdmVJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uRGlzY29ubmVjdGVkKGluc3RhbmNlSW5kZXgpLFxuICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25EaXNjb25uZWN0ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcGFja2V0T3JkZXJlci5vblN0cmVhbUNsb3NlZChpbnN0YW5jZUlkKTtcbiAgICAgICAgICBpZiAoc29ja2V0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHNvY2tldEluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci5yZW1vdmVJZEJ5UGFyYW1ldGVycyhkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIGRhdGEuaG9zdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN0cmVhbUNsb3NlZChpbnN0YW5jZUluZGV4KSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN0cmVhbUNsb3NlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgaWYgKGlzT25seUFjdGl2ZUluc3RhbmNlKCkgJiYgIWlzVGltZW91dCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5vbkRpc2Nvbm5lY3RlZChkYXRhLmFjY291bnRJZCwgMCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKGRhdGEuYWNjb3VudElkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnYXV0aGVudGljYXRlZCcpIHtcbiAgICAgICAgcmVzZXREaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgaWYoKCFkYXRhLnNlc3Npb25JZCkgfHwgc29ja2V0SW5zdGFuY2UgJiYgKGRhdGEuc2Vzc2lvbklkID09PSBzb2NrZXRJbnN0YW5jZS5zZXNzaW9uSWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uub25Db25uZWN0ZWQoaW5zdGFuY2VJZCk7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0gPSBkYXRhLmhvc3Q7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQ29ubmVjdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEucmVwbGljYXMpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQ29ubmVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIGlmKGRhdGEucmVwbGljYXMgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsQWNjb3VudChkYXRhLmFjY291bnRJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIGNhbmNlbERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICBhd2FpdCBvbkRpc2Nvbm5lY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzeW5jaHJvbml6YXRpb25TdGFydGVkJykge1xuICAgICAgICB0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF0gPSBbXTtcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0gPSB7XG4gICAgICAgICAgYWNjb3VudElkOiBkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsXG4gICAgICAgICAgc3BlY2lmaWNhdGlvbnNVcGRhdGVkOiBkYXRhLnNwZWNpZmljYXRpb25zSGFzaEluZGV4ID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgcG9zaXRpb25zVXBkYXRlZDogZGF0YS5wb3NpdGlvbnNIYXNoSW5kZXggPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICBvcmRlcnNVcGRhdGVkOiBkYXRhLm9yZGVyc0hhc2hJbmRleCA9PT0gdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSA9IGRhdGEuc3luY2hyb25pemF0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb25zSGFzaCA9IChkYXRhLnNwZWNpZmljYXRpb25zSGFzaEluZGV4ICE9PSB1bmRlZmluZWQpID8gXG4gICAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXVxuICAgICAgICAgICAgLnNwZWNpZmljYXRpb25zSGFzaGVzW2RhdGEuc3BlY2lmaWNhdGlvbnNIYXNoSW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnNIYXNoID0gKGRhdGEucG9zaXRpb25zSGFzaEluZGV4ICE9PSB1bmRlZmluZWQpID8gXG4gICAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5wb3NpdGlvbnNIYXNoZXNbZGF0YS5wb3NpdGlvbnNIYXNoSW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvcmRlcnNIYXNoID0gKGRhdGEub3JkZXJzSGFzaEluZGV4ICE9PSB1bmRlZmluZWQpID8gXG4gICAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5vcmRlcnNIYXNoZXNbZGF0YS5vcmRlcnNIYXNoSW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLFxuICAgICAgICAgICAgICBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBkYXRhLnN5bmNocm9uaXphdGlvbklkKSxcbiAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW5jaHJvbml6YXRpb25TdGFydGVkYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnYWNjb3VudEluZm9ybWF0aW9uJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSxcbiAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZGAsIHRydWUpO1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5wb3NpdGlvbnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICAgJ2Fib3V0IGFjY291bnRJbmZvcm1hdGlvbiBldmVudCcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ucG9zaXRpb25zVXBkYXRlZCAmJiBcbiAgICAgICAgICAgICAgIXRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdLm9yZGVyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZGVhbHMnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBkZWFsIG9mIChkYXRhLmRlYWxzIHx8IFtdKSkge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkRlYWxBZGRlZChpbnN0YW5jZUluZGV4LCBkZWFsKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkRlYWxBZGRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdvcmRlcnMnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNSZXBsYWNlZChpbnN0YW5jZUluZGV4LCBkYXRhLm9yZGVycyB8fCBbXSksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzUmVwbGFjZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZGAsIHRydWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IEZhaWxlZCB0byBub3RpZnkgbGlzdGVuZXIgYCArXG4gICAgICAgICAgICAgICdhYm91dCBvcmRlcnMgZXZlbnQnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdoaXN0b3J5T3JkZXJzJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaGlzdG9yeU9yZGVyIG9mIChkYXRhLmhpc3RvcnlPcmRlcnMgfHwgW10pKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQoaW5zdGFuY2VJbmRleCwgaGlzdG9yeU9yZGVyKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhpc3RvcnlPcmRlckFkZGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3Bvc2l0aW9ucycpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5wb3NpdGlvbnMgfHwgW10pLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zUmVwbGFjZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25Qb3NpdGlvbnNTeW5jaHJvbml6ZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJlxuICAgICAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgJ2Fib3V0IHBvc2l0aW9ucyBldmVudCcsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdICYmIFxuICAgICAgICAgICF0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5vcmRlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgICAgaWYodGhpcy5fdXBkYXRlRXZlbnRzW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlRXZlbnRzW2luc3RhbmNlSWRdLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLmFjY291bnRJbmZvcm1hdGlvbiksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQb3NpdGlvbnMgPSBkYXRhLnVwZGF0ZWRQb3NpdGlvbnMgfHwgW107XG4gICAgICAgIGNvbnN0IHJlbW92ZWRQb3NpdGlvbklkcyA9IGRhdGEucmVtb3ZlZFBvc2l0aW9uSWRzIHx8IFtdO1xuICAgICAgICBpZih1cGRhdGVkUG9zaXRpb25zLmxlbmd0aCB8fCByZW1vdmVkUG9zaXRpb25JZHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCB1cGRhdGVkUG9zaXRpb25zLCByZW1vdmVkUG9zaXRpb25JZHMpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiBvZiB1cGRhdGVkUG9zaXRpb25zKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBvc2l0aW9uVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbklkIG9mIHJlbW92ZWRQb3NpdGlvbklkcykge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBvc2l0aW9uUmVtb3ZlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbklkKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBvc2l0aW9uUmVtb3ZlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXJzID0gZGF0YS51cGRhdGVkT3JkZXJzIHx8IFtdO1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRPcmRlcklkcyA9IGRhdGEuY29tcGxldGVkT3JkZXJJZHMgfHwgW107XG4gICAgICAgIGlmKHVwZGF0ZWRPcmRlcnMubGVuZ3RoIHx8IGNvbXBsZXRlZE9yZGVySWRzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHVwZGF0ZWRPcmRlcnMsIGNvbXBsZXRlZE9yZGVySWRzKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBlbmRpbmdPcmRlcnNVcGRhdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9yZGVyIG9mIHVwZGF0ZWRPcmRlcnMpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJVcGRhdGVkKGluc3RhbmNlSW5kZXgsIG9yZGVyKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBlbmRpbmdPcmRlclVwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgb3JkZXJJZCBvZiBjb21wbGV0ZWRPcmRlcklkcykge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBlbmRpbmdPcmRlckNvbXBsZXRlZChpbnN0YW5jZUluZGV4LCBvcmRlcklkKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBlbmRpbmdPcmRlckNvbXBsZXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoaXN0b3J5T3JkZXIgb2YgKGRhdGEuaGlzdG9yeU9yZGVycyB8fCBbXSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25IaXN0b3J5T3JkZXJBZGRlZChpbnN0YW5jZUluZGV4LCBoaXN0b3J5T3JkZXIpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uSGlzdG9yeU9yZGVyQWRkZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZGVhbCBvZiAoZGF0YS5kZWFscyB8fCBbXSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25EZWFsQWRkZWQoaW5zdGFuY2VJbmRleCwgZGVhbCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25EZWFsQWRkZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudGltZXN0YW1wcykge1xuICAgICAgICAgIGRhdGEudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uVXBkYXRlKGRhdGEuYWNjb3VudElkLCBkYXRhLnRpbWVzdGFtcHMpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uVXBkYXRlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2RlYWxTeW5jaHJvbml6YXRpb25GaW5pc2hlZCcpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uub25EZWFsc1N5bmNocm9uaXplZChpbnN0YW5jZUlkKTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgaWYoc29ja2V0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHNvY2tldEluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci5yZW1vdmVTeW5jaHJvbml6YXRpb25JZChkYXRhLnN5bmNocm9uaXphdGlvbklkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25EZWFsc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBkYXRhLnN5bmNocm9uaXphdGlvbklkKSxcbiAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25EZWFsc1N5bmNocm9uaXplZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXSA9IHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXS5tYXAocGFja2V0ID0+ICgpID0+IFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0KSkpO1xuICAgICAgICAgIGlmICh0aGlzLl9ldmVudFF1ZXVlc1twcmltYXJ5QWNjb3VudElkXSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbcHJpbWFyeUFjY291bnRJZF0gPVxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF0uY29uY2F0KHRoaXMuX2V2ZW50UXVldWVzW3ByaW1hcnlBY2NvdW50SWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW3ByaW1hcnlBY2NvdW50SWRdID0gdGhpcy5fdXBkYXRlRXZlbnRzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxBY2NvdW50RXZlbnRzKHByaW1hcnlBY2NvdW50SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdvcmRlclN5bmNocm9uaXphdGlvbkZpbmlzaGVkJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBpZih0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0gJiYgZGF0YS5hdXRoZW50aWNhdGVkICYmIFxuICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc0Rpc2Nvbm5lY3RlZFJldHJ5TW9kZShkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHx8IFxuICAgICAgICAgICAgICAhdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc0FjY291bnRTdWJzY3JpYmluZyhkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5jYW5jZWxTdWJzY3JpYmUoZGF0YS5hY2NvdW50SWQgKyAnOicgKyBpbnN0YW5jZU51bWJlcik7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDEwKSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oJ2l0IHNlZW1zIGxpa2Ugd2UgYXJlIG5vdCBjb25uZWN0ZWQgdG8gYSBydW5uaW5nIEFQSSAnICtcbiAgICAgICAgICAgICAgJ3NlcnZlciB5ZXQsIHJldHJ5aW5nIHN1YnNjcmlwdGlvbiBmb3IgYWNjb3VudCAnICsgaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVN1YnNjcmliZShkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkKGluc3RhbmNlSW5kZXgsICEhZGF0YS5jb25uZWN0ZWQpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuaGVhbHRoU3RhdHVzKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uSGVhbHRoU3RhdHVzKGluc3RhbmNlSW5kZXgsIGRhdGEuaGVhbHRoU3RhdHVzKSxcbiAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uSGVhbHRoU3RhdHVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2Rvd25ncmFkZVN1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogTWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3Igc3ltYm9sIGAgK1xuICAgICAgICAgIGAke2RhdGEuc3ltYm9sfSB3ZXJlIGRvd25ncmFkZWQgYnkgdGhlIHNlcnZlciBkdWUgdG8gcmF0ZSBsaW1pdHMuIFVwZGF0ZWQgc3Vic2NyaXB0aW9uczogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoZGF0YS51cGRhdGVzKX0sIHJlbW92ZWQgc3Vic2NyaXB0aW9uczogJHtKU09OLnN0cmluZ2lmeShkYXRhLnVuc3Vic2NyaXB0aW9ucyl9LiBgICtcbiAgICAgICAgICAnUGxlYXNlIHJlYWQgaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3JhdGVMaW1pdGluZy8gZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3ltYm9sLCBkYXRhLnVwZGF0ZXMsIGRhdGEudW5zdWJzY3JpcHRpb25zKSxcbiAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnc3BlY2lmaWNhdGlvbnMnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnNwZWNpZmljYXRpb25zIHx8IFtdLFxuICAgICAgICAgICAgICBkYXRhLnJlbW92ZWRTeW1ib2xzIHx8IFtdKSwgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNwZWNpZmljYXRpb24gb2YgKGRhdGEuc3BlY2lmaWNhdGlvbnMgfHwgW10pKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbiksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCByZW1vdmVkU3ltYm9sIG9mIChkYXRhLnJlbW92ZWRTeW1ib2xzIHx8IFtdKSkge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkKGluc3RhbmNlSW5kZXgsIHJlbW92ZWRTeW1ib2wpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3ltYm9sU3BlY2lmaWNhdGlvblJlbW92ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAncHJpY2VzJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByaWNlcyA9IGRhdGEucHJpY2VzIHx8IFtdO1xuICAgICAgICBsZXQgY2FuZGxlcyA9IGRhdGEuY2FuZGxlcyB8fCBbXTtcbiAgICAgICAgbGV0IHRpY2tzID0gZGF0YS50aWNrcyB8fCBbXTtcbiAgICAgICAgbGV0IGJvb2tzID0gZGF0YS5ib29rcyB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgaWYgKHByaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TeW1ib2xQcmljZXNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHByaWNlcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLCBkYXRhLmZyZWVNYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3ltYm9sUHJpY2VzVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25DYW5kbGVzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBjYW5kbGVzLCBkYXRhLmVxdWl0eSwgZGF0YS5tYXJnaW4sIGRhdGEuZnJlZU1hcmdpbixcbiAgICAgICAgICAgICAgICBkYXRhLm1hcmdpbkxldmVsLCBkYXRhLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25DYW5kbGVzVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGlja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uVGlja3NVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHRpY2tzLCBkYXRhLmVxdWl0eSwgZGF0YS5tYXJnaW4sIGRhdGEuZnJlZU1hcmdpbixcbiAgICAgICAgICAgICAgICBkYXRhLm1hcmdpbkxldmVsLCBkYXRhLmFjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZSksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25UaWNrc1VwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJvb2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkJvb2tzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBib29rcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLCBkYXRhLmZyZWVNYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQm9va3NVcGRhdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByaWNlIG9mIHByaWNlcykge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFByaWNlVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZSksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW1ib2xQcmljZVVwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJpY2Ugb2YgcHJpY2VzKSB7XG4gICAgICAgICAgaWYgKHByaWNlLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIHByaWNlLnRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ0ZpbmlzaGVkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgfHwgW10pIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3ltYm9sUHJpY2UoZGF0YS5hY2NvdW50SWQsIHByaWNlLnN5bWJvbCwgcHJpY2UudGltZXN0YW1wcyksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFByaWNlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIGluY29taW5nIHN5bmNocm9uaXphdGlvbiBwYWNrZXQnLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9wcm9jZXNzRXZlbnQoY2FsbGFibGUsIGxhYmVsLCB0aHJvd0Vycm9yKSB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaXNMb25nRXZlbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNFdmVudERvbmUgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoZWNrTG9uZ0V2ZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICBpZiAoIWlzRXZlbnREb25lKSB7XG4gICAgICAgIGlzTG9uZ0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7bGFiZWx9OiBldmVudCBpcyB0YWtpbmcgbW9yZSB0aGFuIDEgc2Vjb25kIHRvIHByb2Nlc3NgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tMb25nRXZlbnQoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2FsbGFibGUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0aHJvd0Vycm9yKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtsYWJlbH06IGV2ZW50IGZhaWxlZCB3aXRoIGVycm9yYCwgZXJyKTtcbiAgICB9XG4gICAgaXNFdmVudERvbmUgPSB0cnVlO1xuICAgIGlmIChpc0xvbmdFdmVudCkge1xuICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7bGFiZWx9OiBmaW5pc2hlZCBpbiAke01hdGguZmxvb3IoKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMCl9IHNlY29uZHNgKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZmlyZVJlY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9yZWNvbm5lY3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2xpc3RlbmVyLmFjY291bnRJZF0gPT09IHNvY2tldEluc3RhbmNlSW5kZXggJiYgXG4gICAgICAgICAgdGhpcy5nZXRBY2NvdW50UmVnaW9uKGxpc3RlbmVyLmFjY291bnRJZCkgPT09IHJlZ2lvbikge1xuICAgICAgICAgIHJlY29ubmVjdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXModGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3MpLmZvckVhY2goc3luY2hyb25pemF0aW9uSWQgPT4ge1xuICAgICAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tzeW5jaHJvbml6YXRpb25JZF0uYWNjb3VudElkO1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gc29ja2V0SW5zdGFuY2VJbmRleFxuICAgICAgICAgICAgJiYgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3Nbc3luY2hyb25pemF0aW9uSWRdLmluc3RhbmNlTnVtYmVyID09PSBpbnN0YW5jZU51bWJlclxuICAgICAgICAgICAgJiYgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXVxuICAgICAgICAgICAgJiYgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXS5yZWdpb24gPT09IHJlZ2lvbikge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tzeW5jaHJvbml6YXRpb25JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVjb25uZWN0QWNjb3VudElkcyA9IHJlY29ubmVjdExpc3RlbmVycy5tYXAobGlzdGVuZXIgPT4gbGlzdGVuZXIuYWNjb3VudElkKTtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25SZWNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVjb25uZWN0QWNjb3VudElkcyk7XG4gICAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLm9uUmVjb25uZWN0ZWQocmVjb25uZWN0QWNjb3VudElkcyk7XG5cbiAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHJlY29ubmVjdExpc3RlbmVycykge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUobGlzdGVuZXIubGlzdGVuZXIub25SZWNvbm5lY3RlZChyZWdpb24sIGluc3RhbmNlTnVtYmVyKSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIG5vdGlmeSByZWNvbm5lY3QgbGlzdGVuZXInLCBlcnIpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgcmVjb25uZWN0ZWQgZXZlbnQnLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRBY2NvdW50UmVnaW9uKGFjY291bnRJZCk7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVt0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdXTtcbiAgfVxuXG4gIGFzeW5jIGdldFVybFNldHRpbmdzKGluc3RhbmNlTnVtYmVyLCByZWdpb24pIHtcbiAgICBpZih0aGlzLl91cmwpIHtcbiAgICAgIHJldHVybiB7dXJsOiB0aGlzLl91cmwsIGlzU2hhcmVkQ2xpZW50QXBpOiB0cnVlfTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmxTZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2RvbWFpbkNsaWVudC5nZXRTZXR0aW5ncygpO1xuICAgIGNvbnN0IGdldFVybCA9IChob3N0bmFtZSkgPT4gXG4gICAgICBgaHR0cHM6Ly8ke2hvc3RuYW1lfS4ke3JlZ2lvbn0tJHtTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgTnVtYmVyKGluc3RhbmNlTnVtYmVyKSl9LiR7dXJsU2V0dGluZ3MuZG9tYWlufWA7XG5cbiAgICBsZXQgdXJsO1xuICAgIGlmKHRoaXMuX3VzZVNoYXJlZENsaWVudEFwaSkge1xuICAgICAgdXJsID0gZ2V0VXJsKHRoaXMuX2hvc3RuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gZ2V0VXJsKHVybFNldHRpbmdzLmhvc3RuYW1lKTtcbiAgICB9XG4gICAgY29uc3QgaXNTaGFyZWRDbGllbnRBcGkgPSB1cmwgPT09IGdldFVybCh0aGlzLl9ob3N0bmFtZSk7XG4gICAgcmV0dXJuIHt1cmwsIGlzU2hhcmVkQ2xpZW50QXBpfTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIF9nZXRTZXJ2ZXJVcmwoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGlmKHRoaXMuX3VybCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG5cbiAgICB3aGlsZSh0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XS5jb25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybFNldHRpbmdzID0gYXdhaXQgdGhpcy5nZXRVcmxTZXR0aW5ncyhpbnN0YW5jZU51bWJlciwgcmVnaW9uKTtcbiAgICAgICAgY29uc3QgdXJsID0gdXJsU2V0dGluZ3MudXJsO1xuICAgICAgICBjb25zdCBpc1NoYXJlZENsaWVudEFwaSA9IHVybFNldHRpbmdzLmlzU2hhcmVkQ2xpZW50QXBpO1xuICAgICAgICBsZXQgbG9nTWVzc2FnZSA9ICdDb25uZWN0aW5nIE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCB0byB0aGUgTWV0YUFwaSBzZXJ2ZXIgJyArXG4gICAgICBgdmlhICR7dXJsfSAke2lzU2hhcmVkQ2xpZW50QXBpID8gJ3NoYXJlZCcgOiAnZGVkaWNhdGVkJ30gc2VydmVyLmA7XG4gICAgICAgIGlmKHRoaXMuX2ZpcnN0Q29ubmVjdCAmJiAhaXNTaGFyZWRDbGllbnRBcGkpIHtcbiAgICAgICAgICBsb2dNZXNzYWdlICs9ICcgUGxlYXNlIG5vdGUgdGhhdCBpdCBjYW4gdGFrZSB1cCB0byAzIG1pbnV0ZXMgZm9yIHlvdXIgZGVkaWNhdGVkIHNlcnZlciB0byBzdGFydCBmb3IgdGhlICcgK1xuICAgICAgICAnZmlyc3QgdGltZS4gRHVyaW5nIHRoaXMgdGltZSBpdCBpcyBPSyBpZiB5b3Ugc2VlIHNvbWUgY29ubmVjdGlvbiBlcnJvcnMuJztcbiAgICAgICAgICB0aGlzLl9maXJzdENvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhsb2dNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBzZXJ2ZXIgVVJMJywgZXJyKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Rocm90dGxlUmVxdWVzdCh0eXBlLCBhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCB0aW1lSW5Ncykge1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0c1RpbWVbaW5zdGFuY2VOdW1iZXJdID0gdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl0gfHwge307XG4gICAgdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl1bdHlwZV0gPSB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXVt0eXBlXSB8fCB7fTtcbiAgICBsZXQgbGFzdFRpbWUgPSB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXVt0eXBlXVthY2NvdW50SWRdO1xuICAgIGlmICghbGFzdFRpbWUgfHwgKGxhc3RUaW1lIDwgRGF0ZS5ub3coKSAtIHRpbWVJbk1zKSkge1xuICAgICAgdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl1bdHlwZV1bYWNjb3VudElkXSA9IERhdGUubm93KCk7XG4gICAgICByZXR1cm4gISFsYXN0VGltZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX3JlZnJlc2hBY2NvdW50UmVnaW9uKGFjY291bnRJZCkge1xuICAgIGlmKHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0pIHtcbiAgICAgIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0ubGFzdFVzZWQgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfVxuXG4gIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICBpZiAodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgc29ja2V0SW5zdGFuY2VJbmRleCA9IG51bGw7XG4gICAgICB3aGlsZSAodGhpcy5fc3Vic2NyaWJlTG9jayAmJiAoKG5ldyBEYXRlKHRoaXMuX3N1YnNjcmliZUxvY2sucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKSA+IERhdGUubm93KCkgJiYgXG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbnN0YW5jZU51bWJlciwgdW5kZWZpbmVkLCByZWdpb24pLmxlbmd0aCA8IFxuICAgICAgICAgIHRoaXMuX3N1YnNjcmliZUxvY2subG9ja2VkQXRBY2NvdW50cykgfHwgXG4gICAgICAgICAgKG5ldyBEYXRlKHRoaXMuX3N1YnNjcmliZUxvY2subG9ja2VkQXRUaW1lKS5nZXRUaW1lKCkgKyB0aGlzLl9zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcyAqIDEwMDAgPiBcbiAgICAgICAgICBEYXRlLm5vdygpICYmIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIHVuZGVmaW5lZCwgcmVnaW9uKS5sZW5ndGggPj0gXG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlTG9jay5sb2NrZWRBdEFjY291bnRzKSkpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBhY2NvdW50Q291bnRlciA9IHRoaXMuZ2V0QXNzaWduZWRBY2NvdW50cyhpbnN0YW5jZU51bWJlciwgaW5kZXgsIHJlZ2lvbikubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW2luZGV4XTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2spIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay50eXBlID09PSAnTElNSVRfQUNDT1VOVF9TVUJTQ1JJUFRJT05TX1BFUl9VU0VSX1BFUl9TRVJWRVInICYmIFxuICAgICAgICAgICAgKG5ldyBEYXRlKGluc3RhbmNlLnN1YnNjcmliZUxvY2sucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKSA+IERhdGUubm93KCkgfHwgXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCBpbmRleCwgcmVnaW9uKS5sZW5ndGggPj0gXG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2sudHlwZSA9PT0gJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfU0VSVkVSJyAmJiBcbiAgICAgICAgICAgIG5ldyBEYXRlKGluc3RhbmNlLnN1YnNjcmliZUxvY2sucmVjb21tZW5kZWRSZXRyeVRpbWUpLmdldFRpbWUoKSA+IERhdGUubm93KCkgJiZcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIGluZGV4LCByZWdpb24pLmxlbmd0aCA+PSBcbiAgICAgICAgICAgIGluc3RhbmNlLnN1YnNjcmliZUxvY2subG9ja2VkQXRBY2NvdW50cykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFjY291bnRDb3VudGVyIDwgdGhpcy5fbWF4QWNjb3VudHNQZXJJbnN0YW5jZSkge1xuICAgICAgICAgIHNvY2tldEluc3RhbmNlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdLmxlbmd0aDtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KGluc3RhbmNlTnVtYmVyLCByZWdpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9IHNvY2tldEluc3RhbmNlSW5kZXg7XG4gICAgfVxuICB9ICBcblxuICBfY2xlYXJBY2NvdW50Q2FjaGVKb2IoKSB7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVnaW9uc0J5QWNjb3VudHMpLmZvckVhY2gocmVwbGljYUlkID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhSWRdO1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5jb25uZWN0aW9ucyA9PT0gMCAmJiBkYXRlIC0gZGF0YS5sYXN0VXNlZCA+IDIgKiA2MCAqIDYwICogMTAwMCkge1xuICAgICAgICBjb25zdCBwcmltYXJ5QWNjb3VudElkID0gdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhSWRdO1xuICAgICAgICBjb25zdCByZXBsaWNhcyA9IE9iamVjdC52YWx1ZXModGhpcy5fYWNjb3VudFJlcGxpY2FzW3ByaW1hcnlBY2NvdW50SWRdIHx8IHt9KTtcbiAgICAgICAgcmVwbGljYXMuZm9yRWFjaChyZXBsaWNhID0+IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYV07XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudFJlcGxpY2FzW3ByaW1hcnlBY2NvdW50SWRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2NsZWFySW5hY3RpdmVTeW5jRGF0YUpvYigpIHtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXMpLmtleXMoc3luY2hyb25pemF0aW9uSWQgPT4ge1xuICAgICAgaWYodGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW3N5bmNocm9uaXphdGlvbklkXS5sYXN0VXBkYXRlZCA8IGRhdGUgLSAzMCAqIDYwICogMTAwMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW3N5bmNocm9uaXphdGlvbklkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG4iXSwibmFtZXMiOlsicmFuZG9tc3RyaW5nIiwic29ja2V0SU8iLCJUaW1lb3V0RXJyb3IiLCJWYWxpZGF0aW9uRXJyb3IiLCJOb3RGb3VuZEVycm9yIiwiSW50ZXJuYWxFcnJvciIsIlVuYXV0aG9yaXplZEVycm9yIiwiVG9vTWFueVJlcXVlc3RzRXJyb3IiLCJGb3JiaWRkZW5FcnJvciIsIk9wdGlvbnNWYWxpZGF0b3IiLCJOb3RTeW5jaHJvbml6ZWRFcnJvciIsIk5vdENvbm5lY3RlZEVycm9yIiwiVHJhZGVFcnJvciIsIlBhY2tldE9yZGVyZXIiLCJTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJTdWJzY3JpcHRpb25NYW5hZ2VyIiwiTG9nZ2VyTWFuYWdlciIsImFueSIsIkxhdGVuY3lTZXJ2aWNlIiwiUGFja2V0TG9nZ2VyIiwid2luZG93IiwicmVxdWlyZSIsImRlZmF1bHQiLCJNZXRhQXBpV2Vic29ja2V0Q2xpZW50Iiwib25PdXRPZk9yZGVyUGFja2V0IiwiYWNjb3VudElkIiwiaW5zdGFuY2VJbmRleCIsImV4cGVjdGVkU2VxdWVuY2VOdW1iZXIiLCJhY3R1YWxTZXF1ZW5jZU51bWJlciIsInBhY2tldCIsInJlY2VpdmVkQXQiLCJfc3Vic2NyaXB0aW9uTWFuYWdlciIsImlzU3Vic2NyaXB0aW9uQWN0aXZlIiwiX2xvZ2dlciIsImVycm9yIiwidHlwZSIsImVuc3VyZVN1YnNjcmliZSIsInVybCIsIl91cmwiLCJyZWdpb24iLCJfcmVnaW9uIiwic29ja2V0SW5zdGFuY2VzIiwiX3NvY2tldEluc3RhbmNlcyIsInNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJfc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyIsImFjY291bnRSZXBsaWNhcyIsIl9hY2NvdW50UmVwbGljYXMiLCJhY2NvdW50c0J5UmVwbGljYUlkIiwiX2FjY291bnRzQnlSZXBsaWNhSWQiLCJjbGVhckFjY291bnRDYWNoZUpvYiIsIl9jbGVhckFjY291bnRDYWNoZUpvYiIsImJpbmQiLCJzdWJzY3JpYmVkQWNjb3VudElkcyIsImluc3RhbmNlTnVtYmVyIiwic29ja2V0SW5zdGFuY2VJbmRleCIsImNvbm5lY3RlZElkcyIsIk9iamVjdCIsImtleXMiLCJfY29ubmVjdGVkSG9zdHMiLCJmb3JFYWNoIiwiaW5zdGFuY2VJZCIsInNwbGl0IiwiYWNjb3VudFJlZ2lvbiIsImdldEFjY291bnRSZWdpb24iLCJpbmNsdWRlcyIsInVuZGVmaW5lZCIsInB1c2giLCJjb25uZWN0ZWQiLCJpbnN0YW5jZSIsImxlbmd0aCIsInNvY2tldCIsImdldEFzc2lnbmVkQWNjb3VudHMiLCJhY2NvdW50SWRzIiwia2V5IiwiX3JlZ2lvbnNCeUFjY291bnRzIiwiYWRkQWNjb3VudENhY2hlIiwicmVwbGljYXMiLCJyZXBsaWNhSWQiLCJjb25uZWN0aW9ucyIsImxhc3RVc2VkIiwiRGF0ZSIsIm5vdyIsInVwZGF0ZUFjY291bnRDYWNoZSIsIm9sZFJlcGxpY2FzIiwiY29ubmVjdGlvbkNvdW50IiwicmVtb3ZlQWNjb3VudENhY2hlIiwibG9ja1NvY2tldEluc3RhbmNlIiwibWV0YWRhdGEiLCJfc3Vic2NyaWJlTG9jayIsInJlY29tbWVuZGVkUmV0cnlUaW1lIiwibG9ja2VkQXRBY2NvdW50cyIsImxvY2tlZEF0VGltZSIsInN1YnNjcmliZWRBY2NvdW50cyIsInNvY2tldEluc3RhbmNlIiwiY2xvc2UiLCJfcmVjb25uZWN0Iiwic3Vic2NyaWJlTG9jayIsImNvbm5lY3QiLCJjbGllbnRJZCIsIk1hdGgiLCJyYW5kb20iLCJyZXNvbHZlIiwicmVzdWx0IiwiUHJvbWlzZSIsInJlcyIsInJlaiIsImlkIiwicmVjb25uZWN0V2FpdFRpbWUiLCJfc29ja2V0TWluaW11bVJlY29ubmVjdFRpbWVvdXQiLCJyZXF1ZXN0UmVzb2x2ZXMiLCJyZXNvbHZlZCIsImNvbm5lY3RSZXN1bHQiLCJzZXNzaW9uSWQiLCJnZW5lcmF0ZSIsImlzUmVjb25uZWN0aW5nIiwic3luY2hyb25pemF0aW9uVGhyb3R0bGVyIiwiX3N5bmNocm9uaXphdGlvblRocm90dGxlck9wdHMiLCJzdGFydCIsInNlcnZlclVybCIsIl9nZXRTZXJ2ZXJVcmwiLCJwYXRoIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwiSW5maW5pdHkiLCJ0aW1lb3V0IiwiX2Nvbm5lY3RUaW1lb3V0IiwiZXh0cmFIZWFkZXJzIiwicXVlcnkiLCJfdG9rZW4iLCJwcm90b2NvbCIsIm9uIiwiaW5mbyIsIl9maXJlUmVjb25uZWN0ZWQiLCJlcnIiLCJyZWFzb24iLCJvbkRpc2Nvbm5lY3QiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZGVidWciLCJzdHJpbmdpZnkiLCJyZXF1ZXN0SWQiLCJ0aW1lc3RhbXBzIiwicmVxdWVzdFJlc29sdmUiLCJyZWplY3QiLCJfY29udmVydElzb1RpbWVUb0RhdGUiLCJjbGllbnRQcm9jZXNzaW5nRmluaXNoZWQiLCJsaXN0ZW5lciIsIl9sYXRlbmN5TGlzdGVuZXJzIiwidGhlbiIsIm9uVHJhZGUiLCJvblJlc3BvbnNlIiwiY2F0Y2giLCJfY29udmVydEVycm9yIiwidHJhY2UiLCJzZXF1ZW5jZU51bWJlciIsInNlcXVlbmNlVGltZXN0YW1wIiwic3luY2hyb25pemF0aW9uSWQiLCJhcHBsaWNhdGlvbiIsImhvc3QiLCJzcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJwb3NpdGlvbnNVcGRhdGVkIiwib3JkZXJzVXBkYXRlZCIsInNwZWNpZmljYXRpb25zIiwiX3N5bmNocm9uaXphdGlvbkxpc3RlbmVycyIsImFjdGl2ZVN5bmNocm9uaXphdGlvbklkcyIsIl9wYWNrZXRMb2dnZXIiLCJsb2dQYWNrZXQiLCJpZ25vcmVkUGFja2V0VHlwZXMiLCJfdGhyb3R0bGVSZXF1ZXN0IiwiX3Vuc3Vic2NyaWJlVGhyb3R0bGluZ0ludGVydmFsIiwidW5zdWJzY3JpYmUiLCJ3YXJuIiwicXVldWVQYWNrZXQiLCJ2YWx1ZXMiLCJFcnJvciIsIl9wYWNrZXRPcmRlcmVyIiwic3RvcCIsImNsZWFySW50ZXJ2YWwiLCJfY2xlYXJBY2NvdW50Q2FjaGVJbnRlcnZhbCIsIl9jbGVhckluYWN0aXZlU3luY0RhdGFKb2IiLCJfbGF0ZW5jeVNlcnZpY2UiLCJnZXRBY2NvdW50SW5mb3JtYXRpb24iLCJvcHRpb25zIiwicmVzcG9uc2UiLCJycGNSZXF1ZXN0IiwiYWNjb3VudEluZm9ybWF0aW9uIiwiZ2V0UG9zaXRpb25zIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJwb3NpdGlvbklkIiwicG9zaXRpb24iLCJnZXRPcmRlcnMiLCJvcmRlcnMiLCJnZXRPcmRlciIsIm9yZGVySWQiLCJvcmRlciIsImdldEhpc3RvcnlPcmRlcnNCeVRpY2tldCIsInRpY2tldCIsImhpc3RvcnlPcmRlcnMiLCJzeW5jaHJvbml6aW5nIiwiZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24iLCJnZXRIaXN0b3J5T3JkZXJzQnlUaW1lUmFuZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwib2Zmc2V0IiwibGltaXQiLCJnZXREZWFsc0J5VGlja2V0IiwiZGVhbHMiLCJnZXREZWFsc0J5UG9zaXRpb24iLCJnZXREZWFsc0J5VGltZVJhbmdlIiwicmVtb3ZlQXBwbGljYXRpb24iLCJ0cmFkZSIsInJlbGlhYmlsaXR5IiwicnBjUmVxdWVzdEFsbEluc3RhbmNlcyIsIl9hcHBsaWNhdGlvbiIsInN0cmluZ0NvZGUiLCJkZXNjcmlwdGlvbiIsIm51bWVyaWNDb2RlIiwibWVzc2FnZSIsInNjaGVkdWxlU3Vic2NyaWJlIiwic3Vic2NyaWJlIiwic3luY2hyb25pemUiLCJzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUiLCJzdGFydGluZ0RlYWxUaW1lIiwiaGFzaGVzIiwiX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50IiwiX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50Iiwic3luY1Rocm90dGxlciIsIl9zeW5jaHJvbml6YXRpb25IYXNoZXMiLCJsYXN0VXBkYXRlZCIsInNjaGVkdWxlU3luY2hyb25pemUiLCJ2ZXJzaW9uIiwid2FpdFN5bmNocm9uaXplZCIsImFwcGxpY2F0aW9uUGF0dGVybiIsInRpbWVvdXRJblNlY29uZHMiLCJzdWJzY3JpYmVUb01hcmtldERhdGEiLCJzeW1ib2wiLCJzdWJzY3JpcHRpb25zIiwicmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zIiwidW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSIsImdldFN5bWJvbHMiLCJzeW1ib2xzIiwiZ2V0U3ltYm9sU3BlY2lmaWNhdGlvbiIsInNwZWNpZmljYXRpb24iLCJnZXRTeW1ib2xQcmljZSIsImtlZXBTdWJzY3JpcHRpb24iLCJwcmljZSIsImdldENhbmRsZSIsInRpbWVmcmFtZSIsImNhbmRsZSIsImdldFRpY2siLCJ0aWNrIiwiZ2V0Qm9vayIsImJvb2siLCJyZWZyZXNoVGVybWluYWxTdGF0ZSIsInJlZnJlc2hTeW1ib2xRdW90ZXMiLCJyZWZyZXNoZWRRdW90ZXMiLCJzYXZlVXB0aW1lIiwidXB0aW1lIiwib25VbnN1YnNjcmliZSIsInVwZGF0ZUV2ZW50c1RvUmVtb3ZlIiwiX3VwZGF0ZUV2ZW50cyIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCJhbGwiLCJtYXAiLCJOdW1iZXIiLCJuYW1lIiwiZ2V0U2VydmVyVGltZSIsInNlcnZlclRpbWUiLCJjYWxjdWxhdGVNYXJnaW4iLCJtYXJnaW4iLCJ1bnN1YnNjcmliZUFjY291bnRSZWdpb24iLCJ1bnN1YnNjcmliZVByb21pc2VzIiwiX3Byb2Nlc3NFdmVudCIsIm9uVW5zdWJzY3JpYmVSZWdpb24iLCJhZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImxpc3RlbmVycyIsInJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwibCIsImFkZExhdGVuY3lMaXN0ZW5lciIsInJlbW92ZUxhdGVuY3lMaXN0ZW5lciIsImFkZFJlY29ubmVjdExpc3RlbmVyIiwiX3JlY29ubmVjdExpc3RlbmVycyIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwib25BY2NvdW50RGVsZXRlZCIsImNhbmNlbEFjY291bnQiLCJtYXN0ZXJBY2NvdW50SWQiLCJyZWdpb25EYXRhIiwiX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZSIsInJlcGxpY2EiLCJwYWNrZXRzIiwicmVzdG9yZU9yZGVyIiwicCIsIl9zZXF1ZW50aWFsRXZlbnRQcm9jZXNzaW5nIiwiZXZlbnRzIiwicGFja2V0SXRlbSIsIl9wcm9jZXNzU3luY2hyb25pemF0aW9uUGFja2V0IiwiX2V2ZW50UXVldWVzIiwiX2NhbGxBY2NvdW50RXZlbnRzIiwiY29uY2F0IiwicXVldWVFdmVudCIsImNhbGxhYmxlIiwiZXZlbnQiLCJzaGlmdCIsIl90cnlSZWNvbm5lY3QiLCJtaW4iLCJzZXRUaW1lb3V0IiwiaW8iLCJvcHRzIiwidXJpIiwicmVxdWVzdCIsImFzc2lnbiIsImVycm9ycyIsImlnbm9yZWRSZXF1ZXN0VHlwZXMiLCJwcmltYXJ5QWNjb3VudElkIiwiY29ubmVjdGVkSW5zdGFuY2UiLCJnZXRBY3RpdmVBY2NvdW50SW5zdGFuY2VzIiwid2FpdENvbm5lY3RlZEluc3RhbmNlIiwiYWN0aXZlUmVnaW9uIiwiX3JlZnJlc2hBY2NvdW50UmVnaW9uIiwiX21ha2VSZXF1ZXN0IiwicmV0cnlDb3VudGVyIiwiY2FsY1JldHJ5Q291bnRlciIsImNhbGNSZXF1ZXN0VGltZSIsIl9yZXRyaWVzIiwicG93IiwiX21pblJldHJ5RGVsYXlJblNlY29uZHMiLCJfbWF4UmV0cnlEZWxheUluU2Vjb25kcyIsInJldHJ5VGltZSIsImdldFRpbWUiLCJjbGllbnRQcm9jZXNzaW5nU3RhcnRlZCIsInJhY2UiLCJfcmVxdWVzdFRpbWVvdXQiLCJlbWl0IiwiZGV0YWlscyIsImZpZWxkIiwidmFsdWUiLCJtYXRjaCIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW0iLCJwcmljZXMiLCJ1cGRhdGVTeW5jaHJvbml6YXRpb25JZCIsImlzT25seUFjdGl2ZUluc3RhbmNlIiwiYWN0aXZlSW5zdGFuY2VJZHMiLCJjYW5jZWxEaXNjb25uZWN0VGltZXIiLCJfc3RhdHVzVGltZXJzIiwiY2xlYXJUaW1lb3V0IiwicmVzZXREaXNjb25uZWN0VGltZXIiLCJvblRpbWVvdXQiLCJvbkRpc2Nvbm5lY3RlZCIsImlzVGltZW91dCIsIm9uU3RyZWFtQ2xvc2VkIiwicmVtb3ZlSWRCeVBhcmFtZXRlcnMiLCJvbkNvbm5lY3RlZCIsImNhbmNlbFN1YnNjcmliZSIsIl9zeW5jaHJvbml6YXRpb25GbGFncyIsInNwZWNpZmljYXRpb25zSGFzaEluZGV4IiwicG9zaXRpb25zSGFzaEluZGV4Iiwib3JkZXJzSGFzaEluZGV4Iiwic3BlY2lmaWNhdGlvbnNIYXNoIiwic3BlY2lmaWNhdGlvbnNIYXNoZXMiLCJwb3NpdGlvbnNIYXNoIiwicG9zaXRpb25zSGFzaGVzIiwib3JkZXJzSGFzaCIsIm9yZGVyc0hhc2hlcyIsIm9uU3luY2hyb25pemF0aW9uU3RhcnRlZCIsIm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCIsIm9uUG9zaXRpb25zU3luY2hyb25pemVkIiwib25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkIiwiZGVhbCIsIm9uRGVhbEFkZGVkIiwib25QZW5kaW5nT3JkZXJzUmVwbGFjZWQiLCJoaXN0b3J5T3JkZXIiLCJvbkhpc3RvcnlPcmRlckFkZGVkIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsInVwZGF0ZWRQb3NpdGlvbnMiLCJyZW1vdmVkUG9zaXRpb25JZHMiLCJvblBvc2l0aW9uc1VwZGF0ZWQiLCJvblBvc2l0aW9uVXBkYXRlZCIsIm9uUG9zaXRpb25SZW1vdmVkIiwidXBkYXRlZE9yZGVycyIsImNvbXBsZXRlZE9yZGVySWRzIiwib25QZW5kaW5nT3JkZXJzVXBkYXRlZCIsIm9uUGVuZGluZ09yZGVyVXBkYXRlZCIsIm9uUGVuZGluZ09yZGVyQ29tcGxldGVkIiwib25VcGRhdGUiLCJvbkRlYWxzU3luY2hyb25pemVkIiwicmVtb3ZlU3luY2hyb25pemF0aW9uSWQiLCJvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWQiLCJhdXRoZW50aWNhdGVkIiwiaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGUiLCJpc0FjY291bnRTdWJzY3JpYmluZyIsIm9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQiLCJoZWFsdGhTdGF0dXMiLCJvbkhlYWx0aFN0YXR1cyIsInVwZGF0ZXMiLCJ1bnN1YnNjcmlwdGlvbnMiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInJlbW92ZWRTeW1ib2xzIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uVXBkYXRlZCIsInJlbW92ZWRTeW1ib2wiLCJvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkIiwiY2FuZGxlcyIsInRpY2tzIiwiYm9va3MiLCJvblN5bWJvbFByaWNlc1VwZGF0ZWQiLCJlcXVpdHkiLCJmcmVlTWFyZ2luIiwibWFyZ2luTGV2ZWwiLCJhY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUiLCJvbkNhbmRsZXNVcGRhdGVkIiwib25UaWNrc1VwZGF0ZWQiLCJvbkJvb2tzVXBkYXRlZCIsIm9uU3ltYm9sUHJpY2VVcGRhdGVkIiwib25TeW1ib2xQcmljZSIsImxhYmVsIiwidGhyb3dFcnJvciIsImlzTG9uZ0V2ZW50IiwiaXNFdmVudERvbmUiLCJjaGVja0xvbmdFdmVudCIsImZsb29yIiwicmVjb25uZWN0TGlzdGVuZXJzIiwicmVjb25uZWN0QWNjb3VudElkcyIsIm9uUmVjb25uZWN0ZWQiLCJnZXRVcmxTZXR0aW5ncyIsImlzU2hhcmVkQ2xpZW50QXBpIiwidXJsU2V0dGluZ3MiLCJfZG9tYWluQ2xpZW50IiwiZ2V0U2V0dGluZ3MiLCJnZXRVcmwiLCJob3N0bmFtZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImRvbWFpbiIsIl91c2VTaGFyZWRDbGllbnRBcGkiLCJfaG9zdG5hbWUiLCJsb2dNZXNzYWdlIiwiX2ZpcnN0Q29ubmVjdCIsInRpbWVJbk1zIiwiX2xhc3RSZXF1ZXN0c1RpbWUiLCJsYXN0VGltZSIsIl9zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcyIsImluZGV4IiwiYWNjb3VudENvdW50ZXIiLCJfbWF4QWNjb3VudHNQZXJJbnN0YW5jZSIsImRhdGUiLCJjb25zdHJ1Y3RvciIsIm1ldGFBcGkiLCJkb21haW5DbGllbnQiLCJ0b2tlbiIsInZhbGlkYXRvciIsInBhY2tldE9yZGVyaW5nVGltZW91dCIsInZhbGlkYXRlTm9uWmVybyIsIl9kb21haW4iLCJfbWV0YUFwaSIsInJlcXVlc3RUaW1lb3V0IiwiY29ubmVjdFRpbWVvdXQiLCJyZXRyeU9wdHMiLCJ2YWxpZGF0ZU51bWJlciIsInJldHJpZXMiLCJtaW5EZWxheUluU2Vjb25kcyIsIm1heERlbGF5SW5TZWNvbmRzIiwic3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMiLCJ2YWxpZGF0ZUJvb2xlYW4iLCJ1c2VTaGFyZWRDbGllbnRBcGkiLCJ1bnN1YnNjcmliZVRocm90dGxpbmdJbnRlcnZhbEluU2Vjb25kcyIsInBhY2tldExvZ2dlciIsImVuYWJsZWQiLCJnZXRMb2dnZXIiLCJkaXNhYmxlSW50ZXJuYWxKb2JzIiwic2V0SW50ZXJ2YWwiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsT0FBT0Esa0JBQWtCLGVBQWU7QUFDeEMsT0FBT0MsY0FBYyxtQkFBbUI7QUFDeEMsT0FBT0Msa0JBQWtCLGtCQUFrQjtBQUMzQyxTQUFRQyxlQUFlLEVBQUVDLGFBQWEsRUFBRUMsYUFBYSxFQUFFQyxpQkFBaUIsRUFBRUMsb0JBQW9CLEVBQUVDLGNBQWMsUUFDdkcsa0JBQWtCO0FBQ3pCLE9BQU9DLHNCQUFzQixzQkFBc0I7QUFDbkQsT0FBT0MsMEJBQTBCLHlCQUF5QjtBQUMxRCxPQUFPQyx1QkFBdUIsc0JBQXNCO0FBQ3BELE9BQU9DLGdCQUFnQixlQUFlO0FBQ3RDLE9BQU9DLG1CQUFtQixrQkFBa0I7QUFD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