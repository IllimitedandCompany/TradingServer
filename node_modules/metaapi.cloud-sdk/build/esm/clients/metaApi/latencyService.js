'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import socketIO from 'socket.io-client';
import LoggerManager from '../../logger';
let LatencyService = class LatencyService {
    /**
   * Stops the service
   */ stop() {
        clearInterval(this._refreshRegionLatencyInterval);
    }
    /**
   * Returns the list of regions sorted by latency
   * @returns {String[]} list of regions sorted by latency
   */ get regionsSortedByLatency() {
        const regions = Object.keys(this._latencyCache);
        regions.sort((a, b)=>this._latencyCache[a] - this._latencyCache[b]);
        return regions;
    }
    /**
   * Invoked when an instance has been disconnected
   * @param {String} instanceId instance id
   */ onDisconnected(instanceId) {
        try {
            const accountId = this._getAccountIdFromInstance(instanceId);
            const disconnectedRegion = this._getRegionFromInstance(instanceId);
            this._disconnectInstance(instanceId);
            const instances = this._getAccountInstances(accountId);
            if (!instances.map((instance)=>this._connectedInstancesCache[instance]).includes(true)) {
                const regions = this._getAccountRegions(accountId);
                regions.filter((region)=>region !== disconnectedRegion).forEach((region)=>this._subscribeAccountReplica(accountId, region));
            }
        } catch (err) {
            this._logger.error(`Failed to process onDisconnected event for instance ${instanceId}`, err);
        }
    }
    /**
   * Invoked when an account has been unsubscribed
   * @param {String} accountId account id
   */ onUnsubscribe(accountId) {
        try {
            const region = this._websocketClient.getAccountRegion(accountId);
            const primaryAccountId = this._websocketClient.accountsByReplicaId[accountId];
            const instances = this._getAccountInstances(primaryAccountId);
            instances.filter((instanceId)=>instanceId.startsWith(`${primaryAccountId}:${region}:`)).forEach((instanceId)=>this._disconnectInstance(instanceId));
        } catch (err) {
            this._logger.error(`Failed to process onUnsubscribe event for account ${accountId}`, err);
        }
    }
    /**
   * Invoked when an instance has been connected
   * @param {String} instanceId instance id
   */ onConnected(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            try {
                _this._connectedInstancesCache[instanceId] = true;
                const accountId = _this._getAccountIdFromInstance(instanceId);
                const region = _this._getRegionFromInstance(instanceId);
                if (!_this._latencyCache[region]) {
                    yield _this._refreshLatency(region);
                }
                const instances = _this.getActiveAccountInstances(accountId);
                const synchronizedInstances = _this.getSynchronizedAccountInstances(accountId);
                const regions = instances.map((instance)=>_this._getRegionFromInstance(instance));
                if (instances.length > 1 && !synchronizedInstances.length) {
                    const regionsToDisconnect = _this.regionsSortedByLatency.filter((sortedRegion)=>regions.includes(sortedRegion)).slice(1);
                    regionsToDisconnect.forEach((regionItem)=>{
                        _this._websocketClient.unsubscribe(_this._websocketClient.accountReplicas[accountId][regionItem]);
                        _this._websocketClient.unsubscribeAccountRegion(accountId, regionItem);
                    });
                }
                if (_this._waitConnectPromises[accountId]) {
                    _this._waitConnectPromises[accountId].resolve();
                    delete _this._waitConnectPromises[accountId];
                }
            } catch (err) {
                _this._logger.error(`Failed to process onConnected event for instance ${instanceId}`, err);
            }
        })();
    }
    /**
   * Invoked when an instance has been synchronized
   * @param {String} instanceId instance id
   */ onDealsSynchronized(instanceId) {
        var _this = this;
        return _async_to_generator(function*() {
            try {
                _this._synchronizedInstancesCache[instanceId] = true;
                const accountId = _this._getAccountIdFromInstance(instanceId);
                const region = _this._getRegionFromInstance(instanceId);
                if (!_this._latencyCache[region]) {
                    yield _this._refreshLatency(region);
                }
                const instances = _this.getSynchronizedAccountInstances(accountId);
                const regions = [
                    ...new Set(instances.map((instance)=>_this._getRegionFromInstance(instance)))
                ];
                if (instances.length > 1) {
                    const regionsToDisconnect = _this.regionsSortedByLatency.filter((sortedRegion)=>regions.includes(sortedRegion)).slice(1);
                    regionsToDisconnect.forEach((regionItem)=>{
                        _this._websocketClient.unsubscribe(_this._websocketClient.accountReplicas[accountId][regionItem]);
                        _this._websocketClient.unsubscribeAccountRegion(accountId, regionItem);
                    });
                }
            } catch (err) {
                _this._logger.error(`Failed to process onDealsSynchronized event for instance ${instanceId}`, err);
            }
        })();
    }
    /**
   * Returns the list of currently connected account instances
   * @param {String} accountId account id
   * @returns {String[]} list of connected account instances
   */ getActiveAccountInstances(accountId) {
        return this._getAccountInstances(accountId).filter((instance)=>this._connectedInstancesCache[instance]);
    }
    /**
   * Returns the list of currently synchronized account instances
   * @param {String} accountId account id
   * @returns {String[]} list of synchronized account instances
   */ getSynchronizedAccountInstances(accountId) {
        return this._getAccountInstances(accountId).filter((instance)=>this._synchronizedInstancesCache[instance]);
    }
    /**
   * Waits for connected instance
   * @param {String} accountId account id 
   * @returns {String} instance id
   */ waitConnectedInstance(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let instances = _this.getActiveAccountInstances(accountId);
            if (!instances.length) {
                if (!_this._waitConnectPromises[accountId]) {
                    let resolve;
                    let promise = new Promise((res, rej)=>{
                        resolve = res;
                    });
                    _this._waitConnectPromises[accountId] = {
                        promise,
                        resolve
                    };
                }
                yield _this._waitConnectPromises[accountId].promise;
                instances = _this.getActiveAccountInstances(accountId);
            }
            return instances[0];
        })();
    }
    _getAccountInstances(accountId) {
        return Object.keys(this._connectedInstancesCache).filter((instanceId)=>instanceId.startsWith(`${accountId}:`));
    }
    _getAccountRegions(accountId) {
        const regions = [];
        const instances = this._getAccountInstances(accountId);
        instances.forEach((instance)=>{
            const region = this._getRegionFromInstance(instance);
            if (!regions.includes(region)) {
                regions.push(region);
            }
        });
        return regions;
    }
    _getAccountIdFromInstance(instanceId) {
        return instanceId.split(':')[0];
    }
    _getRegionFromInstance(instanceId) {
        return instanceId.split(':')[1];
    }
    _disconnectInstance(instanceId) {
        this._connectedInstancesCache[instanceId] = false;
        if (this._synchronizedInstancesCache[instanceId]) {
            this._synchronizedInstancesCache[instanceId] = false;
        }
    }
    _subscribeAccountReplica(accountId, region) {
        const instanceId = this._websocketClient.accountReplicas[accountId][region];
        if (instanceId) {
            this._websocketClient.ensureSubscribe(instanceId, 0);
            this._websocketClient.ensureSubscribe(instanceId, 1);
        }
    }
    _refreshRegionLatencyJob() {
        var _this = this;
        return _async_to_generator(function*() {
            for (let region of Object.keys(_this._latencyCache)){
                yield _this._refreshLatency(region);
            }
            // For every account, switch to a better region if such exists
            const accountIds = [];
            Object.keys(_this._connectedInstancesCache).filter((instanceId)=>_this._connectedInstancesCache[instanceId]).forEach((instanceId)=>{
                const accountId = _this._getAccountIdFromInstance(instanceId);
                if (!accountIds.includes(accountId)) {
                    accountIds.push(accountId);
                }
            });
            const sortedRegions = _this.regionsSortedByLatency;
            accountIds.forEach((accountId)=>{
                const accountRegions = _this._getAccountRegions(accountId);
                const activeInstances = _this.getActiveAccountInstances(accountId);
                if (activeInstances.length === 1) {
                    const activeInstance = activeInstances[0];
                    const activeRegion = _this._getRegionFromInstance(activeInstance);
                    const accountBestRegions = sortedRegions.filter((region)=>accountRegions.includes(region));
                    if (accountBestRegions[0] !== activeRegion) {
                        _this._subscribeAccountReplica(accountId, accountBestRegions[0]);
                    }
                }
            });
        })();
    }
    _refreshLatency(region) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._refreshPromisesByRegion[region]) {
                return yield _this._refreshPromisesByRegion[region];
            }
            let resolve;
            _this._refreshPromisesByRegion[region] = new Promise((res, rej)=>{
                resolve = res;
            });
            const serverUrl = yield _this._websocketClient.getUrlSettings(0, region);
            const startDate = Date.now();
            const socketInstance = socketIO(serverUrl.url, {
                path: '/ws',
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: Infinity,
                timeout: _this._connectTimeout,
                query: {
                    'auth-token': _this._token,
                    protocol: 3
                }
            });
            socketInstance.on('connect', /*#__PURE__*/ _async_to_generator(function*() {
                resolve();
                const latency = Date.now() - startDate;
                _this._latencyCache[region] = latency;
                socketInstance.close();
            }));
            yield _this._refreshPromisesByRegion[region];
            delete _this._refreshPromisesByRegion[region];
        })();
    }
    /**
   * Constructs latency service instance
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {String} token authorization token
   * @param {Number} connectTimeout websocket connect timeout in seconds
   */ constructor(websocketClient, token, connectTimeout){
        this._websocketClient = websocketClient;
        this._token = token;
        this._connectTimeout = connectTimeout;
        this._latencyCache = {};
        this._connectedInstancesCache = {};
        this._synchronizedInstancesCache = {};
        this._refreshPromisesByRegion = {};
        this._waitConnectPromises = {};
        this._logger = LoggerManager.getLogger('LatencyService');
        this._refreshRegionLatencyJob = this._refreshRegionLatencyJob.bind(this);
        this._refreshRegionLatencyInterval = setInterval(this._refreshRegionLatencyJob, 15 * 60 * 1000);
    }
};
/**
 * Service for managing account replicas based on region latency
 */ export { LatencyService as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBzb2NrZXRJTyBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5cbi8qKlxuICogU2VydmljZSBmb3IgbWFuYWdpbmcgYWNjb3VudCByZXBsaWNhcyBiYXNlZCBvbiByZWdpb24gbGF0ZW5jeVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXRlbmN5U2VydmljZSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgbGF0ZW5jeSBzZXJ2aWNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gYXV0aG9yaXphdGlvbiB0b2tlblxuICAgKiBAcGFyYW0ge051bWJlcn0gY29ubmVjdFRpbWVvdXQgd2Vic29ja2V0IGNvbm5lY3QgdGltZW91dCBpbiBzZWNvbmRzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJzb2NrZXRDbGllbnQsIHRva2VuLCBjb25uZWN0VGltZW91dCkge1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudCA9IHdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl90b2tlbiA9IHRva2VuO1xuICAgIHRoaXMuX2Nvbm5lY3RUaW1lb3V0ID0gY29ubmVjdFRpbWVvdXQ7XG4gICAgdGhpcy5fbGF0ZW5jeUNhY2hlID0ge307XG4gICAgdGhpcy5fY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9zeW5jaHJvbml6ZWRJbnN0YW5jZXNDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3JlZnJlc2hQcm9taXNlc0J5UmVnaW9uID0ge307XG4gICAgdGhpcy5fd2FpdENvbm5lY3RQcm9taXNlcyA9IHt9O1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdMYXRlbmN5U2VydmljZScpO1xuICAgIHRoaXMuX3JlZnJlc2hSZWdpb25MYXRlbmN5Sm9iID0gdGhpcy5fcmVmcmVzaFJlZ2lvbkxhdGVuY3lKb2IuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZWZyZXNoUmVnaW9uTGF0ZW5jeUludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fcmVmcmVzaFJlZ2lvbkxhdGVuY3lKb2IsIDE1ICogNjAgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgc2VydmljZVxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3JlZnJlc2hSZWdpb25MYXRlbmN5SW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgcmVnaW9ucyBzb3J0ZWQgYnkgbGF0ZW5jeVxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119IGxpc3Qgb2YgcmVnaW9ucyBzb3J0ZWQgYnkgbGF0ZW5jeVxuICAgKi9cbiAgZ2V0IHJlZ2lvbnNTb3J0ZWRCeUxhdGVuY3koKSB7XG4gICAgY29uc3QgcmVnaW9ucyA9IE9iamVjdC5rZXlzKHRoaXMuX2xhdGVuY3lDYWNoZSk7XG4gICAgcmVnaW9ucy5zb3J0KChhLCBiKSA9PiB0aGlzLl9sYXRlbmN5Q2FjaGVbYV0gLSB0aGlzLl9sYXRlbmN5Q2FjaGVbYl0pO1xuICAgIHJldHVybiByZWdpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhbiBpbnN0YW5jZSBoYXMgYmVlbiBkaXNjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSWQgaW5zdGFuY2UgaWRcbiAgICovXG4gIG9uRGlzY29ubmVjdGVkKGluc3RhbmNlSWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fZ2V0QWNjb3VudElkRnJvbUluc3RhbmNlKGluc3RhbmNlSWQpO1xuICAgICAgY29uc3QgZGlzY29ubmVjdGVkUmVnaW9uID0gdGhpcy5fZ2V0UmVnaW9uRnJvbUluc3RhbmNlKGluc3RhbmNlSWQpO1xuICAgICAgdGhpcy5fZGlzY29ubmVjdEluc3RhbmNlKGluc3RhbmNlSWQpO1xuICAgICAgY29uc3QgaW5zdGFuY2VzID0gdGhpcy5fZ2V0QWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpO1xuICAgICAgaWYoIWluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5fY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGVbaW5zdGFuY2VdKS5pbmNsdWRlcyh0cnVlKSkge1xuICAgICAgICBjb25zdCByZWdpb25zID0gdGhpcy5fZ2V0QWNjb3VudFJlZ2lvbnMoYWNjb3VudElkKTtcbiAgICAgICAgcmVnaW9ucy5maWx0ZXIocmVnaW9uID0+IHJlZ2lvbiAhPT0gZGlzY29ubmVjdGVkUmVnaW9uKVxuICAgICAgICAgIC5mb3JFYWNoKHJlZ2lvbiA9PiB0aGlzLl9zdWJzY3JpYmVBY2NvdW50UmVwbGljYShhY2NvdW50SWQsIHJlZ2lvbikpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBvbkRpc2Nvbm5lY3RlZCBldmVudCBmb3IgaW5zdGFuY2UgJHtpbnN0YW5jZUlkfWAsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhbiBhY2NvdW50IGhhcyBiZWVuIHVuc3Vic2NyaWJlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICovXG4gIG9uVW5zdWJzY3JpYmUoYWNjb3VudElkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuX3dlYnNvY2tldENsaWVudC5nZXRBY2NvdW50UmVnaW9uKGFjY291bnRJZCk7XG4gICAgICBjb25zdCBwcmltYXJ5QWNjb3VudElkID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFjY291bnRzQnlSZXBsaWNhSWRbYWNjb3VudElkXTtcbiAgICAgIGNvbnN0IGluc3RhbmNlcyA9IHRoaXMuX2dldEFjY291bnRJbnN0YW5jZXMocHJpbWFyeUFjY291bnRJZCk7XG4gICAgICBpbnN0YW5jZXMuZmlsdGVyKGluc3RhbmNlSWQgPT4gaW5zdGFuY2VJZC5zdGFydHNXaXRoKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7cmVnaW9ufTpgKSlcbiAgICAgICAgLmZvckVhY2goaW5zdGFuY2VJZCA9PiB0aGlzLl9kaXNjb25uZWN0SW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBvblVuc3Vic2NyaWJlIGV2ZW50IGZvciBhY2NvdW50ICR7YWNjb3VudElkfWAsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhbiBpbnN0YW5jZSBoYXMgYmVlbiBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSWQgaW5zdGFuY2UgaWRcbiAgICovXG4gIGFzeW5jIG9uQ29ubmVjdGVkKGluc3RhbmNlSWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGVbaW5zdGFuY2VJZF0gPSB0cnVlO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fZ2V0QWNjb3VudElkRnJvbUluc3RhbmNlKGluc3RhbmNlSWQpO1xuICAgICAgY29uc3QgcmVnaW9uID0gdGhpcy5fZ2V0UmVnaW9uRnJvbUluc3RhbmNlKGluc3RhbmNlSWQpO1xuICAgICAgaWYoIXRoaXMuX2xhdGVuY3lDYWNoZVtyZWdpb25dKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hMYXRlbmN5KHJlZ2lvbik7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnN0YW5jZXMgPSB0aGlzLmdldEFjdGl2ZUFjY291bnRJbnN0YW5jZXMoYWNjb3VudElkKTtcbiAgICAgIGNvbnN0IHN5bmNocm9uaXplZEluc3RhbmNlcyA9IHRoaXMuZ2V0U3luY2hyb25pemVkQWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpO1xuICAgICAgY29uc3QgcmVnaW9ucyA9IGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4gdGhpcy5fZ2V0UmVnaW9uRnJvbUluc3RhbmNlKGluc3RhbmNlKSk7XG4gICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDEgJiYgIXN5bmNocm9uaXplZEluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVnaW9uc1RvRGlzY29ubmVjdCA9IHRoaXMucmVnaW9uc1NvcnRlZEJ5TGF0ZW5jeVxuICAgICAgICAgIC5maWx0ZXIoc29ydGVkUmVnaW9uID0+IHJlZ2lvbnMuaW5jbHVkZXMoc29ydGVkUmVnaW9uKSkuc2xpY2UoMSk7XG4gICAgICAgIHJlZ2lvbnNUb0Rpc2Nvbm5lY3QuZm9yRWFjaChyZWdpb25JdGVtID0+IHtcbiAgICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmUodGhpcy5fd2Vic29ja2V0Q2xpZW50LmFjY291bnRSZXBsaWNhc1thY2NvdW50SWRdW3JlZ2lvbkl0ZW1dKTtcbiAgICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVBY2NvdW50UmVnaW9uKGFjY291bnRJZCwgcmVnaW9uSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5fd2FpdENvbm5lY3RQcm9taXNlc1thY2NvdW50SWRdKSB7XG4gICAgICAgIHRoaXMuX3dhaXRDb25uZWN0UHJvbWlzZXNbYWNjb3VudElkXS5yZXNvbHZlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93YWl0Q29ubmVjdFByb21pc2VzW2FjY291bnRJZF07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIG9uQ29ubmVjdGVkIGV2ZW50IGZvciBpbnN0YW5jZSAke2luc3RhbmNlSWR9YCwgZXJyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGFuIGluc3RhbmNlIGhhcyBiZWVuIHN5bmNocm9uaXplZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJZCBpbnN0YW5jZSBpZFxuICAgKi9cbiAgYXN5bmMgb25EZWFsc1N5bmNocm9uaXplZChpbnN0YW5jZUlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXplZEluc3RhbmNlc0NhY2hlW2luc3RhbmNlSWRdID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IHRoaXMuX2dldEFjY291bnRJZEZyb21JbnN0YW5jZShpbnN0YW5jZUlkKTtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuX2dldFJlZ2lvbkZyb21JbnN0YW5jZShpbnN0YW5jZUlkKTtcbiAgICAgIGlmKCF0aGlzLl9sYXRlbmN5Q2FjaGVbcmVnaW9uXSkge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWZyZXNoTGF0ZW5jeShyZWdpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zdGFuY2VzID0gdGhpcy5nZXRTeW5jaHJvbml6ZWRBY2NvdW50SW5zdGFuY2VzKGFjY291bnRJZCk7XG4gICAgICBjb25zdCByZWdpb25zID0gWy4uLm5ldyBTZXQoaW5zdGFuY2VzLm1hcChpbnN0YW5jZSA9PiB0aGlzLl9nZXRSZWdpb25Gcm9tSW5zdGFuY2UoaW5zdGFuY2UpKSldO1xuICAgICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbnNUb0Rpc2Nvbm5lY3QgPSB0aGlzLnJlZ2lvbnNTb3J0ZWRCeUxhdGVuY3lcbiAgICAgICAgICAuZmlsdGVyKHNvcnRlZFJlZ2lvbiA9PiByZWdpb25zLmluY2x1ZGVzKHNvcnRlZFJlZ2lvbikpLnNsaWNlKDEpO1xuICAgICAgICByZWdpb25zVG9EaXNjb25uZWN0LmZvckVhY2gocmVnaW9uSXRlbSA9PiB7XG4gICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnVuc3Vic2NyaWJlKHRoaXMuX3dlYnNvY2tldENsaWVudC5hY2NvdW50UmVwbGljYXNbYWNjb3VudElkXVtyZWdpb25JdGVtXSk7XG4gICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnVuc3Vic2NyaWJlQWNjb3VudFJlZ2lvbihhY2NvdW50SWQsIHJlZ2lvbkl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHByb2Nlc3Mgb25EZWFsc1N5bmNocm9uaXplZCBldmVudCBmb3IgaW5zdGFuY2UgJHtpbnN0YW5jZUlkfWAsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBhY2NvdW50IGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHJldHVybnMge1N0cmluZ1tdfSBsaXN0IG9mIGNvbm5lY3RlZCBhY2NvdW50IGluc3RhbmNlc1xuICAgKi9cbiAgZ2V0QWN0aXZlQWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpLmZpbHRlcihpbnN0YW5jZSA9PiB0aGlzLl9jb25uZWN0ZWRJbnN0YW5jZXNDYWNoZVtpbnN0YW5jZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY3VycmVudGx5IHN5bmNocm9uaXplZCBhY2NvdW50IGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHJldHVybnMge1N0cmluZ1tdfSBsaXN0IG9mIHN5bmNocm9uaXplZCBhY2NvdW50IGluc3RhbmNlc1xuICAgKi9cbiAgZ2V0U3luY2hyb25pemVkQWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpLmZpbHRlcihpbnN0YW5jZSA9PiB0aGlzLl9zeW5jaHJvbml6ZWRJbnN0YW5jZXNDYWNoZVtpbnN0YW5jZV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBjb25uZWN0ZWQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbnN0YW5jZSBpZFxuICAgKi9cbiAgYXN5bmMgd2FpdENvbm5lY3RlZEluc3RhbmNlKGFjY291bnRJZCkge1xuICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmdldEFjdGl2ZUFjY291bnRJbnN0YW5jZXMoYWNjb3VudElkKTtcbiAgICBpZiAoIWluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgIGlmICghdGhpcy5fd2FpdENvbm5lY3RQcm9taXNlc1thY2NvdW50SWRdKSB7XG4gICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl93YWl0Q29ubmVjdFByb21pc2VzW2FjY291bnRJZF0gPSB7cHJvbWlzZSwgcmVzb2x2ZX07XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl93YWl0Q29ubmVjdFByb21pc2VzW2FjY291bnRJZF0ucHJvbWlzZTtcbiAgICAgIGluc3RhbmNlcyA9IHRoaXMuZ2V0QWN0aXZlQWNjb3VudEluc3RhbmNlcyhhY2NvdW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VzWzBdO1xuICB9XG5cbiAgX2dldEFjY291bnRJbnN0YW5jZXMoYWNjb3VudElkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2Nvbm5lY3RlZEluc3RhbmNlc0NhY2hlKS5maWx0ZXIoaW5zdGFuY2VJZCA9PiBpbnN0YW5jZUlkLnN0YXJ0c1dpdGgoYCR7YWNjb3VudElkfTpgKSk7XG4gIH1cblxuICBfZ2V0QWNjb3VudFJlZ2lvbnMoYWNjb3VudElkKSB7XG4gICAgY29uc3QgcmVnaW9ucyA9IFtdO1xuICAgIGNvbnN0IGluc3RhbmNlcyA9IHRoaXMuX2dldEFjY291bnRJbnN0YW5jZXMoYWNjb3VudElkKTtcbiAgICBpbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICBjb25zdCByZWdpb24gPSB0aGlzLl9nZXRSZWdpb25Gcm9tSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgaWYoIXJlZ2lvbnMuaW5jbHVkZXMocmVnaW9uKSkge1xuICAgICAgICByZWdpb25zLnB1c2gocmVnaW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVnaW9ucztcbiAgfVxuXG4gIF9nZXRBY2NvdW50SWRGcm9tSW5zdGFuY2UoaW5zdGFuY2VJZCkge1xuICAgIHJldHVybiBpbnN0YW5jZUlkLnNwbGl0KCc6JylbMF07XG4gIH1cblxuICBfZ2V0UmVnaW9uRnJvbUluc3RhbmNlKGluc3RhbmNlSWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VJZC5zcGxpdCgnOicpWzFdO1xuICB9XG5cbiAgX2Rpc2Nvbm5lY3RJbnN0YW5jZShpbnN0YW5jZUlkKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGVbaW5zdGFuY2VJZF0gPSBmYWxzZTtcbiAgICBpZih0aGlzLl9zeW5jaHJvbml6ZWRJbnN0YW5jZXNDYWNoZVtpbnN0YW5jZUlkXSkge1xuICAgICAgdGhpcy5fc3luY2hyb25pemVkSW5zdGFuY2VzQ2FjaGVbaW5zdGFuY2VJZF0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBfc3Vic2NyaWJlQWNjb3VudFJlcGxpY2EoYWNjb3VudElkLCByZWdpb24pIHtcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFjY291bnRSZXBsaWNhc1thY2NvdW50SWRdW3JlZ2lvbl07XG4gICAgaWYoaW5zdGFuY2VJZCkge1xuICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmVuc3VyZVN1YnNjcmliZShpbnN0YW5jZUlkLCAwKTtcbiAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5lbnN1cmVTdWJzY3JpYmUoaW5zdGFuY2VJZCwgMSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3JlZnJlc2hSZWdpb25MYXRlbmN5Sm9iKCkge1xuICAgIGZvcihsZXQgcmVnaW9uIG9mIE9iamVjdC5rZXlzKHRoaXMuX2xhdGVuY3lDYWNoZSkpIHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hMYXRlbmN5KHJlZ2lvbik7XG4gICAgfVxuXG4gICAgLy8gRm9yIGV2ZXJ5IGFjY291bnQsIHN3aXRjaCB0byBhIGJldHRlciByZWdpb24gaWYgc3VjaCBleGlzdHNcbiAgICBjb25zdCBhY2NvdW50SWRzID0gW107XG4gICAgT2JqZWN0LmtleXModGhpcy5fY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGUpXG4gICAgICAuZmlsdGVyKGluc3RhbmNlSWQgPT4gdGhpcy5fY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGVbaW5zdGFuY2VJZF0pXG4gICAgICAuZm9yRWFjaChpbnN0YW5jZUlkID0+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fZ2V0QWNjb3VudElkRnJvbUluc3RhbmNlKGluc3RhbmNlSWQpO1xuICAgICAgICBpZighYWNjb3VudElkcy5pbmNsdWRlcyhhY2NvdW50SWQpKSB7XG4gICAgICAgICAgYWNjb3VudElkcy5wdXNoKGFjY291bnRJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgY29uc3Qgc29ydGVkUmVnaW9ucyA9IHRoaXMucmVnaW9uc1NvcnRlZEJ5TGF0ZW5jeTtcblxuICAgIGFjY291bnRJZHMuZm9yRWFjaChhY2NvdW50SWQgPT4ge1xuICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbnMgPSB0aGlzLl9nZXRBY2NvdW50UmVnaW9ucyhhY2NvdW50SWQpO1xuICAgICAgY29uc3QgYWN0aXZlSW5zdGFuY2VzID0gdGhpcy5nZXRBY3RpdmVBY2NvdW50SW5zdGFuY2VzKGFjY291bnRJZCk7XG4gICAgICBpZihhY3RpdmVJbnN0YW5jZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2VzWzBdO1xuICAgICAgICBjb25zdCBhY3RpdmVSZWdpb24gPSB0aGlzLl9nZXRSZWdpb25Gcm9tSW5zdGFuY2UoYWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICBjb25zdCBhY2NvdW50QmVzdFJlZ2lvbnMgPSBzb3J0ZWRSZWdpb25zLmZpbHRlcihyZWdpb24gPT4gYWNjb3VudFJlZ2lvbnMuaW5jbHVkZXMocmVnaW9uKSk7XG4gICAgICAgIGlmKGFjY291bnRCZXN0UmVnaW9uc1swXSAhPT0gYWN0aXZlUmVnaW9uKSB7XG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlQWNjb3VudFJlcGxpY2EoYWNjb3VudElkLCBhY2NvdW50QmVzdFJlZ2lvbnNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaExhdGVuY3kocmVnaW9uKSB7XG4gICAgaWYodGhpcy5fcmVmcmVzaFByb21pc2VzQnlSZWdpb25bcmVnaW9uXSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlZnJlc2hQcm9taXNlc0J5UmVnaW9uW3JlZ2lvbl07XG4gICAgfVxuICAgIGxldCByZXNvbHZlO1xuICAgIHRoaXMuX3JlZnJlc2hQcm9taXNlc0J5UmVnaW9uW3JlZ2lvbl0gPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VydmVyVXJsID0gYXdhaXQgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmdldFVybFNldHRpbmdzKDAsIHJlZ2lvbik7XG4gICAgY29uc3Qgc3RhcnREYXRlID0gRGF0ZS5ub3coKTtcbiAgXG4gICAgY29uc3Qgc29ja2V0SW5zdGFuY2UgPSBzb2NrZXRJTyhzZXJ2ZXJVcmwudXJsLCB7XG4gICAgICBwYXRoOiAnL3dzJyxcbiAgICAgIHJlY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiAxMDAwLFxuICAgICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDUwMDAsXG4gICAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogSW5maW5pdHksXG4gICAgICB0aW1lb3V0OiB0aGlzLl9jb25uZWN0VGltZW91dCxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICdhdXRoLXRva2VuJzogdGhpcy5fdG9rZW4sXG4gICAgICAgIHByb3RvY29sOiAzXG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICBjb25zdCBsYXRlbmN5ID0gRGF0ZS5ub3coKSAtIHN0YXJ0RGF0ZTtcbiAgICAgIHRoaXMuX2xhdGVuY3lDYWNoZVtyZWdpb25dID0gbGF0ZW5jeTtcbiAgICAgIHNvY2tldEluc3RhbmNlLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5fcmVmcmVzaFByb21pc2VzQnlSZWdpb25bcmVnaW9uXTtcbiAgICBkZWxldGUgdGhpcy5fcmVmcmVzaFByb21pc2VzQnlSZWdpb25bcmVnaW9uXTtcbiAgfVxuXG59XG4iXSwibmFtZXMiOlsic29ja2V0SU8iLCJMb2dnZXJNYW5hZ2VyIiwiTGF0ZW5jeVNlcnZpY2UiLCJzdG9wIiwiY2xlYXJJbnRlcnZhbCIsIl9yZWZyZXNoUmVnaW9uTGF0ZW5jeUludGVydmFsIiwicmVnaW9uc1NvcnRlZEJ5TGF0ZW5jeSIsInJlZ2lvbnMiLCJPYmplY3QiLCJrZXlzIiwiX2xhdGVuY3lDYWNoZSIsInNvcnQiLCJhIiwiYiIsIm9uRGlzY29ubmVjdGVkIiwiaW5zdGFuY2VJZCIsImFjY291bnRJZCIsIl9nZXRBY2NvdW50SWRGcm9tSW5zdGFuY2UiLCJkaXNjb25uZWN0ZWRSZWdpb24iLCJfZ2V0UmVnaW9uRnJvbUluc3RhbmNlIiwiX2Rpc2Nvbm5lY3RJbnN0YW5jZSIsImluc3RhbmNlcyIsIl9nZXRBY2NvdW50SW5zdGFuY2VzIiwibWFwIiwiaW5zdGFuY2UiLCJfY29ubmVjdGVkSW5zdGFuY2VzQ2FjaGUiLCJpbmNsdWRlcyIsIl9nZXRBY2NvdW50UmVnaW9ucyIsImZpbHRlciIsInJlZ2lvbiIsImZvckVhY2giLCJfc3Vic2NyaWJlQWNjb3VudFJlcGxpY2EiLCJlcnIiLCJfbG9nZ2VyIiwiZXJyb3IiLCJvblVuc3Vic2NyaWJlIiwiX3dlYnNvY2tldENsaWVudCIsImdldEFjY291bnRSZWdpb24iLCJwcmltYXJ5QWNjb3VudElkIiwiYWNjb3VudHNCeVJlcGxpY2FJZCIsInN0YXJ0c1dpdGgiLCJvbkNvbm5lY3RlZCIsIl9yZWZyZXNoTGF0ZW5jeSIsImdldEFjdGl2ZUFjY291bnRJbnN0YW5jZXMiLCJzeW5jaHJvbml6ZWRJbnN0YW5jZXMiLCJnZXRTeW5jaHJvbml6ZWRBY2NvdW50SW5zdGFuY2VzIiwibGVuZ3RoIiwicmVnaW9uc1RvRGlzY29ubmVjdCIsInNvcnRlZFJlZ2lvbiIsInNsaWNlIiwicmVnaW9uSXRlbSIsInVuc3Vic2NyaWJlIiwiYWNjb3VudFJlcGxpY2FzIiwidW5zdWJzY3JpYmVBY2NvdW50UmVnaW9uIiwiX3dhaXRDb25uZWN0UHJvbWlzZXMiLCJyZXNvbHZlIiwib25EZWFsc1N5bmNocm9uaXplZCIsIl9zeW5jaHJvbml6ZWRJbnN0YW5jZXNDYWNoZSIsIlNldCIsIndhaXRDb25uZWN0ZWRJbnN0YW5jZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwicHVzaCIsInNwbGl0IiwiZW5zdXJlU3Vic2NyaWJlIiwiX3JlZnJlc2hSZWdpb25MYXRlbmN5Sm9iIiwiYWNjb3VudElkcyIsInNvcnRlZFJlZ2lvbnMiLCJhY2NvdW50UmVnaW9ucyIsImFjdGl2ZUluc3RhbmNlcyIsImFjdGl2ZUluc3RhbmNlIiwiYWN0aXZlUmVnaW9uIiwiYWNjb3VudEJlc3RSZWdpb25zIiwiX3JlZnJlc2hQcm9taXNlc0J5UmVnaW9uIiwic2VydmVyVXJsIiwiZ2V0VXJsU2V0dGluZ3MiLCJzdGFydERhdGUiLCJEYXRlIiwibm93Iiwic29ja2V0SW5zdGFuY2UiLCJ1cmwiLCJwYXRoIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwiSW5maW5pdHkiLCJ0aW1lb3V0IiwiX2Nvbm5lY3RUaW1lb3V0IiwicXVlcnkiLCJfdG9rZW4iLCJwcm90b2NvbCIsIm9uIiwibGF0ZW5jeSIsImNsb3NlIiwiY29uc3RydWN0b3IiLCJ3ZWJzb2NrZXRDbGllbnQiLCJ0b2tlbiIsImNvbm5lY3RUaW1lb3V0IiwiZ2V0TG9nZ2VyIiwiYmluZCIsInNldEludGVydmFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsT0FBT0EsY0FBYyxtQkFBbUI7QUFDeEMsT0FBT0MsbUJBQW1CLGVBQWU7QUFLMUIsSUFBQSxBQUFNQyxpQkFBTixNQUFNQTtJQXNCbkI7O0dBRUMsR0FDREMsT0FBTztRQUNMQyxjQUFjLElBQUksQ0FBQ0MsNkJBQTZCO0lBQ2xEO0lBRUE7OztHQUdDLEdBQ0QsSUFBSUMseUJBQXlCO1FBQzNCLE1BQU1DLFVBQVVDLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNDLGFBQWE7UUFDOUNILFFBQVFJLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLElBQUksQ0FBQ0gsYUFBYSxDQUFDRSxFQUFFLEdBQUcsSUFBSSxDQUFDRixhQUFhLENBQUNHLEVBQUU7UUFDcEUsT0FBT047SUFDVDtJQUVBOzs7R0FHQyxHQUNETyxlQUFlQyxVQUFVLEVBQUU7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