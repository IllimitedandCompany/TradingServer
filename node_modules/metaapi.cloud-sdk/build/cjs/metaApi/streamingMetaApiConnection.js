"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return StreamingMetaApiConnection;
    }
});
const _terminalState = /*#__PURE__*/ _interop_require_default(require("./terminalState"));
const _memoryHistoryStorage = /*#__PURE__*/ _interop_require_default(require("./memoryHistoryStorage"));
const _timeoutError = /*#__PURE__*/ _interop_require_default(require("../clients/timeoutError"));
const _randomstring = /*#__PURE__*/ _interop_require_default(require("randomstring"));
const _connectionHealthMonitor = /*#__PURE__*/ _interop_require_default(require("./connectionHealthMonitor"));
const _errorHandler = require("../clients/errorHandler");
const _optionsValidator = /*#__PURE__*/ _interop_require_default(require("../clients/optionsValidator"));
const _logger = /*#__PURE__*/ _interop_require_default(require("../logger"));
const _metaApiConnection = /*#__PURE__*/ _interop_require_default(require("./metaApiConnection"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let StreamingMetaApiConnection = class StreamingMetaApiConnection extends _metaApiConnection.default {
    /**
   * Opens the connection. Can only be called the first time, next calls will be ignored.
   * @param {string} instanceId connection instance id
   * @return {Promise} promise resolving when the connection is opened
   */ async connect(instanceId) {
        if (!this._openedInstances.includes(instanceId)) {
            this._openedInstances.push(instanceId);
        }
        if (!this._opened) {
            this._logger.trace(`${this._account.id}: Opening connection`);
            this._opened = true;
            try {
                await this.initialize();
                await this.subscribe();
            } catch (err) {
                await this.close();
                throw err;
            }
        }
    }
    /**
   * Clears the order and transaction history of a specified application and removes application
   * @return {Promise} promise resolving when the history is cleared and application is removed
   */ removeApplication() {
        this._checkIsConnectionActive();
        this._historyStorage.clear();
        return this._websocketClient.removeApplication(this._account.id);
    }
    /**
   * Requests the terminal to start synchronization process
   * (see https://metaapi.cloud/docs/client/websocket/synchronizing/synchronize/)
   * @param {String} instanceIndex instance index
   * @returns {Promise} promise which resolves when synchronization started
   */ async synchronize(instanceIndex) {
        this._checkIsConnectionActive();
        const region = this.getRegion(instanceIndex);
        const instance = this.getInstanceNumber(instanceIndex);
        const host = this.getHostName(instanceIndex);
        let startingHistoryOrderTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastHistoryOrderTime(instance)).getTime()));
        let startingDealTime = new Date(Math.max((this._historyStartTime || new Date(0)).getTime(), (await this._historyStorage.lastDealTime(instance)).getTime()));
        let synchronizationId = _randomstring.default.generate(32);
        this._getState(instanceIndex).lastSynchronizationId = synchronizationId;
        const accountId = this._account.accountRegions[region];
        this._logger.debug(`${this._account.id}:${instanceIndex}: initiating synchronization ${synchronizationId}`);
        return this._websocketClient.synchronize(accountId, instance, host, synchronizationId, startingHistoryOrderTime, startingDealTime, this.terminalState.getHashes());
    }
    /**
   * Initializes meta api connection
   * @return {Promise} promise which resolves when meta api connection is initialized
   */ async initialize() {
        this._checkIsConnectionActive();
        await this._historyStorage.initialize(this._account.id, this._connectionRegistry.application);
        this._websocketClient.addAccountCache(this._account.id, this._account.accountRegions);
    }
    /**
   * Initiates subscription to MetaTrader terminal
   * @returns {Promise} promise which resolves when subscription is initiated
   */ async subscribe() {
        this._checkIsConnectionActive();
        const accountRegions = this._account.accountRegions;
        Object.values(accountRegions).forEach((replicaId)=>{
            this._websocketClient.ensureSubscribe(replicaId, 0);
            this._websocketClient.ensureSubscribe(replicaId, 1);
        });
    }
    /**
   * Subscribes on market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/subscribeToMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update. Please
   * note that this feature is not fully implemented on server-side yet
   * @param {number} [timeoutInSeconds] timeout to wait for prices in seconds, default is 30
   * @param {boolean} [waitForQuote] if set to false, the method will resolve without waiting for the first quote to
   * arrive. Default is to wait for quote if quotes subscription is requested.
   * @returns {Promise} promise which resolves when subscription request was processed
   */ async subscribeToMarketData(symbol, subscriptions, timeoutInSeconds, waitForQuote = true) {
        this._checkIsConnectionActive();
        if (!this._terminalState.specification(symbol)) {
            throw new _errorHandler.ValidationError(`${this._account.id}: Cannot subscribe to market data for symbol ${symbol} because ` + "symbol does not exist");
        } else {
            subscriptions = subscriptions || [
                {
                    type: "quotes"
                }
            ];
            if (this._subscriptions[symbol]) {
                const prevSubscriptions = this._subscriptions[symbol].subscriptions;
                subscriptions.forEach((subscription)=>{
                    const index = subscription.type === "candles" ? prevSubscriptions.findIndex((item)=>item.type === subscription.type && item.timeframe === subscription.timeframe) : prevSubscriptions.findIndex((item)=>item.type === subscription.type);
                    if (index === -1) {
                        prevSubscriptions.push(subscription);
                    } else {
                        prevSubscriptions[index] = subscription;
                    }
                });
            } else {
                this._subscriptions[symbol] = {
                    subscriptions
                };
            }
            await this._websocketClient.subscribeToMarketData(this._account.id, symbol, subscriptions, this._account.reliability);
            if (waitForQuote !== false && subscriptions.find((s)=>s.type === "quotes")) {
                return this.terminalState.waitForPrice(symbol, timeoutInSeconds);
            }
        }
    }
    /**
   * Unsubscribes from market data of specified symbol (see
   * https://metaapi.cloud/docs/client/websocket/marketDataStreaming/unsubscribeFromMarketData/).
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */ unsubscribeFromMarketData(symbol, subscriptions) {
        this._checkIsConnectionActive();
        if (!subscriptions) {
            delete this._subscriptions[symbol];
        } else if (this._subscriptions[symbol]) {
            this._subscriptions[symbol].subscriptions = this._subscriptions[symbol].subscriptions.filter((s)=>s.type === "candles" ? !subscriptions.find((s2)=>s.type === s2.type && s.timeframe === s2.timeframe) : !subscriptions.find((s2)=>s.type === s2.type));
            if (!this._subscriptions[symbol].subscriptions.length) {
                delete this._subscriptions[symbol];
            }
        }
        return this._websocketClient.unsubscribeFromMarketData(this._account.id, symbol, subscriptions, this._account.reliability);
    }
    /**
   * Invoked when subscription downgrade has occurred
   * @param {String} instanceIndex index of an account instance connected
   * @param {string} symbol symbol to update subscriptions for
   * @param {Array<MarketDataSubscription>} updates array of market data subscription to update
   * @param {Array<MarketDataUnsubscription>} unsubscriptions array of subscriptions to cancel
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity
    async onSubscriptionDowngraded(instanceIndex, symbol, updates, unsubscriptions) {
        let subscriptions = this._subscriptions[symbol] || [];
        if (unsubscriptions && unsubscriptions.length) {
            if (subscriptions) {
                for (let subscription of unsubscriptions){
                    subscriptions = subscriptions.filter((s)=>s.type === subscription.type);
                }
            }
            this.unsubscribeFromMarketData(symbol, unsubscriptions).catch((err)=>{
                if (err.name !== _errorHandler.ValidationError) {
                    this._logger.error(`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
                } else {
                    this._logger.trace(`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
                }
            });
        }
        if (updates && updates.length) {
            if (subscriptions) {
                for (let subscription of updates){
                    subscriptions.filter((s)=>s.type === subscription.type).forEach((s)=>s.intervalInMilliiseconds = subscription.intervalInMilliseconds);
                }
            }
            this.subscribeToMarketData(symbol, updates).catch((err)=>{
                this._logger.error(`${this._account.id}: failed do unsubscribe from market data on subscription downgraded`, err);
            });
        }
        if (subscriptions && !subscriptions.length) {
            delete this._subscriptions[symbol];
        }
    }
    /**
   * Returns list of the symbols connection is subscribed to
   * @returns {Array<String>} list of the symbols connection is subscribed to
   */ get subscribedSymbols() {
        return Object.keys(this._subscriptions);
    }
    /**
   * Returns subscriptions for a symbol
   * @param {string} symbol symbol to retrieve subscriptions for
   * @returns {Array<MarketDataSubscription>} list of market data subscriptions for the symbol
   */ subscriptions(symbol) {
        this._checkIsConnectionActive();
        return (this._subscriptions[symbol] || {}).subscriptions;
    }
    /**
   * Returns local copy of terminal state
   * @returns {TerminalState} local copy of terminal state
   */ get terminalState() {
        return this._terminalState;
    }
    /**
   * Returns local history storage
   * @returns {HistoryStorage} local history storage
   */ get historyStorage() {
        return this._historyStorage;
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   * @param {Number} replicas number of account replicas launched
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onConnected(instanceIndex, replicas) {
        let key = _randomstring.default.generate(32);
        let state = this._getState(instanceIndex);
        const region = this.getRegion(instanceIndex);
        this.cancelRefresh(region);
        await this._terminalHashManager.refreshIgnoredFieldLists(region);
        state.shouldSynchronize = key;
        state.synchronizationRetryIntervalInSeconds = 1;
        state.synchronized = false;
        this._ensureSynchronized(instanceIndex, key);
        this._logger.debug(`${this._account.id}:${instanceIndex}: connected to broker`);
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ async onDisconnected(instanceIndex) {
        let state = this._getState(instanceIndex);
        state.lastDisconnectedSynchronizationId = state.lastSynchronizationId;
        state.lastSynchronizationId = undefined;
        state.shouldSynchronize = undefined;
        state.synchronized = false;
        state.disconnected = true;
        const instanceNumber = this.getInstanceNumber(instanceIndex);
        const region = this.getRegion(instanceIndex);
        const instance = `${region}:${instanceNumber}`;
        delete this._refreshMarketDataSubscriptionSessions[instance];
        clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
        delete this._refreshMarketDataSubscriptionTimeouts[instance];
        if (state.synchronizationTimeout) {
            clearTimeout(state.synchronizationTimeout);
            delete state.synchronizationTimeout;
        }
        if (state.ensureSynchronizeTimeout) {
            clearTimeout(state.ensureSynchronizeTimeout);
            delete state.ensureSynchronizeTimeout;
        }
        this._logger.debug(`${this._account.id}:${instanceIndex}: disconnected from broker`);
    }
    /**
   * Invoked when a symbol specifications were updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when position synchronization finished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ onPositionsSynchronized(instanceIndex, synchronizationId) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   */ onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when a synchronization of history deals on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onDealsSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.dealsSynchronized[synchronizationId] = true;
        this._scheduleSynchronizationTimeout(instanceIndex);
        this._logger.debug(`${this._account.id}:${instanceIndex}: finished synchronization ${synchronizationId}`);
    }
    /**
   * Invoked when a synchronization of history orders on a MetaTrader account have finished to indicate progress of an
   * initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onHistoryOrdersSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.ordersSynchronized[synchronizationId] = true;
        this._scheduleSynchronizationTimeout(instanceIndex);
    }
    /**
   * Invoked when connection to MetaApi websocket API restored after a disconnect
   * @param {String} region reconnected region
   * @param {Number} instanceNumber reconnected instance number
   * @return {Promise} promise which resolves when connection to MetaApi websocket API restored after a disconnect
   */ async onReconnected(region, instanceNumber) {
        const instanceTemplate = `${region}:${instanceNumber}`;
        Object.keys(this._stateByInstanceIndex).filter((key)=>key.startsWith(`${instanceTemplate}:`)).forEach((key)=>{
            delete this._stateByInstanceIndex[key];
        });
        delete this._refreshMarketDataSubscriptionSessions[instanceTemplate];
        clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instanceTemplate]);
        delete this._refreshMarketDataSubscriptionTimeouts[instanceTemplate];
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onStreamClosed(instanceIndex) {
        delete this._stateByInstanceIndex[instanceIndex];
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        this._logger.debug(`${this._account.id}:${instanceIndex}: starting synchronization ${synchronizationId}`);
        const instanceNumber = this.getInstanceNumber(instanceIndex);
        const region = this.getRegion(instanceIndex);
        const instance = `${region}:${instanceNumber}`;
        const accountId = this._account.accountRegions[region];
        delete this._refreshMarketDataSubscriptionSessions[instance];
        let sessionId = _randomstring.default.generate(32);
        this._refreshMarketDataSubscriptionSessions[instance] = sessionId;
        clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
        delete this._refreshMarketDataSubscriptionTimeouts[instance];
        await this._refreshMarketDataSubscriptions(accountId, instanceNumber, sessionId);
        this._scheduleSynchronizationTimeout(instanceIndex);
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            state.lastSynchronizationId = synchronizationId;
        }
    }
    /**
   * Invoked when account region has been unsubscribed
   * @param {String} region account region unsubscribed
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onUnsubscribeRegion(region) {
        Object.keys(this._refreshMarketDataSubscriptionTimeouts).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>{
            clearTimeout(this._refreshMarketDataSubscriptionTimeouts[instance]);
            delete this._refreshMarketDataSubscriptionTimeouts[instance];
            delete this._refreshMarketDataSubscriptionSessions[instance];
        });
        Object.keys(this._stateByInstanceIndex).filter((instance)=>instance.startsWith(`${region}:`)).forEach((instance)=>delete this._stateByInstanceIndex[instance]);
    }
    /**
   * Returns flag indicating status of state synchronization with MetaTrader terminal
   * @param {String} instanceIndex index of an account instance connected
   * @param {String} synchronizationId optional synchronization request id, last synchronization request id will be used
   * by default
   * @return {Promise<Boolean>} promise resolving with a flag indicating status of state synchronization with MetaTrader
   * terminal
   */ async isSynchronized(instanceIndex, synchronizationId) {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>{
            if (instanceIndex !== undefined && s.instanceIndex !== instanceIndex) {
                return acc;
            }
            const checkSynchronizationId = synchronizationId || s.lastSynchronizationId;
            let synchronized = !!s.ordersSynchronized[checkSynchronizationId] && !!s.dealsSynchronized[checkSynchronizationId];
            return acc || synchronized;
        }, false);
    }
    /**
   * @typedef {Object} SynchronizationOptions
   * @property {String} [applicationPattern] application regular expression pattern, default is .*
   * @property {String} [synchronizationId] synchronization id, last synchronization request id will be used by
   * default
   * @property {Number} [instanceIndex] index of an account instance to ensure synchronization on, default is to wait
   * for the first instance to synchronize
   * @property {Number} [timeoutInSeconds] wait timeout in seconds, default is 5m
   * @property {Number} [intervalInMilliseconds] interval between account reloads while waiting for a change, default is 1s
   */ /**
   * Waits until synchronization to MetaTrader terminal is completed
   * @param {SynchronizationOptions} opts synchronization options
   * @return {Promise} promise which resolves when synchronization to MetaTrader terminal is completed
   * @throws {TimeoutError} if application failed to synchronize with the teminal within timeout allowed
   */ // eslint-disable-next-line complexity
    async waitSynchronized(opts) {
        this._checkIsConnectionActive();
        opts = opts || {};
        let instanceIndex = opts.instanceIndex;
        let synchronizationId = opts.synchronizationId;
        let timeoutInSeconds = opts.timeoutInSeconds || 300;
        let intervalInMilliseconds = opts.intervalInMilliseconds || 1000;
        let applicationPattern = opts.applicationPattern || (this._account.application === "CopyFactory" ? "CopyFactory.*|RPC" : "RPC");
        let startTime = Date.now();
        let synchronized;
        while(!(synchronized = await this.isSynchronized(instanceIndex, synchronizationId)) && startTime + timeoutInSeconds * 1000 > Date.now()){
            await new Promise((res)=>setTimeout(res, intervalInMilliseconds));
        }
        let state;
        if (instanceIndex === undefined) {
            for (let s of Object.values(this._stateByInstanceIndex)){
                if (await this.isSynchronized(s.instanceIndex, synchronizationId)) {
                    state = s;
                    instanceIndex = s.instanceIndex;
                }
            }
        } else {
            state = Object.values(this._stateByInstanceIndex).find((s)=>s.instanceIndex === instanceIndex);
        }
        if (!synchronized) {
            throw new _timeoutError.default("Timed out waiting for MetaApi to synchronize to MetaTrader account " + this._account.id + ", synchronization id " + (synchronizationId || state && state.lastSynchronizationId || state && state.lastDisconnectedSynchronizationId));
        }
        let timeLeftInSeconds = Math.max(0, timeoutInSeconds - (Date.now() - startTime) / 1000);
        const region = this.getRegion(state.instanceIndex);
        const accountId = this._account.accountRegions[region];
        await this._websocketClient.waitSynchronized(accountId, this.getInstanceNumber(instanceIndex), applicationPattern, timeLeftInSeconds);
    }
    /**
   * Closes the connection. The instance of the class should no longer be used after this method is invoked.
   * @param {string} instanceId connection instance id
   */ async close(instanceId) {
        if (this._opened) {
            this._openedInstances = this._openedInstances.filter((id)=>id !== instanceId);
            if (!this._openedInstances.length && !this._closed) {
                clearInterval(this._refreshJob);
                this._logger.debug(`${this._account.id}: Closing connection`);
                this._stateByInstanceIndex = {};
                await this._connectionRegistry.removeStreaming(this._account);
                this._terminalState.close();
                const accountRegions = this._account.accountRegions;
                this._websocketClient.removeSynchronizationListener(this._account.id, this);
                this._websocketClient.removeSynchronizationListener(this._account.id, this._terminalState);
                this._websocketClient.removeSynchronizationListener(this._account.id, this._historyStorage);
                this._websocketClient.removeSynchronizationListener(this._account.id, this._healthMonitor);
                this._websocketClient.removeReconnectListener(this);
                this._healthMonitor.stop();
                this._refreshMarketDataSubscriptionSessions = {};
                Object.values(this._refreshMarketDataSubscriptionTimeouts).forEach((timeout)=>clearTimeout(timeout));
                this._refreshMarketDataSubscriptionTimeouts = {};
                Object.values(accountRegions).forEach((replicaId)=>this._websocketClient.removeAccountCache(replicaId));
                this._closed = true;
                this._logger.trace(`${this._account.id}: Closed connection`);
            }
        }
    }
    /**
   * Returns synchronization status
   * @return {boolean} synchronization status
   */ get synchronized() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.synchronized, false);
    }
    /**
   * Returns MetaApi account
   * @return {MetatraderAccount} MetaApi account
   */ get account() {
        return this._account;
    }
    /**
   * Returns connection health monitor instance
   * @return {ConnectionHealthMonitor} connection health monitor instance
   */ get healthMonitor() {
        return this._healthMonitor;
    }
    async _refreshMarketDataSubscriptions(accountId, instanceNumber, session) {
        const region = this._websocketClient.getAccountRegion(accountId);
        const instance = `${region}:${instanceNumber}`;
        try {
            if (this._refreshMarketDataSubscriptionSessions[instance] === session) {
                const subscriptionsList = [];
                Object.keys(this._subscriptions).forEach((key)=>{
                    const subscriptions = this.subscriptions(key);
                    const subscriptionsItem = {
                        symbol: key
                    };
                    if (subscriptions) {
                        subscriptionsItem.subscriptions = subscriptions;
                    }
                    subscriptionsList.push(subscriptionsItem);
                });
                await this._websocketClient.refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptionsList);
            }
        } catch (err) {
            this._logger.error(`Error refreshing market data subscriptions job for account ${this._account.id} ` + `${instanceNumber}`, err);
        } finally{
            if (this._refreshMarketDataSubscriptionSessions[instance] === session) {
                let refreshInterval = (Math.random() * (this._maxSubscriptionRefreshInterval - this._minSubscriptionRefreshInterval) + this._minSubscriptionRefreshInterval) * 1000;
                this._refreshMarketDataSubscriptionTimeouts[instance] = setTimeout(()=>this._refreshMarketDataSubscriptions(accountId, instanceNumber, session), refreshInterval);
            }
        }
    }
    _generateStopOptions(stopLoss, takeProfit) {
        let trade = {};
        if (typeof stopLoss === "number") {
            trade.stopLoss = stopLoss;
        } else if (stopLoss) {
            trade.stopLoss = stopLoss.value;
            trade.stopLossUnits = stopLoss.units;
        }
        if (typeof takeProfit === "number") {
            trade.takeProfit = takeProfit;
        } else if (takeProfit) {
            trade.takeProfit = takeProfit.value;
            trade.takeProfitUnits = takeProfit.units;
        }
        return trade;
    }
    async _ensureSynchronized(instanceIndex, key) {
        let state = this._getState(instanceIndex);
        if (state && state.shouldSynchronize && !this._closed) {
            try {
                const synchronizationResult = await this.synchronize(instanceIndex);
                if (synchronizationResult) {
                    state.synchronized = true;
                    state.synchronizationRetryIntervalInSeconds = 1;
                    delete state.ensureSynchronizeTimeout;
                }
                this._scheduleSynchronizationTimeout(instanceIndex);
            } catch (err) {
                this._logger.error("MetaApi websocket client for account " + this._account.id + ":" + instanceIndex + " failed to synchronize", err);
                if (state.shouldSynchronize === key) {
                    if (state.ensureSynchronizeTimeout) {
                        clearTimeout(state.ensureSynchronizeTimeout);
                    }
                    state.ensureSynchronizeTimeout = setTimeout(this._ensureSynchronized.bind(this, instanceIndex, key), state.synchronizationRetryIntervalInSeconds * 1000);
                    state.synchronizationRetryIntervalInSeconds = Math.min(state.synchronizationRetryIntervalInSeconds * 2, 300);
                }
            }
        }
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex["" + instanceIndex]) {
            this._stateByInstanceIndex["" + instanceIndex] = {
                instanceIndex,
                ordersSynchronized: {},
                dealsSynchronized: {},
                shouldSynchronize: undefined,
                synchronizationRetryIntervalInSeconds: 1,
                synchronized: false,
                lastDisconnectedSynchronizationId: undefined,
                lastSynchronizationId: undefined,
                disconnected: false
            };
        }
        return this._stateByInstanceIndex["" + instanceIndex];
    }
    _scheduleSynchronizationTimeout(instanceIndex) {
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            if (state.synchronizationTimeout) {
                clearTimeout(state.synchronizationTimeout);
            }
            let synchronizationTimeout = 2 * 60 * 1000;
            state.synchronizationTimeout = setTimeout(()=>this._checkSynchronizationTimedOut(instanceIndex), synchronizationTimeout);
        }
    }
    _checkSynchronizationTimedOut(instanceIndex) {
        let state = this._getState(instanceIndex);
        if (state && !this._closed) {
            let synchronizationId = state.lastSynchronizationId;
            let synchronized = !!state.dealsSynchronized[synchronizationId];
            if (!synchronized && synchronizationId && state.shouldSynchronize) {
                this._logger.warn(`${this._account.id}:${instanceIndex}: resynchronized since latest synchronization ` + `${synchronizationId} did not finish in time`);
                this._ensureSynchronized(instanceIndex, state.shouldSynchronize);
            }
        }
    }
    /**
   * Constructs MetaApi MetaTrader streaming Api connection
   * @param {MetaApiWebsocketClient} websocketClient MetaApi websocket client
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetatraderAccount} account MetaTrader account id to connect to
   * @param {HistoryStorage} historyStorage terminal history storage. By default an instance of MemoryHistoryStorage
   * will be used.
   * @param {ConnectionRegistry} connectionRegistry metatrader account connection registry
   * @param {Date} [historyStartTime] history start sync time
   * @param {RefreshSubscriptionsOpts} [refreshSubscriptionsOpts] subscriptions refresh options
   */ constructor(websocketClient, terminalHashManager, account, historyStorage, connectionRegistry, historyStartTime, refreshSubscriptionsOpts){
        super(websocketClient, account);
        refreshSubscriptionsOpts = refreshSubscriptionsOpts || {};
        const validator = new _optionsValidator.default();
        this._minSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.minDelayInSeconds, 1, "refreshSubscriptionsOpts.minDelayInSeconds");
        this._maxSubscriptionRefreshInterval = validator.validateNonZero(refreshSubscriptionsOpts.maxDelayInSeconds, 600, "refreshSubscriptionsOpts.maxDelayInSeconds");
        this._connectionRegistry = connectionRegistry;
        this._historyStartTime = historyStartTime;
        this._terminalHashManager = terminalHashManager;
        this._terminalState = new _terminalState.default(account, terminalHashManager, this._websocketClient);
        this._historyStorage = historyStorage || new _memoryHistoryStorage.default();
        this._healthMonitor = new _connectionHealthMonitor.default(this);
        this._websocketClient.addSynchronizationListener(account.id, this);
        this._websocketClient.addSynchronizationListener(account.id, this._terminalState);
        this._websocketClient.addSynchronizationListener(account.id, this._historyStorage);
        this._websocketClient.addSynchronizationListener(account.id, this._healthMonitor);
        Object.values(account.accountRegions).forEach((replicaId)=>this._websocketClient.addReconnectListener(this, replicaId));
        this._subscriptions = {};
        this._stateByInstanceIndex = {};
        this._refreshMarketDataSubscriptionSessions = {};
        this._refreshMarketDataSubscriptionTimeouts = {};
        this._openedInstances = [];
        this._logger = _logger.default.getLogger("MetaApiConnection");
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUZXJtaW5hbFN0YXRlIGZyb20gJy4vdGVybWluYWxTdGF0ZSc7XG5pbXBvcnQgTWVtb3J5SGlzdG9yeVN0b3JhZ2UgZnJvbSAnLi9tZW1vcnlIaXN0b3J5U3RvcmFnZSc7XG5pbXBvcnQgVGltZW91dEVycm9yIGZyb20gJy4uL2NsaWVudHMvdGltZW91dEVycm9yJztcbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBDb25uZWN0aW9uSGVhbHRoTW9uaXRvciBmcm9tICcuL2Nvbm5lY3Rpb25IZWFsdGhNb25pdG9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yfSBmcm9tICcuLi9jbGllbnRzL2Vycm9ySGFuZGxlcic7XG5pbXBvcnQgT3B0aW9uc1ZhbGlkYXRvciBmcm9tICcuLi9jbGllbnRzL29wdGlvbnNWYWxpZGF0b3InO1xuaW1wb3J0IExvZ2dlck1hbmFnZXIgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCBNZXRhQXBpQ29ubmVjdGlvbiBmcm9tICcuL21ldGFBcGlDb25uZWN0aW9uJztcblxuLyoqXG4gKiBFeHBvc2VzIE1ldGFBcGkgTWV0YVRyYWRlciBzdHJlYW1pbmcgQVBJIGNvbm5lY3Rpb24gdG8gY29uc3VtZXJzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbWluZ01ldGFBcGlDb25uZWN0aW9uIGV4dGVuZHMgTWV0YUFwaUNvbm5lY3Rpb24ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIE1ldGFBcGkgTWV0YVRyYWRlciBzdHJlYW1pbmcgQXBpIGNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtNZXRhQXBpV2Vic29ja2V0Q2xpZW50fSB3ZWJzb2NrZXRDbGllbnQgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50XG4gICAqIEBwYXJhbSB7VGVybWluYWxIYXNoTWFuYWdlcn0gdGVybWluYWxIYXNoTWFuYWdlciB0ZXJtaW5hbCBoYXNoIG1hbmFnZXJcbiAgICogQHBhcmFtIHtNZXRhdHJhZGVyQWNjb3VudH0gYWNjb3VudCBNZXRhVHJhZGVyIGFjY291bnQgaWQgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0ge0hpc3RvcnlTdG9yYWdlfSBoaXN0b3J5U3RvcmFnZSB0ZXJtaW5hbCBoaXN0b3J5IHN0b3JhZ2UuIEJ5IGRlZmF1bHQgYW4gaW5zdGFuY2Ugb2YgTWVtb3J5SGlzdG9yeVN0b3JhZ2VcbiAgICogd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25SZWdpc3RyeX0gY29ubmVjdGlvblJlZ2lzdHJ5IG1ldGF0cmFkZXIgYWNjb3VudCBjb25uZWN0aW9uIHJlZ2lzdHJ5XG4gICAqIEBwYXJhbSB7RGF0ZX0gW2hpc3RvcnlTdGFydFRpbWVdIGhpc3Rvcnkgc3RhcnQgc3luYyB0aW1lXG4gICAqIEBwYXJhbSB7UmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzfSBbcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzXSBzdWJzY3JpcHRpb25zIHJlZnJlc2ggb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2Vic29ja2V0Q2xpZW50LCB0ZXJtaW5hbEhhc2hNYW5hZ2VyLCBhY2NvdW50LCBoaXN0b3J5U3RvcmFnZSwgY29ubmVjdGlvblJlZ2lzdHJ5LFxuICAgIGhpc3RvcnlTdGFydFRpbWUsIHJlZnJlc2hTdWJzY3JpcHRpb25zT3B0cykge1xuICAgIHN1cGVyKHdlYnNvY2tldENsaWVudCwgYWNjb3VudCk7XG4gICAgcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzID0gcmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzIHx8IHt9O1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgdGhpcy5fbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWluRGVsYXlJblNlY29uZHMsIDEsXG4gICAgICAncmVmcmVzaFN1YnNjcmlwdGlvbnNPcHRzLm1pbkRlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4U3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsID0gdmFsaWRhdG9yLnZhbGlkYXRlTm9uWmVybyhyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWF4RGVsYXlJblNlY29uZHMsIDYwMCxcbiAgICAgICdyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMubWF4RGVsYXlJblNlY29uZHMnKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uUmVnaXN0cnkgPSBjb25uZWN0aW9uUmVnaXN0cnk7XG4gICAgdGhpcy5faGlzdG9yeVN0YXJ0VGltZSA9IGhpc3RvcnlTdGFydFRpbWU7XG4gICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlciA9IHRlcm1pbmFsSGFzaE1hbmFnZXI7XG4gICAgdGhpcy5fdGVybWluYWxTdGF0ZSA9IG5ldyBUZXJtaW5hbFN0YXRlKGFjY291bnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIHRoaXMuX3dlYnNvY2tldENsaWVudCk7XG4gICAgdGhpcy5faGlzdG9yeVN0b3JhZ2UgPSBoaXN0b3J5U3RvcmFnZSB8fCBuZXcgTWVtb3J5SGlzdG9yeVN0b3JhZ2UoKTtcbiAgICB0aGlzLl9oZWFsdGhNb25pdG9yID0gbmV3IENvbm5lY3Rpb25IZWFsdGhNb25pdG9yKHRoaXMpO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRTeW5jaHJvbml6YXRpb25MaXN0ZW5lcihhY2NvdW50LmlkLCB0aGlzKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5fdGVybWluYWxTdGF0ZSk7XG4gICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LmFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnQuaWQsIHRoaXMuX2hpc3RvcnlTdG9yYWdlKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIoYWNjb3VudC5pZCwgdGhpcy5faGVhbHRoTW9uaXRvcik7XG4gICAgT2JqZWN0LnZhbHVlcyhhY2NvdW50LmFjY291bnRSZWdpb25zKVxuICAgICAgLmZvckVhY2gocmVwbGljYUlkID0+IHRoaXMuX3dlYnNvY2tldENsaWVudC5hZGRSZWNvbm5lY3RMaXN0ZW5lcih0aGlzLCByZXBsaWNhSWQpKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0ge307XG4gICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXggPSB7fTtcbiAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zID0ge307XG4gICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cyA9IHt9O1xuICAgIHRoaXMuX29wZW5lZEluc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdNZXRhQXBpQ29ubmVjdGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb25uZWN0aW9uLiBDYW4gb25seSBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUsIG5leHQgY2FsbHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJZCBjb25uZWN0aW9uIGluc3RhbmNlIGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgb3BlbmVkXG4gICAqL1xuICBhc3luYyBjb25uZWN0KGluc3RhbmNlSWQpIHtcbiAgICBpZighdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmluY2x1ZGVzKGluc3RhbmNlSWQpKSB7XG4gICAgICB0aGlzLl9vcGVuZWRJbnN0YW5jZXMucHVzaChpbnN0YW5jZUlkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfTogT3BlbmluZyBjb25uZWN0aW9uYCk7XG4gICAgICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgb3JkZXIgYW5kIHRyYW5zYWN0aW9uIGhpc3Rvcnkgb2YgYSBzcGVjaWZpZWQgYXBwbGljYXRpb24gYW5kIHJlbW92ZXMgYXBwbGljYXRpb25cbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSByZXNvbHZpbmcgd2hlbiB0aGUgaGlzdG9yeSBpcyBjbGVhcmVkIGFuZCBhcHBsaWNhdGlvbiBpcyByZW1vdmVkXG4gICAqL1xuICByZW1vdmVBcHBsaWNhdGlvbigpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHRoaXMuX2hpc3RvcnlTdG9yYWdlLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVBcHBsaWNhdGlvbih0aGlzLl9hY2NvdW50LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgdGVybWluYWwgdG8gc3RhcnQgc3luY2hyb25pemF0aW9uIHByb2Nlc3NcbiAgICogKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L3N5bmNocm9uaXppbmcvc3luY2hyb25pemUvKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICBhc3luYyBzeW5jaHJvbml6ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldFJlZ2lvbihpbnN0YW5jZUluZGV4KTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgaG9zdCA9IHRoaXMuZ2V0SG9zdE5hbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgbGV0IHN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSA9IG5ldyBEYXRlKE1hdGgubWF4KFxuICAgICAgKHRoaXMuX2hpc3RvcnlTdGFydFRpbWUgfHwgbmV3IERhdGUoMCkpLmdldFRpbWUoKSxcbiAgICAgIChhd2FpdCB0aGlzLl9oaXN0b3J5U3RvcmFnZS5sYXN0SGlzdG9yeU9yZGVyVGltZShpbnN0YW5jZSkpLmdldFRpbWUoKVxuICAgICkpO1xuICAgIGxldCBzdGFydGluZ0RlYWxUaW1lID0gbmV3IERhdGUoTWF0aC5tYXgoXG4gICAgICAodGhpcy5faGlzdG9yeVN0YXJ0VGltZSB8fCBuZXcgRGF0ZSgwKSkuZ2V0VGltZSgpLFxuICAgICAgKGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmxhc3REZWFsVGltZShpbnN0YW5jZSkpLmdldFRpbWUoKVxuICAgICkpO1xuICAgIGxldCBzeW5jaHJvbml6YXRpb25JZCA9IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMik7XG4gICAgdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkubGFzdFN5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQ7XG4gICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9uc1tyZWdpb25dO1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBpbml0aWF0aW5nIHN5bmNocm9uaXphdGlvbiAke3N5bmNocm9uaXphdGlvbklkfWApO1xuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3luY2hyb25pemUoYWNjb3VudElkLCBpbnN0YW5jZSwgaG9zdCwgc3luY2hyb25pemF0aW9uSWQsXG4gICAgICBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUsIHN0YXJ0aW5nRGVhbFRpbWUsIHRoaXMudGVybWluYWxTdGF0ZS5nZXRIYXNoZXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgbWV0YSBhcGkgY29ubmVjdGlvblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gbWV0YSBhcGkgY29ubmVjdGlvbiBpcyBpbml0aWFsaXplZFxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGF3YWl0IHRoaXMuX2hpc3RvcnlTdG9yYWdlLmluaXRpYWxpemUodGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fY29ubmVjdGlvblJlZ2lzdHJ5LmFwcGxpY2F0aW9uKTtcbiAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuYWRkQWNjb3VudENhY2hlKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBzdWJzY3JpcHRpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiBpcyBpbml0aWF0ZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZSgpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGNvbnN0IGFjY291bnRSZWdpb25zID0gdGhpcy5fYWNjb3VudC5hY2NvdW50UmVnaW9ucztcbiAgICBPYmplY3QudmFsdWVzKGFjY291bnRSZWdpb25zKS5mb3JFYWNoKHJlcGxpY2FJZCA9PiB7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMCk7XG4gICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZW5zdXJlU3Vic2NyaWJlKHJlcGxpY2FJZCwgMSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyBvbiBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3N1YnNjcmliZVRvTWFya2V0RGF0YS8pLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFTdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbiB0byBjcmVhdGUgb3IgdXBkYXRlLiBQbGVhc2VcbiAgICogbm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBpcyBub3QgZnVsbHkgaW1wbGVtZW50ZWQgb24gc2VydmVyLXNpZGUgeWV0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gdGltZW91dCB0byB3YWl0IGZvciBwcmljZXMgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3YWl0Rm9yUXVvdGVdIGlmIHNldCB0byBmYWxzZSwgdGhlIG1ldGhvZCB3aWxsIHJlc29sdmUgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgZmlyc3QgcXVvdGUgdG9cbiAgICogYXJyaXZlLiBEZWZhdWx0IGlzIHRvIHdhaXQgZm9yIHF1b3RlIGlmIHF1b3RlcyBzdWJzY3JpcHRpb24gaXMgcmVxdWVzdGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIHN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIHRpbWVvdXRJblNlY29uZHMsIHdhaXRGb3JRdW90ZSA9IHRydWUpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIGlmKCF0aGlzLl90ZXJtaW5hbFN0YXRlLnNwZWNpZmljYXRpb24oc3ltYm9sKSl7XG4gICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGAke3RoaXMuX2FjY291bnQuaWR9OiBDYW5ub3Qgc3Vic2NyaWJlIHRvIG1hcmtldCBkYXRhIGZvciBzeW1ib2wgJHtzeW1ib2x9IGJlY2F1c2UgYCArXG4gICAgICAnc3ltYm9sIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zIHx8IFt7dHlwZTogJ3F1b3Rlcyd9XTtcbiAgICAgIGlmKHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXSkge1xuICAgICAgICBjb25zdCBwcmV2U3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zO1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmlwdGlvbi50eXBlID09PSAnY2FuZGxlcycgPyBcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0udHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUgJiYgXG4gICAgICAgICAgICBpdGVtLnRpbWVmcmFtZSA9PT0gc3Vic2NyaXB0aW9uLnRpbWVmcmFtZSkgOlxuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50eXBlID09PSBzdWJzY3JpcHRpb24udHlwZSk7XG4gICAgICAgICAgaWYoaW5kZXggPT09IC0xKXtcbiAgICAgICAgICAgIHByZXZTdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldlN1YnNjcmlwdGlvbnNbaW5kZXhdID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0gPSB7c3Vic2NyaXB0aW9uc307XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQuc3Vic2NyaWJlVG9NYXJrZXREYXRhKHRoaXMuX2FjY291bnQuaWQsIHN5bWJvbCwgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgdGhpcy5fYWNjb3VudC5yZWxpYWJpbGl0eSk7XG4gICAgICBpZiAod2FpdEZvclF1b3RlICE9PSBmYWxzZSAmJiBzdWJzY3JpcHRpb25zLmZpbmQocyA9PiBzLnR5cGUgPT09ICdxdW90ZXMnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbFN0YXRlLndhaXRGb3JQcmljZShzeW1ib2wsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBtYXJrZXQgZGF0YSBvZiBzcGVjaWZpZWQgc3ltYm9sIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L3dlYnNvY2tldC9tYXJrZXREYXRhU3RyZWFtaW5nL3Vuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEvKS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdW5zdWJzY3JpcHRpb24gcmVxdWVzdCB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICB1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhKHN5bWJvbCwgc3Vic2NyaXB0aW9ucykge1xuICAgIHRoaXMuX2NoZWNrSXNDb25uZWN0aW9uQWN0aXZlKCk7XG4gICAgaWYgKCFzdWJzY3JpcHRpb25zKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF0uc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXS5zdWJzY3JpcHRpb25zXG4gICAgICAgIC5maWx0ZXIocyA9PiBzLnR5cGUgPT09ICdjYW5kbGVzJyA/IFxuICAgICAgICAgICFzdWJzY3JpcHRpb25zLmZpbmQoczIgPT4gcy50eXBlID09PSBzMi50eXBlICYmIHMudGltZWZyYW1lID09PSBzMi50aW1lZnJhbWUpIDogXG4gICAgICAgICAgIXN1YnNjcmlwdGlvbnMuZmluZChzMiA9PiBzLnR5cGUgPT09IHMyLnR5cGUpKTtcbiAgICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdLnN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zW3N5bWJvbF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93ZWJzb2NrZXRDbGllbnQudW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YSh0aGlzLl9hY2NvdW50LmlkLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsXG4gICAgICB0aGlzLl9hY2NvdW50LnJlbGlhYmlsaXR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gc3Vic2NyaXB0aW9uIGRvd25ncmFkZSBoYXMgb2NjdXJyZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gdXBkYXRlIHN1YnNjcmlwdGlvbnMgZm9yXG4gICAqIEBwYXJhbSB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IHVwZGF0ZXMgYXJyYXkgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge0FycmF5PE1hcmtldERhdGFVbnN1YnNjcmlwdGlvbj59IHVuc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBzdWJzY3JpcHRpb25zIHRvIGNhbmNlbFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIG9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBzeW1ib2wsIHVwZGF0ZXMsIHVuc3Vic2NyaXB0aW9ucykge1xuICAgIGxldCBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IFtdO1xuICAgIGlmICh1bnN1YnNjcmlwdGlvbnMgJiYgdW5zdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgc3Vic2NyaXB0aW9uIG9mIHVuc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMgPSBzdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMudHlwZSA9PT0gc3Vic2NyaXB0aW9uLnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoc3ltYm9sLCB1bnN1YnNjcmlwdGlvbnMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIubmFtZSAhPT0gVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7dGhpcy5fYWNjb3VudC5pZH06IGZhaWxlZCBkbyB1bnN1YnNjcmliZSBmcm9tIG1hcmtldCBkYXRhIG9uIHN1YnNjcmlwdGlvbiBkb3duZ3JhZGVkYCxcbiAgICAgICAgICAgICAgZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke3RoaXMuX2FjY291bnQuaWR9OiBmYWlsZWQgZG8gdW5zdWJzY3JpYmUgZnJvbSBtYXJrZXQgZGF0YSBvbiBzdWJzY3JpcHRpb24gZG93bmdyYWRlZGAsXG4gICAgICAgICAgICAgIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMgJiYgdXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IHN1YnNjcmlwdGlvbiBvZiB1cGRhdGVzKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5maWx0ZXIocyA9PiBzLnR5cGUgPT09IHN1YnNjcmlwdGlvbi50eXBlKVxuICAgICAgICAgICAgLmZvckVhY2gocyA9PiBzLmludGVydmFsSW5NaWxsaWlzZWNvbmRzID0gc3Vic2NyaXB0aW9uLmludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN1YnNjcmliZVRvTWFya2V0RGF0YShzeW1ib2wsIHVwZGF0ZXMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHt0aGlzLl9hY2NvdW50LmlkfTogZmFpbGVkIGRvIHVuc3Vic2NyaWJlIGZyb20gbWFya2V0IGRhdGEgb24gc3Vic2NyaXB0aW9uIGRvd25ncmFkZWRgLFxuICAgICAgICAgICAgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb25zICYmICFzdWJzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNbc3ltYm9sXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIHRoZSBzeW1ib2xzIGNvbm5lY3Rpb24gaXMgc3Vic2NyaWJlZCB0b1xuICAgKiBAcmV0dXJucyB7QXJyYXk8U3RyaW5nPn0gbGlzdCBvZiB0aGUgc3ltYm9scyBjb25uZWN0aW9uIGlzIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCBzdWJzY3JpYmVkU3ltYm9scygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdWJzY3JpcHRpb25zIGZvciBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb25zIGZvclxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWFya2V0RGF0YVN1YnNjcmlwdGlvbj59IGxpc3Qgb2YgbWFya2V0IGRhdGEgc3Vic2NyaXB0aW9ucyBmb3IgdGhlIHN5bWJvbFxuICAgKi9cbiAgc3Vic2NyaXB0aW9ucyhzeW1ib2wpIHtcbiAgICB0aGlzLl9jaGVja0lzQ29ubmVjdGlvbkFjdGl2ZSgpO1xuICAgIHJldHVybiAodGhpcy5fc3Vic2NyaXB0aW9uc1tzeW1ib2xdIHx8IHt9KS5zdWJzY3JpcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbG9jYWwgY29weSBvZiB0ZXJtaW5hbCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7VGVybWluYWxTdGF0ZX0gbG9jYWwgY29weSBvZiB0ZXJtaW5hbCBzdGF0ZVxuICAgKi9cbiAgZ2V0IHRlcm1pbmFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rlcm1pbmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsb2NhbCBoaXN0b3J5IHN0b3JhZ2VcbiAgICogQHJldHVybnMge0hpc3RvcnlTdG9yYWdlfSBsb2NhbCBoaXN0b3J5IHN0b3JhZ2VcbiAgICovXG4gIGdldCBoaXN0b3J5U3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGlzdG9yeVN0b3JhZ2U7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVwbGljYXMgbnVtYmVyIG9mIGFjY291bnQgcmVwbGljYXMgbGF1bmNoZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvbkNvbm5lY3RlZChpbnN0YW5jZUluZGV4LCByZXBsaWNhcykge1xuICAgIGxldCBrZXkgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuY2FuY2VsUmVmcmVzaChyZWdpb24pO1xuICAgIGF3YWl0IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVmcmVzaElnbm9yZWRGaWVsZExpc3RzKHJlZ2lvbik7XG4gICAgc3RhdGUuc2hvdWxkU3luY2hyb25pemUgPSBrZXk7XG4gICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgc3RhdGUuc3luY2hyb25pemVkID0gZmFsc2U7XG4gICAgdGhpcy5fZW5zdXJlU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGtleSk7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IGNvbm5lY3RlZCB0byBicm9rZXJgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIHRlcm1pbmF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICovXG4gIGFzeW5jIG9uRGlzY29ubmVjdGVkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5sYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQgPSBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQ7XG4gICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnNob3VsZFN5bmNocm9uaXplID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IGZhbHNlO1xuICAgIHN0YXRlLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSB0aGlzLmdldEluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgIGlmIChzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dCk7XG4gICAgICBkZWxldGUgc3RhdGUuc3luY2hyb25pemF0aW9uVGltZW91dDtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgICBkZWxldGUgc3RhdGUuZW5zdXJlU3luY2hyb25pemVUaW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZGlzY29ubmVjdGVkIGZyb20gYnJva2VyYCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3ltYm9sIHNwZWNpZmljYXRpb25zIHdlcmUgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gc3BlY2lmaWNhdGlvbnMgdXBkYXRlZCBzcGVjaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHJlbW92ZWRTeW1ib2xzIHJlbW92ZWQgc3ltYm9sc1xuICAgKi9cbiAgb25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwb3NpdGlvbiBzeW5jaHJvbml6YXRpb24gZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW4gaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqL1xuICBvblBvc2l0aW9uc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gcGVuZGluZyBvcmRlciBzeW5jaHJvbml6YXRpb24gZm5pc2hlZCB0byBpbmRpY2F0ZSBwcm9ncmVzcyBvZiBhbiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlXG4gICAqIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3luY2hyb25pemF0aW9uSWQgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWRcbiAgICovXG4gIG9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzeW5jaHJvbml6YXRpb24gb2YgaGlzdG9yeSBkZWFscyBvbiBhIE1ldGFUcmFkZXIgYWNjb3VudCBoYXZlIGZpbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuXG4gICAqIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5kZWFsc1N5bmNocm9uaXplZFtzeW5jaHJvbml6YXRpb25JZF0gPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogZmluaXNoZWQgc3luY2hyb25pemF0aW9uICR7c3luY2hyb25pemF0aW9uSWR9YCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGEgc3luY2hyb25pemF0aW9uIG9mIGhpc3Rvcnkgb3JkZXJzIG9uIGEgTWV0YVRyYWRlciBhY2NvdW50IGhhdmUgZmluaXNoZWQgdG8gaW5kaWNhdGUgcHJvZ3Jlc3Mgb2YgYW5cbiAgICogaW5pdGlhbCB0ZXJtaW5hbCBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUub3JkZXJzU3luY2hyb25pemVkW3N5bmNocm9uaXphdGlvbklkXSA9IHRydWU7XG4gICAgdGhpcy5fc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0KGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBjb25uZWN0aW9uIHRvIE1ldGFBcGkgd2Vic29ja2V0IEFQSSByZXN0b3JlZCBhZnRlciBhIGRpc2Nvbm5lY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiByZWNvbm5lY3RlZCByZWdpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIHJlY29ubmVjdGVkIGluc3RhbmNlIG51bWJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY29ubmVjdGlvbiB0byBNZXRhQXBpIHdlYnNvY2tldCBBUEkgcmVzdG9yZWQgYWZ0ZXIgYSBkaXNjb25uZWN0XG4gICAqL1xuICBhc3luYyBvblJlY29ubmVjdGVkKHJlZ2lvbiwgaW5zdGFuY2VOdW1iZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZVRlbXBsYXRlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpXG4gICAgICAuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChgJHtpbnN0YW5jZVRlbXBsYXRlfTpgKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhba2V5XTtcbiAgICAgIH0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlVGVtcGxhdGVdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlVGVtcGxhdGVdKTtcbiAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZVRlbXBsYXRlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIGlzIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWNpZmljYXRpb25zSGFzaCBzcGVjaWZpY2F0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbnNIYXNoIHBvc2l0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcnNIYXNoIG9yZGVycyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLCBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiBzdGFydGluZyBzeW5jaHJvbml6YXRpb24gJHtzeW5jaHJvbml6YXRpb25JZH1gKTtcbiAgICBjb25zdCBpbnN0YW5jZU51bWJlciA9IHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRSZWdpb24oaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9YDtcbiAgICBjb25zdCBhY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zW3JlZ2lvbl07XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdO1xuICAgIGxldCBzZXNzaW9uSWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnNbaW5zdGFuY2VdID0gc2Vzc2lvbklkO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblRpbWVvdXRzW2luc3RhbmNlXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyhhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCBzZXNzaW9uSWQpO1xuICAgIHRoaXMuX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KTtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkID0gc3luY2hyb25pemF0aW9uSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhY2NvdW50IHJlZ2lvbiBoYXMgYmVlbiB1bnN1YnNjcmliZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBhY2NvdW50IHJlZ2lvbiB1bnN1YnNjcmliZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblVuc3Vic2NyaWJlUmVnaW9uKHJlZ2lvbikge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMpXG4gICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7cmVnaW9ufTpgKSlcbiAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHNbaW5zdGFuY2VdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV07XG4gICAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleClcbiAgICAgIC5maWx0ZXIoaW5zdGFuY2UgPT4gaW5zdGFuY2Uuc3RhcnRzV2l0aChgJHtyZWdpb259OmApKVxuICAgICAgLmZvckVhY2goaW5zdGFuY2UgPT4gZGVsZXRlIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIG9wdGlvbmFsIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkLCBsYXN0IHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkIHdpbGwgYmUgdXNlZFxuICAgKiBieSBkZWZhdWx0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8Qm9vbGVhbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYSBmbGFnIGluZGljYXRpbmcgc3RhdHVzIG9mIHN0YXRlIHN5bmNocm9uaXphdGlvbiB3aXRoIE1ldGFUcmFkZXJcbiAgICogdGVybWluYWxcbiAgICovXG4gIGFzeW5jIGlzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2VJbmRleCAhPT0gdW5kZWZpbmVkICYmIHMuaW5zdGFuY2VJbmRleCAhPT0gaW5zdGFuY2VJbmRleCkge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hlY2tTeW5jaHJvbml6YXRpb25JZCA9IHN5bmNocm9uaXphdGlvbklkIHx8IHMubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgICAgbGV0IHN5bmNocm9uaXplZCA9ICEhcy5vcmRlcnNTeW5jaHJvbml6ZWRbY2hlY2tTeW5jaHJvbml6YXRpb25JZF0gJiYgXG4gICAgICAgICEhcy5kZWFsc1N5bmNocm9uaXplZFtjaGVja1N5bmNocm9uaXphdGlvbklkXTtcbiAgICAgIHJldHVybiBhY2MgfHwgc3luY2hyb25pemVkO1xuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTeW5jaHJvbml6YXRpb25PcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYXBwbGljYXRpb25QYXR0ZXJuXSBhcHBsaWNhdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiwgZGVmYXVsdCBpcyAuKlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3N5bmNocm9uaXphdGlvbklkXSBzeW5jaHJvbml6YXRpb24gaWQsIGxhc3Qgc3luY2hyb25pemF0aW9uIHJlcXVlc3QgaWQgd2lsbCBiZSB1c2VkIGJ5XG4gICAqIGRlZmF1bHRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtpbnN0YW5jZUluZGV4XSBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIHRvIGVuc3VyZSBzeW5jaHJvbml6YXRpb24gb24sIGRlZmF1bHQgaXMgdG8gd2FpdFxuICAgKiBmb3IgdGhlIGZpcnN0IGluc3RhbmNlIHRvIHN5bmNocm9uaXplXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gd2FpdCB0aW1lb3V0IGluIHNlY29uZHMsIGRlZmF1bHQgaXMgNW1cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtpbnRlcnZhbEluTWlsbGlzZWNvbmRzXSBpbnRlcnZhbCBiZXR3ZWVuIGFjY291bnQgcmVsb2FkcyB3aGlsZSB3YWl0aW5nIGZvciBhIGNoYW5nZSwgZGVmYXVsdCBpcyAxc1xuICAgKi9cblxuICAvKipcbiAgICogV2FpdHMgdW50aWwgc3luY2hyb25pemF0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uT3B0aW9uc30gb3B0cyBzeW5jaHJvbml6YXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29tcGxldGVkXG4gICAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gaWYgYXBwbGljYXRpb24gZmFpbGVkIHRvIHN5bmNocm9uaXplIHdpdGggdGhlIHRlbWluYWwgd2l0aGluIHRpbWVvdXQgYWxsb3dlZFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgd2FpdFN5bmNocm9uaXplZChvcHRzKSB7XG4gICAgdGhpcy5fY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUoKTtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBsZXQgaW5zdGFuY2VJbmRleCA9IG9wdHMuaW5zdGFuY2VJbmRleDtcbiAgICBsZXQgc3luY2hyb25pemF0aW9uSWQgPSBvcHRzLnN5bmNocm9uaXphdGlvbklkO1xuICAgIGxldCB0aW1lb3V0SW5TZWNvbmRzID0gb3B0cy50aW1lb3V0SW5TZWNvbmRzIHx8IDMwMDtcbiAgICBsZXQgaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IG9wdHMuaW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyB8fCAxMDAwO1xuICAgIGxldCBhcHBsaWNhdGlvblBhdHRlcm4gPSBvcHRzLmFwcGxpY2F0aW9uUGF0dGVybiB8fFxuICAgICAgKHRoaXMuX2FjY291bnQuYXBwbGljYXRpb24gPT09ICdDb3B5RmFjdG9yeScgPyAnQ29weUZhY3RvcnkuKnxSUEMnIDogJ1JQQycpO1xuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBzeW5jaHJvbml6ZWQ7XG4gICAgd2hpbGUgKCEoc3luY2hyb25pemVkID0gYXdhaXQgdGhpcy5pc1N5bmNocm9uaXplZChpbnN0YW5jZUluZGV4LCBzeW5jaHJvbml6YXRpb25JZCkpICYmXG4gICAgICAoc3RhcnRUaW1lICsgdGltZW91dEluU2Vjb25kcyAqIDEwMDApID4gRGF0ZS5ub3coKSkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCBpbnRlcnZhbEluTWlsbGlzZWNvbmRzKSk7XG4gICAgfVxuICAgIGxldCBzdGF0ZTtcbiAgICBpZiAoaW5zdGFuY2VJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpKSB7XG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzU3luY2hyb25pemVkKHMuaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpKSB7XG4gICAgICAgICAgc3RhdGUgPSBzO1xuICAgICAgICAgIGluc3RhbmNlSW5kZXggPSBzLmluc3RhbmNlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5maW5kKHMgPT4gcy5pbnN0YW5jZUluZGV4ID09PSBpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgaWYgKCFzeW5jaHJvbml6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBUaW1lb3V0RXJyb3IoJ1RpbWVkIG91dCB3YWl0aW5nIGZvciBNZXRhQXBpIHRvIHN5bmNocm9uaXplIHRvIE1ldGFUcmFkZXIgYWNjb3VudCAnICtcbiAgICAgICAgdGhpcy5fYWNjb3VudC5pZCArICcsIHN5bmNocm9uaXphdGlvbiBpZCAnICsgKHN5bmNocm9uaXphdGlvbklkIHx8IChzdGF0ZSAmJiBzdGF0ZS5sYXN0U3luY2hyb25pemF0aW9uSWQpIHx8XG4gICAgICAgICAgKHN0YXRlICYmIHN0YXRlLmxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCkpKTtcbiAgICB9XG4gICAgbGV0IHRpbWVMZWZ0SW5TZWNvbmRzID0gTWF0aC5tYXgoMCwgdGltZW91dEluU2Vjb25kcyAtIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0UmVnaW9uKHN0YXRlLmluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IHRoaXMuX2FjY291bnQuYWNjb3VudFJlZ2lvbnNbcmVnaW9uXTtcbiAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQud2FpdFN5bmNocm9uaXplZChhY2NvdW50SWQsIHRoaXMuZ2V0SW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleCksXG4gICAgICBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVMZWZ0SW5TZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uIFRoZSBpbnN0YW5jZSBvZiB0aGUgY2xhc3Mgc2hvdWxkIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIHRoaXMgbWV0aG9kIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUlkIGNvbm5lY3Rpb24gaW5zdGFuY2UgaWRcbiAgICovXG4gIGFzeW5jIGNsb3NlKGluc3RhbmNlSWQpIHtcbiAgICBpZiAodGhpcy5fb3BlbmVkKSB7XG4gICAgICB0aGlzLl9vcGVuZWRJbnN0YW5jZXMgPSB0aGlzLl9vcGVuZWRJbnN0YW5jZXMuZmlsdGVyKGlkID0+IGlkICE9PSBpbnN0YW5jZUlkKTtcbiAgICAgIGlmICghdGhpcy5fb3BlbmVkSW5zdGFuY2VzLmxlbmd0aCAmJiAhdGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVmcmVzaEpvYik7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHt0aGlzLl9hY2NvdW50LmlkfTogQ2xvc2luZyBjb25uZWN0aW9uYCk7XG4gICAgICAgIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4ID0ge307XG4gICAgICAgIGF3YWl0IHRoaXMuX2Nvbm5lY3Rpb25SZWdpc3RyeS5yZW1vdmVTdHJlYW1pbmcodGhpcy5fYWNjb3VudCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmFsU3RhdGUuY2xvc2UoKTtcbiAgICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbnMgPSB0aGlzLl9hY2NvdW50LmFjY291bnRSZWdpb25zO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIodGhpcy5fYWNjb3VudC5pZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldENsaWVudC5yZW1vdmVTeW5jaHJvbml6YXRpb25MaXN0ZW5lcih0aGlzLl9hY2NvdW50LmlkLCB0aGlzLl90ZXJtaW5hbFN0YXRlKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2hpc3RvcnlTdG9yYWdlKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2hlYWx0aE1vbml0b3IpO1xuICAgICAgICB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX2hlYWx0aE1vbml0b3Iuc3RvcCgpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cykuZm9yRWFjaCh0aW1lb3V0ID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uVGltZW91dHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhhY2NvdW50UmVnaW9ucykuZm9yRWFjaChyZXBsaWNhSWQgPT4gXG4gICAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlbW92ZUFjY291bnRDYWNoZShyZXBsaWNhSWQpKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKGAke3RoaXMuX2FjY291bnQuaWR9OiBDbG9zZWQgY29ubmVjdGlvbmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN5bmNocm9uaXphdGlvbiBzdGF0dXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gc3luY2hyb25pemF0aW9uIHN0YXR1c1xuICAgKi9cbiAgZ2V0IHN5bmNocm9uaXplZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCkucmVkdWNlKChhY2MsIHMpID0+IGFjYyB8fCBzLnN5bmNocm9uaXplZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgTWV0YUFwaSBhY2NvdW50XG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJBY2NvdW50fSBNZXRhQXBpIGFjY291bnRcbiAgICovXG4gIGdldCBhY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtDb25uZWN0aW9uSGVhbHRoTW9uaXRvcn0gY29ubmVjdGlvbiBoZWFsdGggbW9uaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGhlYWx0aE1vbml0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWx0aE1vbml0b3I7XG4gIH1cblxuICBhc3luYyBfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pIHtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLl93ZWJzb2NrZXRDbGllbnQuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfWA7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9yZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvblNlc3Npb25zW2luc3RhbmNlXSA9PT0gc2Vzc2lvbikge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zTGlzdCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucyhrZXkpO1xuICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNJdGVtID0ge3N5bWJvbDoga2V5fTtcbiAgICAgICAgICBpZihzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zSXRlbS5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QucHVzaChzdWJzY3JpcHRpb25zSXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLl93ZWJzb2NrZXRDbGllbnQucmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uc0xpc3QpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvciByZWZyZXNoaW5nIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgam9iIGZvciBhY2NvdW50ICR7dGhpcy5fYWNjb3VudC5pZH0gYCArXG4gICAgICBgJHtpbnN0YW5jZU51bWJlcn1gLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25TZXNzaW9uc1tpbnN0YW5jZV0gPT09IHNlc3Npb24pIHtcbiAgICAgICAgbGV0IHJlZnJlc2hJbnRlcnZhbCA9IChNYXRoLnJhbmRvbSgpICogKHRoaXMuX21heFN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCAtIFxuICAgICAgICAgIHRoaXMuX21pblN1YnNjcmlwdGlvblJlZnJlc2hJbnRlcnZhbCkgKyB0aGlzLl9taW5TdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwpICogMTAwMDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0c1tpbnN0YW5jZV0gPSBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHNlc3Npb24pLCByZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZVN0b3BPcHRpb25zKHN0b3BMb3NzLCB0YWtlUHJvZml0KSB7XG4gICAgbGV0IHRyYWRlID0ge307XG4gICAgaWYgKHR5cGVvZiBzdG9wTG9zcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyYWRlLnN0b3BMb3NzID0gc3RvcExvc3M7XG4gICAgfSBlbHNlIGlmIChzdG9wTG9zcykge1xuICAgICAgdHJhZGUuc3RvcExvc3MgPSBzdG9wTG9zcy52YWx1ZTtcbiAgICAgIHRyYWRlLnN0b3BMb3NzVW5pdHMgPSBzdG9wTG9zcy51bml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWtlUHJvZml0ID09PSAnbnVtYmVyJykge1xuICAgICAgdHJhZGUudGFrZVByb2ZpdCA9IHRha2VQcm9maXQ7XG4gICAgfSBlbHNlIGlmICh0YWtlUHJvZml0KSB7XG4gICAgICB0cmFkZS50YWtlUHJvZml0ID0gdGFrZVByb2ZpdC52YWx1ZTtcbiAgICAgIHRyYWRlLnRha2VQcm9maXRVbml0cyA9IHRha2VQcm9maXQudW5pdHM7XG4gICAgfVxuICAgIHJldHVybiB0cmFkZTtcbiAgfVxuXG4gIGFzeW5jIF9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwga2V5KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnNob3VsZFN5bmNocm9uaXplICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN5bmNocm9uaXphdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuc3luY2hyb25pemUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgIGlmKHN5bmNocm9uaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXplZCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyA9IDE7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2hlZHVsZVN5bmNocm9uaXphdGlvblRpbWVvdXQoaW5zdGFuY2VJbmRleCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgZm9yIGFjY291bnQgJyArIHRoaXMuX2FjY291bnQuaWQgK1xuICAgICAgICAgICc6JyArIGluc3RhbmNlSW5kZXggKyAnIGZhaWxlZCB0byBzeW5jaHJvbml6ZScsIGVycik7XG4gICAgICAgIGlmIChzdGF0ZS5zaG91bGRTeW5jaHJvbml6ZSA9PT0ga2V5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmVuc3VyZVN5bmNocm9uaXplVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fZW5zdXJlU3luY2hyb25pemVkLmJpbmQodGhpcywgaW5zdGFuY2VJbmRleCwga2V5KSxcbiAgICAgICAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblJldHJ5SW50ZXJ2YWxJblNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgICBzdGF0ZS5zeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzID0gTWF0aC5taW4oc3RhdGUuc3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyAqIDIsIDMwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkge1xuICAgIGlmICghdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSkge1xuICAgICAgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbJycgKyBpbnN0YW5jZUluZGV4XSA9IHtcbiAgICAgICAgaW5zdGFuY2VJbmRleCxcbiAgICAgICAgb3JkZXJzU3luY2hyb25pemVkOiB7fSxcbiAgICAgICAgZGVhbHNTeW5jaHJvbml6ZWQ6IHt9LFxuICAgICAgICBzaG91bGRTeW5jaHJvbml6ZTogdW5kZWZpbmVkLFxuICAgICAgICBzeW5jaHJvbml6YXRpb25SZXRyeUludGVydmFsSW5TZWNvbmRzOiAxLFxuICAgICAgICBzeW5jaHJvbml6ZWQ6IGZhbHNlLFxuICAgICAgICBsYXN0RGlzY29ubmVjdGVkU3luY2hyb25pemF0aW9uSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdFN5bmNocm9uaXphdGlvbklkOiB1bmRlZmluZWQsXG4gICAgICAgIGRpc2Nvbm5lY3RlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdO1xuICB9XG5cbiAgX3NjaGVkdWxlU3luY2hyb25pemF0aW9uVGltZW91dChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYgKHN0YXRlICYmICF0aGlzLl9jbG9zZWQpIHtcbiAgICAgIGlmIChzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5zeW5jaHJvbml6YXRpb25UaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGxldCBzeW5jaHJvbml6YXRpb25UaW1lb3V0ID0gMiAqIDYwICogMTAwMDtcbiAgICAgIHN0YXRlLnN5bmNocm9uaXphdGlvblRpbWVvdXQgPVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2NoZWNrU3luY2hyb25pemF0aW9uVGltZWRPdXQoaW5zdGFuY2VJbmRleCksIHN5bmNocm9uaXphdGlvblRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIF9jaGVja1N5bmNocm9uaXphdGlvblRpbWVkT3V0KGluc3RhbmNlSW5kZXgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZiAoc3RhdGUgJiYgIXRoaXMuX2Nsb3NlZCkge1xuICAgICAgbGV0IHN5bmNocm9uaXphdGlvbklkID0gc3RhdGUubGFzdFN5bmNocm9uaXphdGlvbklkO1xuICAgICAgbGV0IHN5bmNocm9uaXplZCA9ICEhc3RhdGUuZGVhbHNTeW5jaHJvbml6ZWRbc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgaWYgKCFzeW5jaHJvbml6ZWQgJiYgc3luY2hyb25pemF0aW9uSWQgJiYgc3RhdGUuc2hvdWxkU3luY2hyb25pemUpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogcmVzeW5jaHJvbml6ZWQgc2luY2UgbGF0ZXN0IHN5bmNocm9uaXphdGlvbiBgICtcbiAgICAgICAgICBgJHtzeW5jaHJvbml6YXRpb25JZH0gZGlkIG5vdCBmaW5pc2ggaW4gdGltZWApO1xuICAgICAgICB0aGlzLl9lbnN1cmVTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3RhdGUuc2hvdWxkU3luY2hyb25pemUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iXSwibmFtZXMiOlsiU3RyZWFtaW5nTWV0YUFwaUNvbm5lY3Rpb24iLCJNZXRhQXBpQ29ubmVjdGlvbiIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwiX29wZW5lZEluc3RhbmNlcyIsImluY2x1ZGVzIiwicHVzaCIsIl9vcGVuZWQiLCJfbG9nZ2VyIiwidHJhY2UiLCJfYWNjb3VudCIsImlkIiwiaW5pdGlhbGl6ZSIsInN1YnNjcmliZSIsImVyciIsImNsb3NlIiwicmVtb3ZlQXBwbGljYXRpb24iLCJfY2hlY2tJc0Nvbm5lY3Rpb25BY3RpdmUiLCJfaGlzdG9yeVN0b3JhZ2UiLCJjbGVhciIsIl93ZWJzb2NrZXRDbGllbnQiLCJzeW5jaHJvbml6ZSIsImluc3RhbmNlSW5kZXgiLCJyZWdpb24iLCJnZXRSZWdpb24iLCJpbnN0YW5jZSIsImdldEluc3RhbmNlTnVtYmVyIiwiaG9zdCIsImdldEhvc3ROYW1lIiwic3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lIiwiRGF0ZSIsIk1hdGgiLCJtYXgiLCJfaGlzdG9yeVN0YXJ0VGltZSIsImdldFRpbWUiLCJsYXN0SGlzdG9yeU9yZGVyVGltZSIsInN0YXJ0aW5nRGVhbFRpbWUiLCJsYXN0RGVhbFRpbWUiLCJzeW5jaHJvbml6YXRpb25JZCIsInJhbmRvbXN0cmluZyIsImdlbmVyYXRlIiwiX2dldFN0YXRlIiwibGFzdFN5bmNocm9uaXphdGlvbklkIiwiYWNjb3VudElkIiwiYWNjb3VudFJlZ2lvbnMiLCJkZWJ1ZyIsInRlcm1pbmFsU3RhdGUiLCJnZXRIYXNoZXMiLCJfY29ubmVjdGlvblJlZ2lzdHJ5IiwiYXBwbGljYXRpb24iLCJhZGRBY2NvdW50Q2FjaGUiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwicmVwbGljYUlkIiwiZW5zdXJlU3Vic2NyaWJlIiwic3Vic2NyaWJlVG9NYXJrZXREYXRhIiwic3ltYm9sIiwic3Vic2NyaXB0aW9ucyIsInRpbWVvdXRJblNlY29uZHMiLCJ3YWl0Rm9yUXVvdGUiLCJfdGVybWluYWxTdGF0ZSIsInNwZWNpZmljYXRpb24iLCJWYWxpZGF0aW9uRXJyb3IiLCJ0eXBlIiwiX3N1YnNjcmlwdGlvbnMiLCJwcmV2U3Vic2NyaXB0aW9ucyIsInN1YnNjcmlwdGlvbiIsImluZGV4IiwiZmluZEluZGV4IiwiaXRlbSIsInRpbWVmcmFtZSIsInJlbGlhYmlsaXR5IiwiZmluZCIsInMiLCJ3YWl0Rm9yUHJpY2UiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwiZmlsdGVyIiwiczIiLCJsZW5ndGgiLCJvblN1YnNjcmlwdGlvbkRvd25ncmFkZWQiLCJ1cGRhdGVzIiwidW5zdWJzY3JpcHRpb25zIiwiY2F0Y2giLCJuYW1lIiwiZXJyb3IiLCJpbnRlcnZhbEluTWlsbGlpc2Vjb25kcyIsImludGVydmFsSW5NaWxsaXNlY29uZHMiLCJzdWJzY3JpYmVkU3ltYm9scyIsImtleXMiLCJoaXN0b3J5U3RvcmFnZSIsIm9uQ29ubmVjdGVkIiwicmVwbGljYXMiLCJrZXkiLCJzdGF0ZSIsImNhbmNlbFJlZnJlc2giLCJfdGVybWluYWxIYXNoTWFuYWdlciIsInJlZnJlc2hJZ25vcmVkRmllbGRMaXN0cyIsInNob3VsZFN5bmNocm9uaXplIiwic3luY2hyb25pemF0aW9uUmV0cnlJbnRlcnZhbEluU2Vjb25kcyIsInN5bmNocm9uaXplZCIsIl9lbnN1cmVTeW5jaHJvbml6ZWQiLCJvbkRpc2Nvbm5lY3RlZCIsImxhc3REaXNjb25uZWN0ZWRTeW5jaHJvbml6YXRpb25JZCIsInVuZGVmaW5lZCIsImRpc2Nvbm5lY3RlZCIsImluc3RhbmNlTnVtYmVyIiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9uU2Vzc2lvbnMiLCJjbGVhclRpbWVvdXQiLCJfcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25UaW1lb3V0cyIsInN5bmNocm9uaXphdGlvblRpbWVvdXQiLCJlbnN1cmVTeW5jaHJvbml6ZVRpbWVvdXQiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInNwZWNpZmljYXRpb25zIiwicmVtb3ZlZFN5bWJvbHMiLCJfc2NoZWR1bGVTeW5jaHJvbml6YXRpb25UaW1lb3V0Iiwib25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQiLCJvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQiLCJvbkRlYWxzU3luY2hyb25pemVkIiwiZGVhbHNTeW5jaHJvbml6ZWQiLCJvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWQiLCJvcmRlcnNTeW5jaHJvbml6ZWQiLCJvblJlY29ubmVjdGVkIiwiaW5zdGFuY2VUZW1wbGF0ZSIsIl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCIsInN0YXJ0c1dpdGgiLCJvblN0cmVhbUNsb3NlZCIsIm9uU3luY2hyb25pemF0aW9uU3RhcnRlZCIsInNwZWNpZmljYXRpb25zSGFzaCIsInBvc2l0aW9uc0hhc2giLCJvcmRlcnNIYXNoIiwic2Vzc2lvbklkIiwiX3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsIl9jbG9zZWQiLCJvblVuc3Vic2NyaWJlUmVnaW9uIiwiaXNTeW5jaHJvbml6ZWQiLCJyZWR1Y2UiLCJhY2MiLCJjaGVja1N5bmNocm9uaXphdGlvbklkIiwid2FpdFN5bmNocm9uaXplZCIsIm9wdHMiLCJhcHBsaWNhdGlvblBhdHRlcm4iLCJzdGFydFRpbWUiLCJub3ciLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsIlRpbWVvdXRFcnJvciIsInRpbWVMZWZ0SW5TZWNvbmRzIiwiY2xlYXJJbnRlcnZhbCIsIl9yZWZyZXNoSm9iIiwicmVtb3ZlU3RyZWFtaW5nIiwicmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJfaGVhbHRoTW9uaXRvciIsInJlbW92ZVJlY29ubmVjdExpc3RlbmVyIiwic3RvcCIsInRpbWVvdXQiLCJyZW1vdmVBY2NvdW50Q2FjaGUiLCJhY2NvdW50IiwiaGVhbHRoTW9uaXRvciIsInNlc3Npb24iLCJnZXRBY2NvdW50UmVnaW9uIiwic3Vic2NyaXB0aW9uc0xpc3QiLCJzdWJzY3JpcHRpb25zSXRlbSIsInJlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucyIsInJlZnJlc2hJbnRlcnZhbCIsInJhbmRvbSIsIl9tYXhTdWJzY3JpcHRpb25SZWZyZXNoSW50ZXJ2YWwiLCJfbWluU3Vic2NyaXB0aW9uUmVmcmVzaEludGVydmFsIiwiX2dlbmVyYXRlU3RvcE9wdGlvbnMiLCJzdG9wTG9zcyIsInRha2VQcm9maXQiLCJ0cmFkZSIsInZhbHVlIiwic3RvcExvc3NVbml0cyIsInVuaXRzIiwidGFrZVByb2ZpdFVuaXRzIiwic3luY2hyb25pemF0aW9uUmVzdWx0IiwiYmluZCIsIm1pbiIsIl9jaGVja1N5bmNocm9uaXphdGlvblRpbWVkT3V0Iiwid2FybiIsImNvbnN0cnVjdG9yIiwid2Vic29ja2V0Q2xpZW50IiwidGVybWluYWxIYXNoTWFuYWdlciIsImNvbm5lY3Rpb25SZWdpc3RyeSIsImhpc3RvcnlTdGFydFRpbWUiLCJyZWZyZXNoU3Vic2NyaXB0aW9uc09wdHMiLCJ2YWxpZGF0b3IiLCJPcHRpb25zVmFsaWRhdG9yIiwidmFsaWRhdGVOb25aZXJvIiwibWluRGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsIlRlcm1pbmFsU3RhdGUiLCJNZW1vcnlIaXN0b3J5U3RvcmFnZSIsIkNvbm5lY3Rpb25IZWFsdGhNb25pdG9yIiwiYWRkU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJhZGRSZWNvbm5lY3RMaXN0ZW5lciIsIkxvZ2dlck1hbmFnZXIiLCJnZXRMb2dnZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O2VBZXFCQTs7O3NFQWJLOzZFQUNPO3FFQUNSO3FFQUNBO2dGQUNXOzhCQUNOO3lFQUNEOytEQUNIOzBFQUNJOzs7Ozs7QUFLZixJQUFBLEFBQU1BLDZCQUFOLE1BQU1BLG1DQUFtQ0MsMEJBQWlCO0lBMEN2RTs7OztHQUlDLEdBQ0QsTUFBTUMsUUFBUUMsVUFBVSxFQUFFO1FBQ3hCLElBQUcsQ0FBQyxJQUFJLENBQUNDLGdCQUFnQixDQUFDQyxRQUFRLENBQUNGLGFBQWE7WUFDOUMsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0UsSUFBSSxDQUFDSDtRQUM3QjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNJLE9BQU8sRUFBRTtZQUNqQixJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsRUFBRSxDQUFDLG9CQUFvQixDQUFDO1lBQzVELElBQUksQ0FBQ0osT0FBTyxHQUFHO1lBQ2YsSUFBSTtnQkFDRixNQUFNLElBQUksQ0FBQ0ssVUFBVTtnQkFDckIsTUFBTSxJQUFJLENBQUNDLFNBQVM7WUFDdEIsRUFBRSxPQUFPQyxLQUFLO2dCQUNaLE1BQU0sSUFBSSxDQUFDQyxLQUFLO2dCQUNoQixNQUFNRDtZQUNSO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNERSxvQkFBb0I7UUFDbEIsSUFBSSxDQUFDQyx3QkFBd0I7UUFDN0IsSUFBSSxDQUFDQyxlQUFlLENBQUNDLEtBQUs7UUFDMUIsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDSixpQkFBaUIsQ0FBQyxJQUFJLENBQUNOLFFBQVEsQ0FBQ0MsRUFBRTtJQUNqRTtJQUVBOzs7OztHQUtDLEdBQ0QsTUFBTVUsWUFBWUMsYUFBYSxFQUFFO1FBQy9CLElBQUksQ0FBQ0wsd0JBQXdCO1FBQzdCLE1BQU1NLFNBQVMsSUFBSSxDQUFDQyxTQUFTLENBQUNGO1FBQzlCLE1BQU1HLFdBQVcsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0o7UUFDeEMsTUFBTUssT0FBTyxJQUFJLENBQUNDLFdBQVcsQ0FBQ047UUFDOUIsSUFBSU8sMkJBQTJCLElBQUlDLEtBQUtDLEtBQUtDLEdBQUcsQ0FDOUMsQUFBQyxDQUFBLElBQUksQ0FBQ0MsaUJBQWlCLElBQUksSUFBSUgsS0FBSyxFQUFDLEVBQUdJLE9BQU8sSUFDL0MsQUFBQyxDQUFBLE1BQU0sSUFBSSxDQUFDaEIsZUFBZSxDQUFDaUIsb0JBQW9CLENBQUNWLFNBQVEsRUFBR1MsT0FBTztRQUVyRSxJQUFJRSxtQkFBbUIsSUFBSU4sS0FBS0MsS0FBS0MsR0FBRyxDQUN0QyxBQUFDLENBQUEsSUFBSSxDQUFDQyxpQkFBaUIsSUFBSSxJQUFJSCxLQUFLLEVBQUMsRUFBR0ksT0FBTyxJQUMvQyxBQUFDLENBQUEsTUFBTSxJQUFJLENBQUNoQixlQUFlLENBQUNtQixZQUFZLENBQUNaLFNBQVEsRUFBR1MsT0FBTztRQUU3RCxJQUFJSSxvQkFBb0JDLHFCQUFZLENBQUNDLFFBQVEsQ0FBQztRQUM5QyxJQUFJLENBQUNDLFNBQVMsQ0FBQ25CLGVBQWVvQixxQkFBcUIsR0FBR0o7UUFDdEQsTUFBTUssWUFBWSxJQUFJLENBQUNqQyxRQUFRLENBQUNrQyxjQUFjLENBQUNyQixPQUFPO1FBQ3RELElBQUksQ0FBQ2YsT0FBTyxDQUFDcUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNuQyxRQUFRLENBQUNDLEVBQUUsQ0FBQyxDQUFDLEVBQUVXLGNBQWMsNkJBQTZCLEVBQUVnQixrQkFBa0IsQ0FBQztRQUMxRyxPQUFPLElBQUksQ0FBQ2xCLGdCQUFnQixDQUFDQyxXQUFXLENBQUNzQixXQUFXbEIsVUFBVUUsTUFBTVcsbUJBQ2xFVCwwQkFBMEJPLGtCQUFrQixJQUFJLENBQUNVLGFBQWEsQ0FBQ0MsU0FBUztJQUM1RTtJQUVBOzs7R0FHQyxHQUNELE1BQU1uQyxhQUFhO1FBQ2pCLElBQUksQ0FBQ0ssd0JBQXdCO1FBQzdCLE1BQU0sSUFBSSxDQUFDQyxlQUFlLENBQUNOLFVBQVUsQ0FBQyxJQUFJLENBQUNGLFFBQVEsQ0FBQ0MsRUFBRSxFQUFFLElBQUksQ0FBQ3FDLG1CQUFtQixDQUFDQyxXQUFXO1FBQzVGLElBQUksQ0FBQzdCLGdCQUFnQixDQUFDOEIsZUFBZSxDQUFDLElBQUksQ0FBQ3hDLFFBQVEsQ0FBQ0MsRUFBRSxFQUFFLElBQUksQ0FBQ0QsUUFBUSxDQUFDa0MsY0FBYztJQUN0RjtJQUVBOzs7R0FHQyxHQUNELE1BQU0vQixZQUFZO1FBQ2hCLElBQUksQ0FBQ0ksd0JBQXdCO1FBQzdCLE1BQU0yQixpQkFBaUIsSUFBSSxDQUFDbEMsUUFBUSxDQUFDa0MsY0FBYztRQUNuRE8sT0FBT0MsTUFBTSxDQUFDUixnQkFBZ0JTLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDcEMsSUFBSSxDQUFDbEMsZ0JBQWdCLENBQUNtQyxlQUFlLENBQUNELFdBQVc7WUFDakQsSUFBSSxDQUFDbEMsZ0JBQWdCLENBQUNtQyxlQUFlLENBQUNELFdBQVc7UUFDbkQ7SUFDRjtJQUVBOzs7Ozs7Ozs7O0dBVUMsR0FDRCxNQUFNRSxzQkFBc0JDLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxnQkFBZ0IsRUFBRUMsZUFBZSxJQUFJLEVBQUU7UUFDeEYsSUFBSSxDQUFDM0Msd0JBQXdCO1FBQzdCLElBQUcsQ0FBQyxJQUFJLENBQUM0QyxjQUFjLENBQUNDLGFBQWEsQ0FBQ0wsU0FBUTtZQUM1QyxNQUFNLElBQUlNLDZCQUFlLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ3JELFFBQVEsQ0FBQ0MsRUFBRSxDQUFDLDZDQUE2QyxFQUFFOEMsT0FBTyxTQUFTLENBQUMsR0FDOUc7UUFDRixPQUFPO1lBQ0xDLGdCQUFnQkEsaUJBQWlCO2dCQUFDO29CQUFDTSxNQUFNO2dCQUFRO2FBQUU7WUFDbkQsSUFBRyxJQUFJLENBQUNDLGNBQWMsQ0FBQ1IsT0FBTyxFQUFFO2dCQUM5QixNQUFNUyxvQkFBb0IsSUFBSSxDQUFDRCxjQUFjLENBQUNSLE9BQU8sQ0FBQ0MsYUFBYTtnQkFDbkVBLGNBQWNMLE9BQU8sQ0FBQ2MsQ0FBQUE7b0JBQ3BCLE1BQU1DLFFBQVFELGFBQWFILElBQUksS0FBSyxZQUNsQ0Usa0JBQWtCRyxTQUFTLENBQUNDLENBQUFBLE9BQVFBLEtBQUtOLElBQUksS0FBS0csYUFBYUgsSUFBSSxJQUNuRU0sS0FBS0MsU0FBUyxLQUFLSixhQUFhSSxTQUFTLElBQ3pDTCxrQkFBa0JHLFNBQVMsQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS04sSUFBSSxLQUFLRyxhQUFhSCxJQUFJO29CQUNyRSxJQUFHSSxVQUFVLENBQUMsR0FBRTt3QkFDZEYsa0JBQWtCNUQsSUFBSSxDQUFDNkQ7b0JBQ3pCLE9BQU87d0JBQ0xELGlCQUFpQixDQUFDRSxNQUFNLEdBQUdEO29CQUM3QjtnQkFDRjtZQUNGLE9BQU87Z0JBQ0wsSUFBSSxDQUFDRixjQUFjLENBQUNSLE9BQU8sR0FBRztvQkFBQ0M7Z0JBQWE7WUFDOUM7WUFDQSxNQUFNLElBQUksQ0FBQ3RDLGdCQUFnQixDQUFDb0MscUJBQXFCLENBQUMsSUFBSSxDQUFDOUMsUUFBUSxDQUFDQyxFQUFFLEVBQUU4QyxRQUFRQyxlQUMxRSxJQUFJLENBQUNoRCxRQUFRLENBQUM4RCxXQUFXO1lBQzNCLElBQUlaLGlCQUFpQixTQUFTRixjQUFjZSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVWLElBQUksS0FBSyxXQUFXO2dCQUMxRSxPQUFPLElBQUksQ0FBQ2xCLGFBQWEsQ0FBQzZCLFlBQVksQ0FBQ2xCLFFBQVFFO1lBQ2pEO1FBQ0Y7SUFDRjtJQUVBOzs7Ozs7R0FNQyxHQUNEaUIsMEJBQTBCbkIsTUFBTSxFQUFFQyxhQUFhLEVBQUU7UUFDL0MsSUFBSSxDQUFDekMsd0JBQXdCO1FBQzdCLElBQUksQ0FBQ3lDLGVBQWU7WUFDbEIsT0FBTyxJQUFJLENBQUNPLGNBQWMsQ0FBQ1IsT0FBTztRQUNwQyxPQUFPLElBQUksSUFBSSxDQUFDUSxjQUFjLENBQUNSLE9BQU8sRUFBRTtZQUN0QyxJQUFJLENBQUNRLGNBQWMsQ0FBQ1IsT0FBTyxDQUFDQyxhQUFhLEdBQUcsSUFBSSxDQUFDTyxjQUFjLENBQUNSLE9BQU8sQ0FBQ0MsYUFBYSxDQUNsRm1CLE1BQU0sQ0FBQ0gsQ0FBQUEsSUFBS0EsRUFBRVYsSUFBSSxLQUFLLFlBQ3RCLENBQUNOLGNBQWNlLElBQUksQ0FBQ0ssQ0FBQUEsS0FBTUosRUFBRVYsSUFBSSxLQUFLYyxHQUFHZCxJQUFJLElBQUlVLEVBQUVILFNBQVMsS0FBS08sR0FBR1AsU0FBUyxJQUM1RSxDQUFDYixjQUFjZSxJQUFJLENBQUNLLENBQUFBLEtBQU1KLEVBQUVWLElBQUksS0FBS2MsR0FBR2QsSUFBSTtZQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDQyxjQUFjLENBQUNSLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDcUIsTUFBTSxFQUFFO2dCQUNyRCxPQUFPLElBQUksQ0FBQ2QsY0FBYyxDQUFDUixPQUFPO1lBQ3BDO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQ3JDLGdCQUFnQixDQUFDd0QseUJBQXlCLENBQUMsSUFBSSxDQUFDbEUsUUFBUSxDQUFDQyxFQUFFLEVBQUU4QyxRQUFRQyxlQUMvRSxJQUFJLENBQUNoRCxRQUFRLENBQUM4RCxXQUFXO0lBQzdCO0lBRUE7Ozs7Ozs7R0FPQyxHQUNELHNDQUFzQztJQUN0QyxNQUFNUSx5QkFBeUIxRCxhQUFhLEVBQUVtQyxNQUFNLEVBQUV3QixPQUFPLEVBQUVDLGVBQWUsRUFBRTtRQUM5RSxJQUFJeEIsZ0JBQWdCLElBQUksQ0FBQ08sY0FBYyxDQUFDUixPQUFPLElBQUksRUFBRTtRQUNyRCxJQUFJeUIsbUJBQW1CQSxnQkFBZ0JILE1BQU0sRUFBRTtZQUM3QyxJQUFJckIsZUFBZTtnQkFDakIsS0FBSyxJQUFJUyxnQkFBZ0JlLGdCQUFpQjtvQkFDeEN4QixnQkFBZ0JBLGNBQWNtQixNQUFNLENBQUNILENBQUFBLElBQUtBLEVBQUVWLElBQUksS0FBS0csYUFBYUgsSUFBSTtnQkFDeEU7WUFDRjtZQUNBLElBQUksQ0FBQ1kseUJBQXlCLENBQUNuQixRQUFReUIsaUJBQ3BDQyxLQUFLLENBQUNyRSxDQUFBQTtnQkFDTCxJQUFJQSxJQUFJc0UsSUFBSSxLQUFLckIsNkJBQWUsRUFBRTtvQkFDaEMsSUFBSSxDQUFDdkQsT0FBTyxDQUFDNkUsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMzRSxRQUFRLENBQUNDLEVBQUUsQ0FBQyxtRUFBbUUsQ0FBQyxFQUN6R0c7Z0JBQ0osT0FBTztvQkFDTCxJQUFJLENBQUNOLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsRUFBRSxDQUFDLG1FQUFtRSxDQUFDLEVBQ3pHRztnQkFDSjtZQUNGO1FBQ0o7UUFDQSxJQUFJbUUsV0FBV0EsUUFBUUYsTUFBTSxFQUFFO1lBQzdCLElBQUlyQixlQUFlO2dCQUNqQixLQUFLLElBQUlTLGdCQUFnQmMsUUFBUztvQkFDaEN2QixjQUFjbUIsTUFBTSxDQUFDSCxDQUFBQSxJQUFLQSxFQUFFVixJQUFJLEtBQUtHLGFBQWFILElBQUksRUFDbkRYLE9BQU8sQ0FBQ3FCLENBQUFBLElBQUtBLEVBQUVZLHVCQUF1QixHQUFHbkIsYUFBYW9CLHNCQUFzQjtnQkFDakY7WUFDRjtZQUNBLElBQUksQ0FBQy9CLHFCQUFxQixDQUFDQyxRQUFRd0IsU0FDaENFLEtBQUssQ0FBQ3JFLENBQUFBO2dCQUNMLElBQUksQ0FBQ04sT0FBTyxDQUFDNkUsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMzRSxRQUFRLENBQUNDLEVBQUUsQ0FBQyxtRUFBbUUsQ0FBQyxFQUN6R0c7WUFDSjtRQUNKO1FBQ0EsSUFBSTRDLGlCQUFpQixDQUFDQSxjQUFjcUIsTUFBTSxFQUFFO1lBQzFDLE9BQU8sSUFBSSxDQUFDZCxjQUFjLENBQUNSLE9BQU87UUFDcEM7SUFDRjtJQUVBOzs7R0FHQyxHQUNELElBQUkrQixvQkFBb0I7UUFDdEIsT0FBT3JDLE9BQU9zQyxJQUFJLENBQUMsSUFBSSxDQUFDeEIsY0FBYztJQUN4QztJQUVBOzs7O0dBSUMsR0FDRFAsY0FBY0QsTUFBTSxFQUFFO1FBQ3BCLElBQUksQ0FBQ3hDLHdCQUF3QjtRQUM3QixPQUFPLEFBQUMsQ0FBQSxJQUFJLENBQUNnRCxjQUFjLENBQUNSLE9BQU8sSUFBSSxDQUFDLENBQUEsRUFBR0MsYUFBYTtJQUMxRDtJQUVBOzs7R0FHQyxHQUNELElBQUlaLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ2UsY0FBYztJQUM1QjtJQUVBOzs7R0FHQyxHQUNELElBQUk2QixpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUN4RSxlQUFlO0lBQzdCO0lBRUE7Ozs7O0dBS0MsR0FDRCxNQUFNeUUsWUFBWXJFLGFBQWEsRUFBRXNFLFFBQVEsRUFBRTtRQUN6QyxJQUFJQyxNQUFNdEQscUJBQVksQ0FBQ0MsUUFBUSxDQUFDO1FBQ2hDLElBQUlzRCxRQUFRLElBQUksQ0FBQ3JELFNBQVMsQ0FBQ25CO1FBQzNCLE1BQU1DLFNBQVMsSUFBSSxDQUFDQyxTQUFTLENBQUNGO1FBQzlCLElBQUksQ0FBQ3lFLGFBQWEsQ0FBQ3hFO1FBQ25CLE1BQU0sSUFBSSxDQUFDeUUsb0JBQW9CLENBQUNDLHdCQUF3QixDQUFDMUU7UUFDekR1RSxNQUFNSSxpQkFBaUIsR0FBR0w7UUFDMUJDLE1BQU1LLHFDQUFxQyxHQUFHO1FBQzlDTCxNQUFNTSxZQUFZLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQy9FLGVBQWV1RTtRQUN4QyxJQUFJLENBQUNyRixPQUFPLENBQUNxQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25DLFFBQVEsQ0FBQ0MsRUFBRSxDQUFDLENBQUMsRUFBRVcsY0FBYyxxQkFBcUIsQ0FBQztJQUNoRjtJQUVBOzs7R0FHQyxHQUNELE1BQU1nRixlQUFlaEYsYUFBYSxFQUFFO1FBQ2xDLElBQUl3RSxRQUFRLElBQUksQ0FBQ3JELFNBQVMsQ0FBQ25CO1FBQzNCd0UsTUFBTVMsaUNBQWlDLEdBQUdULE1BQU1wRCxxQkFBcUI7UUFDckVvRCxNQUFNcEQscUJBQXFCLEdBQUc4RDtRQUM5QlYsTUFBTUksaUJBQWlCLEdBQUdNO1FBQzFCVixNQUFNTSxZQUFZLEdBQUc7UUFDckJOLE1BQU1XLFlBQVksR0FBRztRQUNyQixNQUFNQyxpQkFBaUIsSUFBSSxDQUFDaEYsaUJBQWlCLENBQUNKO1FBQzlDLE1BQU1DLFNBQVMsSUFBSSxDQUFDQyxTQUFTLENBQUNGO1FBQzlCLE1BQU1HLFdBQVcsQ0FBQyxFQUFFRixPQUFPLENBQUMsRUFBRW1GLGVBQWUsQ0FBQztRQUM5QyxPQUFPLElBQUksQ0FBQ0Msc0NBQXNDLENBQUNsRixTQUFTO1FBQzVEbUYsYUFBYSxJQUFJLENBQUNDLHNDQUFzQyxDQUFDcEYsU0FBUztRQUNsRSxPQUFPLElBQUksQ0FBQ29GLHNDQUFzQyxDQUFDcEYsU0FBUztRQUM1RCxJQUFJcUUsTUFBTWdCLHNCQUFzQixFQUFFO1lBQ2hDRixhQUFhZCxNQUFNZ0Isc0JBQXNCO1lBQ3pDLE9BQU9oQixNQUFNZ0Isc0JBQXNCO1FBQ3JDO1FBQ0EsSUFBSWhCLE1BQU1pQix3QkFBd0IsRUFBRTtZQUNsQ0gsYUFBYWQsTUFBTWlCLHdCQUF3QjtZQUMzQyxPQUFPakIsTUFBTWlCLHdCQUF3QjtRQUN2QztRQUNBLElBQUksQ0FBQ3ZHLE9BQU8sQ0FBQ3FDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDbkMsUUFBUSxDQUFDQyxFQUFFLENBQUMsQ0FBQyxFQUFFVyxjQUFjLDBCQUEwQixDQUFDO0lBQ3JGO0lBRUE7Ozs7O0dBS0MsR0FDRDBGLDhCQUE4QjFGLGFBQWEsRUFBRTJGLGNBQWMsRUFBRUMsY0FBYyxFQUFFO1FBQzNFLElBQUksQ0FBQ0MsK0JBQStCLENBQUM3RjtJQUN2QztJQUVBOzs7O0dBSUMsR0FDRDhGLHdCQUF3QjlGLGFBQWEsRUFBRWdCLGlCQUFpQixFQUFFO1FBQ3hELElBQUksQ0FBQzZFLCtCQUErQixDQUFDN0Y7SUFDdkM7SUFFQTs7Ozs7R0FLQyxHQUNEK0YsNEJBQTRCL0YsYUFBYSxFQUFFZ0IsaUJBQWlCLEVBQUU7UUFDNUQsSUFBSSxDQUFDNkUsK0JBQStCLENBQUM3RjtJQUN2QztJQUVBOzs7Ozs7R0FNQyxHQUNELE1BQU1nRyxvQkFBb0JoRyxhQUFhLEVBQUVnQixpQkFBaUIsRUFBRTtRQUMxRCxJQUFJd0QsUUFBUSxJQUFJLENBQUNyRCxTQUFTLENBQUNuQjtRQUMzQndFLE1BQU15QixpQkFBaUIsQ0FBQ2pGLGtCQUFrQixHQUFHO1FBQzdDLElBQUksQ0FBQzZFLCtCQUErQixDQUFDN0Y7UUFDckMsSUFBSSxDQUFDZCxPQUFPLENBQUNxQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25DLFFBQVEsQ0FBQ0MsRUFBRSxDQUFDLENBQUMsRUFBRVcsY0FBYywyQkFBMkIsRUFBRWdCLGtCQUFrQixDQUFDO0lBQzFHO0lBRUE7Ozs7OztHQU1DLEdBQ0QsTUFBTWtGLDRCQUE0QmxHLGFBQWEsRUFBRWdCLGlCQUFpQixFQUFFO1FBQ2xFLElBQUl3RCxRQUFRLElBQUksQ0FBQ3JELFNBQVMsQ0FBQ25CO1FBQzNCd0UsTUFBTTJCLGtCQUFrQixDQUFDbkYsa0JBQWtCLEdBQUc7UUFDOUMsSUFBSSxDQUFDNkUsK0JBQStCLENBQUM3RjtJQUN2QztJQUVBOzs7OztHQUtDLEdBQ0QsTUFBTW9HLGNBQWNuRyxNQUFNLEVBQUVtRixjQUFjLEVBQUU7UUFDMUMsTUFBTWlCLG1CQUFtQixDQUFDLEVBQUVwRyxPQUFPLENBQUMsRUFBRW1GLGVBQWUsQ0FBQztRQUN0RHZELE9BQU9zQyxJQUFJLENBQUMsSUFBSSxDQUFDbUMscUJBQXFCLEVBQ25DL0MsTUFBTSxDQUFDZ0IsQ0FBQUEsTUFBT0EsSUFBSWdDLFVBQVUsQ0FBQyxDQUFDLEVBQUVGLGlCQUFpQixDQUFDLENBQUMsR0FBR3RFLE9BQU8sQ0FBQ3dDLENBQUFBO1lBQzdELE9BQU8sSUFBSSxDQUFDK0IscUJBQXFCLENBQUMvQixJQUFJO1FBQ3hDO1FBQ0YsT0FBTyxJQUFJLENBQUNjLHNDQUFzQyxDQUFDZ0IsaUJBQWlCO1FBQ3BFZixhQUFhLElBQUksQ0FBQ0Msc0NBQXNDLENBQUNjLGlCQUFpQjtRQUMxRSxPQUFPLElBQUksQ0FBQ2Qsc0NBQXNDLENBQUNjLGlCQUFpQjtJQUN0RTtJQUVBOzs7O0dBSUMsR0FDRCxNQUFNRyxlQUFleEcsYUFBYSxFQUFFO1FBQ2xDLE9BQU8sSUFBSSxDQUFDc0cscUJBQXFCLENBQUN0RyxjQUFjO0lBQ2xEO0lBRUE7Ozs7Ozs7O0dBUUMsR0FDRCxNQUFNeUcseUJBQXlCekcsYUFBYSxFQUFFMEcsa0JBQWtCLEVBQUVDLGFBQWEsRUFBRUMsVUFBVSxFQUFFNUYsaUJBQWlCLEVBQUU7UUFDOUcsSUFBSSxDQUFDOUIsT0FBTyxDQUFDcUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNuQyxRQUFRLENBQUNDLEVBQUUsQ0FBQyxDQUFDLEVBQUVXLGNBQWMsMkJBQTJCLEVBQUVnQixrQkFBa0IsQ0FBQztRQUN4RyxNQUFNb0UsaUJBQWlCLElBQUksQ0FBQ2hGLGlCQUFpQixDQUFDSjtRQUM5QyxNQUFNQyxTQUFTLElBQUksQ0FBQ0MsU0FBUyxDQUFDRjtRQUM5QixNQUFNRyxXQUFXLENBQUMsRUFBRUYsT0FBTyxDQUFDLEVBQUVtRixlQUFlLENBQUM7UUFDOUMsTUFBTS9ELFlBQVksSUFBSSxDQUFDakMsUUFBUSxDQUFDa0MsY0FBYyxDQUFDckIsT0FBTztRQUN0RCxPQUFPLElBQUksQ0FBQ29GLHNDQUFzQyxDQUFDbEYsU0FBUztRQUM1RCxJQUFJMEcsWUFBWTVGLHFCQUFZLENBQUNDLFFBQVEsQ0FBQztRQUN0QyxJQUFJLENBQUNtRSxzQ0FBc0MsQ0FBQ2xGLFNBQVMsR0FBRzBHO1FBQ3hEdkIsYUFBYSxJQUFJLENBQUNDLHNDQUFzQyxDQUFDcEYsU0FBUztRQUNsRSxPQUFPLElBQUksQ0FBQ29GLHNDQUFzQyxDQUFDcEYsU0FBUztRQUM1RCxNQUFNLElBQUksQ0FBQzJHLCtCQUErQixDQUFDekYsV0FBVytELGdCQUFnQnlCO1FBQ3RFLElBQUksQ0FBQ2hCLCtCQUErQixDQUFDN0Y7UUFDckMsSUFBSXdFLFFBQVEsSUFBSSxDQUFDckQsU0FBUyxDQUFDbkI7UUFDM0IsSUFBSXdFLFNBQVMsQ0FBQyxJQUFJLENBQUN1QyxPQUFPLEVBQUU7WUFDMUJ2QyxNQUFNcEQscUJBQXFCLEdBQUdKO1FBQ2hDO0lBQ0Y7SUFFQTs7OztHQUlDLEdBQ0RnRyxvQkFBb0IvRyxNQUFNLEVBQUU7UUFDMUI0QixPQUFPc0MsSUFBSSxDQUFDLElBQUksQ0FBQ29CLHNDQUFzQyxFQUNwRGhDLE1BQU0sQ0FBQ3BELENBQUFBLFdBQVlBLFNBQVNvRyxVQUFVLENBQUMsQ0FBQyxFQUFFdEcsT0FBTyxDQUFDLENBQUMsR0FDbkQ4QixPQUFPLENBQUM1QixDQUFBQTtZQUNQbUYsYUFBYSxJQUFJLENBQUNDLHNDQUFzQyxDQUFDcEYsU0FBUztZQUNsRSxPQUFPLElBQUksQ0FBQ29GLHNDQUFzQyxDQUFDcEYsU0FBUztZQUM1RCxPQUFPLElBQUksQ0FBQ2tGLHNDQUFzQyxDQUFDbEYsU0FBUztRQUM5RDtRQUNGMEIsT0FBT3NDLElBQUksQ0FBQyxJQUFJLENBQUNtQyxxQkFBcUIsRUFDbkMvQyxNQUFNLENBQUNwRCxDQUFBQSxXQUFZQSxTQUFTb0csVUFBVSxDQUFDLENBQUMsRUFBRXRHLE9BQU8sQ0FBQyxDQUFDLEdBQ25EOEIsT0FBTyxDQUFDNUIsQ0FBQUEsV0FBWSxPQUFPLElBQUksQ0FBQ21HLHFCQUFxQixDQUFDbkcsU0FBUztJQUNwRTtJQUVBOzs7Ozs7O0dBT0MsR0FDRCxNQUFNOEcsZUFBZWpILGFBQWEsRUFBRWdCLGlCQUFpQixFQUFFO1FBQ3JELE9BQU9hLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLENBQUN3RSxxQkFBcUIsRUFBRVksTUFBTSxDQUFDLENBQUNDLEtBQUsvRDtZQUM1RCxJQUFJcEQsa0JBQWtCa0YsYUFBYTlCLEVBQUVwRCxhQUFhLEtBQUtBLGVBQWU7Z0JBQ3BFLE9BQU9tSDtZQUNUO1lBQ0EsTUFBTUMseUJBQXlCcEcscUJBQXFCb0MsRUFBRWhDLHFCQUFxQjtZQUMzRSxJQUFJMEQsZUFBZSxDQUFDLENBQUMxQixFQUFFK0Msa0JBQWtCLENBQUNpQix1QkFBdUIsSUFDL0QsQ0FBQyxDQUFDaEUsRUFBRTZDLGlCQUFpQixDQUFDbUIsdUJBQXVCO1lBQy9DLE9BQU9ELE9BQU9yQztRQUNoQixHQUFHO0lBQ0w7SUFFQTs7Ozs7Ozs7O0dBU0MsR0FFRDs7Ozs7R0FLQyxHQUNELHNDQUFzQztJQUN0QyxNQUFNdUMsaUJBQWlCQyxJQUFJLEVBQUU7UUFDM0IsSUFBSSxDQUFDM0gsd0JBQXdCO1FBQzdCMkgsT0FBT0EsUUFBUSxDQUFDO1FBQ2hCLElBQUl0SCxnQkFBZ0JzSCxLQUFLdEgsYUFBYTtRQUN0QyxJQUFJZ0Isb0JBQW9Cc0csS0FBS3RHLGlCQUFpQjtRQUM5QyxJQUFJcUIsbUJBQW1CaUYsS0FBS2pGLGdCQUFnQixJQUFJO1FBQ2hELElBQUk0Qix5QkFBeUJxRCxLQUFLckQsc0JBQXNCLElBQUk7UUFDNUQsSUFBSXNELHFCQUFxQkQsS0FBS0Msa0JBQWtCLElBQzdDLENBQUEsSUFBSSxDQUFDbkksUUFBUSxDQUFDdUMsV0FBVyxLQUFLLGdCQUFnQixzQkFBc0IsS0FBSTtRQUMzRSxJQUFJNkYsWUFBWWhILEtBQUtpSCxHQUFHO1FBQ3hCLElBQUkzQztRQUNKLE1BQU8sQ0FBRUEsQ0FBQUEsZUFBZSxNQUFNLElBQUksQ0FBQ21DLGNBQWMsQ0FBQ2pILGVBQWVnQixrQkFBaUIsS0FDaEYsQUFBQ3dHLFlBQVluRixtQkFBbUIsT0FBUTdCLEtBQUtpSCxHQUFHLEdBQUk7WUFDcEQsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxNQUFPQyxXQUFXRCxLQUFLMUQ7UUFDM0M7UUFDQSxJQUFJTztRQUNKLElBQUl4RSxrQkFBa0JrRixXQUFXO1lBQy9CLEtBQUssSUFBSTlCLEtBQUt2QixPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDd0UscUJBQXFCLEVBQUc7Z0JBQ3ZELElBQUksTUFBTSxJQUFJLENBQUNXLGNBQWMsQ0FBQzdELEVBQUVwRCxhQUFhLEVBQUVnQixvQkFBb0I7b0JBQ2pFd0QsUUFBUXBCO29CQUNScEQsZ0JBQWdCb0QsRUFBRXBELGFBQWE7Z0JBQ2pDO1lBQ0Y7UUFDRixPQUFPO1lBQ0x3RSxRQUFRM0MsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ3dFLHFCQUFxQixFQUFFbkQsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEQsYUFBYSxLQUFLQTtRQUNsRjtRQUNBLElBQUksQ0FBQzhFLGNBQWM7WUFDakIsTUFBTSxJQUFJK0MscUJBQVksQ0FBQyx3RUFDckIsSUFBSSxDQUFDekksUUFBUSxDQUFDQyxFQUFFLEdBQUcsMEJBQTJCMkIsQ0FBQUEscUJBQXNCd0QsU0FBU0EsTUFBTXBELHFCQUFxQixJQUNyR29ELFNBQVNBLE1BQU1TLGlDQUFpQztRQUN2RDtRQUNBLElBQUk2QyxvQkFBb0JySCxLQUFLQyxHQUFHLENBQUMsR0FBRzJCLG1CQUFtQixBQUFDN0IsQ0FBQUEsS0FBS2lILEdBQUcsS0FBS0QsU0FBUSxJQUFLO1FBQ2xGLE1BQU12SCxTQUFTLElBQUksQ0FBQ0MsU0FBUyxDQUFDc0UsTUFBTXhFLGFBQWE7UUFDakQsTUFBTXFCLFlBQVksSUFBSSxDQUFDakMsUUFBUSxDQUFDa0MsY0FBYyxDQUFDckIsT0FBTztRQUN0RCxNQUFNLElBQUksQ0FBQ0gsZ0JBQWdCLENBQUN1SCxnQkFBZ0IsQ0FBQ2hHLFdBQVcsSUFBSSxDQUFDakIsaUJBQWlCLENBQUNKLGdCQUM3RXVILG9CQUFvQk87SUFDeEI7SUFFQTs7O0dBR0MsR0FDRCxNQUFNckksTUFBTVosVUFBVSxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDSSxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDSCxnQkFBZ0IsR0FBRyxJQUFJLENBQUNBLGdCQUFnQixDQUFDeUUsTUFBTSxDQUFDbEUsQ0FBQUEsS0FBTUEsT0FBT1I7WUFDbEUsSUFBSSxDQUFDLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUMyRSxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNzRCxPQUFPLEVBQUU7Z0JBQ2xEZ0IsY0FBYyxJQUFJLENBQUNDLFdBQVc7Z0JBQzlCLElBQUksQ0FBQzlJLE9BQU8sQ0FBQ3FDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDbkMsUUFBUSxDQUFDQyxFQUFFLENBQUMsb0JBQW9CLENBQUM7Z0JBQzVELElBQUksQ0FBQ2lILHFCQUFxQixHQUFHLENBQUM7Z0JBQzlCLE1BQU0sSUFBSSxDQUFDNUUsbUJBQW1CLENBQUN1RyxlQUFlLENBQUMsSUFBSSxDQUFDN0ksUUFBUTtnQkFDNUQsSUFBSSxDQUFDbUQsY0FBYyxDQUFDOUMsS0FBSztnQkFDekIsTUFBTTZCLGlCQUFpQixJQUFJLENBQUNsQyxRQUFRLENBQUNrQyxjQUFjO2dCQUNuRCxJQUFJLENBQUN4QixnQkFBZ0IsQ0FBQ29JLDZCQUE2QixDQUFDLElBQUksQ0FBQzlJLFFBQVEsQ0FBQ0MsRUFBRSxFQUFFLElBQUk7Z0JBQzFFLElBQUksQ0FBQ1MsZ0JBQWdCLENBQUNvSSw2QkFBNkIsQ0FBQyxJQUFJLENBQUM5SSxRQUFRLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNrRCxjQUFjO2dCQUN6RixJQUFJLENBQUN6QyxnQkFBZ0IsQ0FBQ29JLDZCQUE2QixDQUFDLElBQUksQ0FBQzlJLFFBQVEsQ0FBQ0MsRUFBRSxFQUFFLElBQUksQ0FBQ08sZUFBZTtnQkFDMUYsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ29JLDZCQUE2QixDQUFDLElBQUksQ0FBQzlJLFFBQVEsQ0FBQ0MsRUFBRSxFQUFFLElBQUksQ0FBQzhJLGNBQWM7Z0JBQ3pGLElBQUksQ0FBQ3JJLGdCQUFnQixDQUFDc0ksdUJBQXVCLENBQUMsSUFBSTtnQkFDbEQsSUFBSSxDQUFDRCxjQUFjLENBQUNFLElBQUk7Z0JBQ3hCLElBQUksQ0FBQ2hELHNDQUFzQyxHQUFHLENBQUM7Z0JBQy9DeEQsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ3lELHNDQUFzQyxFQUFFeEQsT0FBTyxDQUFDdUcsQ0FBQUEsVUFBV2hELGFBQWFnRDtnQkFDM0YsSUFBSSxDQUFDL0Msc0NBQXNDLEdBQUcsQ0FBQztnQkFDL0MxRCxPQUFPQyxNQUFNLENBQUNSLGdCQUFnQlMsT0FBTyxDQUFDQyxDQUFBQSxZQUNwQyxJQUFJLENBQUNsQyxnQkFBZ0IsQ0FBQ3lJLGtCQUFrQixDQUFDdkc7Z0JBQzNDLElBQUksQ0FBQytFLE9BQU8sR0FBRztnQkFDZixJQUFJLENBQUM3SCxPQUFPLENBQUNDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxRQUFRLENBQUNDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQztZQUM3RDtRQUNGO0lBQ0Y7SUFFQTs7O0dBR0MsR0FDRCxJQUFJeUYsZUFBZTtRQUNqQixPQUFPakQsT0FBT0MsTUFBTSxDQUFDLElBQUksQ0FBQ3dFLHFCQUFxQixFQUFFWSxNQUFNLENBQUMsQ0FBQ0MsS0FBSy9ELElBQU0rRCxPQUFPL0QsRUFBRTBCLFlBQVksRUFBRTtJQUM3RjtJQUVBOzs7R0FHQyxHQUNELElBQUkwRCxVQUFVO1FBQ1osT0FBTyxJQUFJLENBQUNwSixRQUFRO0lBQ3RCO0lBRUE7OztHQUdDLEdBQ0QsSUFBSXFKLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQ04sY0FBYztJQUM1QjtJQUVBLE1BQU1yQixnQ0FBZ0N6RixTQUFTLEVBQUUrRCxjQUFjLEVBQUVzRCxPQUFPLEVBQUU7UUFDeEUsTUFBTXpJLFNBQVMsSUFBSSxDQUFDSCxnQkFBZ0IsQ0FBQzZJLGdCQUFnQixDQUFDdEg7UUFDdEQsTUFBTWxCLFdBQVcsQ0FBQyxFQUFFRixPQUFPLENBQUMsRUFBRW1GLGVBQWUsQ0FBQztRQUM5QyxJQUFJO1lBQ0YsSUFBSSxJQUFJLENBQUNDLHNDQUFzQyxDQUFDbEYsU0FBUyxLQUFLdUksU0FBUztnQkFDckUsTUFBTUUsb0JBQW9CLEVBQUU7Z0JBQzVCL0csT0FBT3NDLElBQUksQ0FBQyxJQUFJLENBQUN4QixjQUFjLEVBQUVaLE9BQU8sQ0FBQ3dDLENBQUFBO29CQUN2QyxNQUFNbkMsZ0JBQWdCLElBQUksQ0FBQ0EsYUFBYSxDQUFDbUM7b0JBQ3pDLE1BQU1zRSxvQkFBb0I7d0JBQUMxRyxRQUFRb0M7b0JBQUc7b0JBQ3RDLElBQUduQyxlQUFlO3dCQUNoQnlHLGtCQUFrQnpHLGFBQWEsR0FBR0E7b0JBQ3BDO29CQUNBd0csa0JBQWtCNUosSUFBSSxDQUFDNko7Z0JBQ3pCO2dCQUNBLE1BQU0sSUFBSSxDQUFDL0ksZ0JBQWdCLENBQUNnSiw4QkFBOEIsQ0FBQ3pILFdBQVcrRCxnQkFDcEV3RDtZQUNKO1FBQ0YsRUFBRSxPQUFPcEosS0FBSztZQUNaLElBQUksQ0FBQ04sT0FBTyxDQUFDNkUsS0FBSyxDQUFDLENBQUMsMkRBQTJELEVBQUUsSUFBSSxDQUFDM0UsUUFBUSxDQUFDQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQ3BHLENBQUMsRUFBRStGLGVBQWUsQ0FBQyxFQUFFNUY7UUFDdkIsU0FBVTtZQUNSLElBQUksSUFBSSxDQUFDNkYsc0NBQXNDLENBQUNsRixTQUFTLEtBQUt1SSxTQUFTO2dCQUNyRSxJQUFJSyxrQkFBa0IsQUFBQ3RJLENBQUFBLEtBQUt1SSxNQUFNLEtBQU0sQ0FBQSxJQUFJLENBQUNDLCtCQUErQixHQUMxRSxJQUFJLENBQUNDLCtCQUErQixBQUFELElBQUssSUFBSSxDQUFDQSwrQkFBK0IsQUFBRCxJQUFLO2dCQUNsRixJQUFJLENBQUMzRCxzQ0FBc0MsQ0FBQ3BGLFNBQVMsR0FBR3lILFdBQVcsSUFDakUsSUFBSSxDQUFDZCwrQkFBK0IsQ0FBQ3pGLFdBQVcrRCxnQkFBZ0JzRCxVQUFVSztZQUM5RTtRQUNGO0lBQ0Y7SUFFQUkscUJBQXFCQyxRQUFRLEVBQUVDLFVBQVUsRUFBRTtRQUN6QyxJQUFJQyxRQUFRLENBQUM7UUFDYixJQUFJLE9BQU9GLGFBQWEsVUFBVTtZQUNoQ0UsTUFBTUYsUUFBUSxHQUFHQTtRQUNuQixPQUFPLElBQUlBLFVBQVU7WUFDbkJFLE1BQU1GLFFBQVEsR0FBR0EsU0FBU0csS0FBSztZQUMvQkQsTUFBTUUsYUFBYSxHQUFHSixTQUFTSyxLQUFLO1FBQ3RDO1FBQ0EsSUFBSSxPQUFPSixlQUFlLFVBQVU7WUFDbENDLE1BQU1ELFVBQVUsR0FBR0E7UUFDckIsT0FBTyxJQUFJQSxZQUFZO1lBQ3JCQyxNQUFNRCxVQUFVLEdBQUdBLFdBQVdFLEtBQUs7WUFDbkNELE1BQU1JLGVBQWUsR0FBR0wsV0FBV0ksS0FBSztRQUMxQztRQUNBLE9BQU9IO0lBQ1Q7SUFFQSxNQUFNdkUsb0JBQW9CL0UsYUFBYSxFQUFFdUUsR0FBRyxFQUFFO1FBQzVDLElBQUlDLFFBQVEsSUFBSSxDQUFDckQsU0FBUyxDQUFDbkI7UUFDM0IsSUFBSXdFLFNBQVNBLE1BQU1JLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDbUMsT0FBTyxFQUFFO1lBQ3JELElBQUk7Z0JBQ0YsTUFBTTRDLHdCQUF3QixNQUFNLElBQUksQ0FBQzVKLFdBQVcsQ0FBQ0M7Z0JBQ3JELElBQUcySix1QkFBdUI7b0JBQ3hCbkYsTUFBTU0sWUFBWSxHQUFHO29CQUNyQk4sTUFBTUsscUNBQXFDLEdBQUc7b0JBQzlDLE9BQU9MLE1BQU1pQix3QkFBd0I7Z0JBQ3ZDO2dCQUNBLElBQUksQ0FBQ0ksK0JBQStCLENBQUM3RjtZQUN2QyxFQUFFLE9BQU9SLEtBQUs7Z0JBQ1osSUFBSSxDQUFDTixPQUFPLENBQUM2RSxLQUFLLENBQUMsMENBQTBDLElBQUksQ0FBQzNFLFFBQVEsQ0FBQ0MsRUFBRSxHQUMzRSxNQUFNVyxnQkFBZ0IsMEJBQTBCUjtnQkFDbEQsSUFBSWdGLE1BQU1JLGlCQUFpQixLQUFLTCxLQUFLO29CQUNuQyxJQUFJQyxNQUFNaUIsd0JBQXdCLEVBQUU7d0JBQ2xDSCxhQUFhZCxNQUFNaUIsd0JBQXdCO29CQUM3QztvQkFDQWpCLE1BQU1pQix3QkFBd0IsR0FBR21DLFdBQVcsSUFBSSxDQUFDN0MsbUJBQW1CLENBQUM2RSxJQUFJLENBQUMsSUFBSSxFQUFFNUosZUFBZXVFLE1BQzdGQyxNQUFNSyxxQ0FBcUMsR0FBRztvQkFDaERMLE1BQU1LLHFDQUFxQyxHQUFHcEUsS0FBS29KLEdBQUcsQ0FBQ3JGLE1BQU1LLHFDQUFxQyxHQUFHLEdBQUc7Z0JBQzFHO1lBQ0Y7UUFDRjtJQUNGO0lBRUExRCxVQUFVbkIsYUFBYSxFQUFFO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLENBQUNzRyxxQkFBcUIsQ0FBQyxLQUFLdEcsY0FBYyxFQUFFO1lBQ25ELElBQUksQ0FBQ3NHLHFCQUFxQixDQUFDLEtBQUt0RyxjQUFjLEdBQUc7Z0JBQy9DQTtnQkFDQW1HLG9CQUFvQixDQUFDO2dCQUNyQkYsbUJBQW1CLENBQUM7Z0JBQ3BCckIsbUJBQW1CTTtnQkFDbkJMLHVDQUF1QztnQkFDdkNDLGNBQWM7Z0JBQ2RHLG1DQUFtQ0M7Z0JBQ25DOUQsdUJBQXVCOEQ7Z0JBQ3ZCQyxjQUFjO1lBQ2hCO1FBQ0Y7UUFDQSxPQUFPLElBQUksQ0FBQ21CLHFCQUFxQixDQUFDLEtBQUt0RyxjQUFjO0lBQ3ZEO0lBRUE2RixnQ0FBZ0M3RixhQUFhLEVBQUU7UUFDN0MsSUFBSXdFLFFBQVEsSUFBSSxDQUFDckQsU0FBUyxDQUFDbkI7UUFDM0IsSUFBSXdFLFNBQVMsQ0FBQyxJQUFJLENBQUN1QyxPQUFPLEVBQUU7WUFDMUIsSUFBSXZDLE1BQU1nQixzQkFBc0IsRUFBRTtnQkFDaENGLGFBQWFkLE1BQU1nQixzQkFBc0I7WUFDM0M7WUFDQSxJQUFJQSx5QkFBeUIsSUFBSSxLQUFLO1lBQ3RDaEIsTUFBTWdCLHNCQUFzQixHQUMxQm9DLFdBQVcsSUFBTSxJQUFJLENBQUNrQyw2QkFBNkIsQ0FBQzlKLGdCQUFnQndGO1FBQ3hFO0lBQ0Y7SUFFQXNFLDhCQUE4QjlKLGFBQWEsRUFBRTtRQUMzQyxJQUFJd0UsUUFBUSxJQUFJLENBQUNyRCxTQUFTLENBQUNuQjtRQUMzQixJQUFJd0UsU0FBUyxDQUFDLElBQUksQ0FBQ3VDLE9BQU8sRUFBRTtZQUMxQixJQUFJL0Ysb0JBQW9Cd0QsTUFBTXBELHFCQUFxQjtZQUNuRCxJQUFJMEQsZUFBZSxDQUFDLENBQUNOLE1BQU15QixpQkFBaUIsQ0FBQ2pGLGtCQUFrQjtZQUMvRCxJQUFJLENBQUM4RCxnQkFBZ0I5RCxxQkFBcUJ3RCxNQUFNSSxpQkFBaUIsRUFBRTtnQkFDakUsSUFBSSxDQUFDMUYsT0FBTyxDQUFDNkssSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMzSyxRQUFRLENBQUNDLEVBQUUsQ0FBQyxDQUFDLEVBQUVXLGNBQWMsOENBQThDLENBQUMsR0FDcEcsQ0FBQyxFQUFFZ0Isa0JBQWtCLHVCQUF1QixDQUFDO2dCQUMvQyxJQUFJLENBQUMrRCxtQkFBbUIsQ0FBQy9FLGVBQWV3RSxNQUFNSSxpQkFBaUI7WUFDakU7UUFDRjtJQUNGO0lBL3FCQTs7Ozs7Ozs7OztHQVVDLEdBQ0RvRixZQUFZQyxlQUFlLEVBQUVDLG1CQUFtQixFQUFFMUIsT0FBTyxFQUFFcEUsY0FBYyxFQUFFK0Ysa0JBQWtCLEVBQzNGQyxnQkFBZ0IsRUFBRUMsd0JBQXdCLENBQUU7UUFDNUMsS0FBSyxDQUFDSixpQkFBaUJ6QjtRQUN2QjZCLDJCQUEyQkEsNEJBQTRCLENBQUM7UUFDeEQsTUFBTUMsWUFBWSxJQUFJQyx5QkFBZ0I7UUFDdEMsSUFBSSxDQUFDckIsK0JBQStCLEdBQUdvQixVQUFVRSxlQUFlLENBQUNILHlCQUF5QkksaUJBQWlCLEVBQUUsR0FDM0c7UUFDRixJQUFJLENBQUN4QiwrQkFBK0IsR0FBR3FCLFVBQVVFLGVBQWUsQ0FBQ0gseUJBQXlCSyxpQkFBaUIsRUFBRSxLQUMzRztRQUNGLElBQUksQ0FBQ2hKLG1CQUFtQixHQUFHeUk7UUFDM0IsSUFBSSxDQUFDeEosaUJBQWlCLEdBQUd5SjtRQUN6QixJQUFJLENBQUMxRixvQkFBb0IsR0FBR3dGO1FBQzVCLElBQUksQ0FBQzNILGNBQWMsR0FBRyxJQUFJb0ksc0JBQWEsQ0FBQ25DLFNBQVMwQixxQkFBcUIsSUFBSSxDQUFDcEssZ0JBQWdCO1FBQzNGLElBQUksQ0FBQ0YsZUFBZSxHQUFHd0Usa0JBQWtCLElBQUl3Ryw2QkFBb0I7UUFDakUsSUFBSSxDQUFDekMsY0FBYyxHQUFHLElBQUkwQyxnQ0FBdUIsQ0FBQyxJQUFJO1FBQ3RELElBQUksQ0FBQy9LLGdCQUFnQixDQUFDZ0wsMEJBQTBCLENBQUN0QyxRQUFRbkosRUFBRSxFQUFFLElBQUk7UUFDakUsSUFBSSxDQUFDUyxnQkFBZ0IsQ0FBQ2dMLDBCQUEwQixDQUFDdEMsUUFBUW5KLEVBQUUsRUFBRSxJQUFJLENBQUNrRCxjQUFjO1FBQ2hGLElBQUksQ0FBQ3pDLGdCQUFnQixDQUFDZ0wsMEJBQTBCLENBQUN0QyxRQUFRbkosRUFBRSxFQUFFLElBQUksQ0FBQ08sZUFBZTtRQUNqRixJQUFJLENBQUNFLGdCQUFnQixDQUFDZ0wsMEJBQTBCLENBQUN0QyxRQUFRbkosRUFBRSxFQUFFLElBQUksQ0FBQzhJLGNBQWM7UUFDaEZ0RyxPQUFPQyxNQUFNLENBQUMwRyxRQUFRbEgsY0FBYyxFQUNqQ1MsT0FBTyxDQUFDQyxDQUFBQSxZQUFhLElBQUksQ0FBQ2xDLGdCQUFnQixDQUFDaUwsb0JBQW9CLENBQUMsSUFBSSxFQUFFL0k7UUFDekUsSUFBSSxDQUFDVyxjQUFjLEdBQUcsQ0FBQztRQUN2QixJQUFJLENBQUMyRCxxQkFBcUIsR0FBRyxDQUFDO1FBQzlCLElBQUksQ0FBQ2pCLHNDQUFzQyxHQUFHLENBQUM7UUFDL0MsSUFBSSxDQUFDRSxzQ0FBc0MsR0FBRyxDQUFDO1FBQy9DLElBQUksQ0FBQ3pHLGdCQUFnQixHQUFHLEVBQUU7UUFDMUIsSUFBSSxDQUFDSSxPQUFPLEdBQUc4TCxlQUFhLENBQUNDLFNBQVMsQ0FBQztJQUN6QztBQTJvQkYifQ==